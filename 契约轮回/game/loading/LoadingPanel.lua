---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by win 10.
--- DateTime: 18/11/19 17:33
---
LoadingPanel = LoadingPanel or class("LoadingPanel", BaseItem)
local this = LoadingPanel

local ConfigLanguage = require('game.config.language.CnLanguage');

LoadingPanel.LOGIN_TIME = "LoginPanel.LoginTime";

function LoadingPanel:ctor(parent_node, layer)
    logWarn("OPEN_LOADINGPANEL");
    self.abName = "loading"
    self.image_ab = "loading_image";
    self.assetName = "LoadingPanel"
    self.layer = "UI"
    self.panel_type = 2;
    self.events = {};
    self.selectedIndex = 1;
    self:GetAllLoading();
    self.all = nil;
    self.mask = AddBgMask(LayerManager:GetInstance():GetLayerByName(LayerManager.LayerNameList.Top).gameObject, 0, 0, 0, 255)
    self.loadLevel = Constant.LoadResLevel.Urgent

    self.pre_load_count     = 0
    self.pre_load_all_count = 9
    self.pre_object_count = 0
    self.pre_object_count_all_count = 0

    -- self.last_value = 0

    LoadingPanel.super.Load(self);
end

function LoadingPanel:dctor()
    --logWarn("LoadingPanel:dctor" .. Time.timeSinceLevelLoad);
    --logWarn(debug.traceback());
    self:StopTime()
    self.last_action = nil
    self.number_action = nil
    self:RemoveAction()

    if self.preo_gress_time_id then
        GlobalSchedule:Stop(self.preo_gress_time_id)
        self.preo_gress_time_id = nil
    end

    if self.events then
        GlobalEvent:RemoveTabListener(self.events)
        self.events = {}
    end

    if self.mask then
        destroy(self.mask.gameObject);
    end
    self.mask = nil;
    
    destroyTab(self.items);

    GlobalEvent:RemoveTabListener(self.events);
    UpdateBeat:Remove(self.Update, self);

    LoadingCtrl:GetInstance():ClearAll();
    if self.destroySchedule then
        GlobalSchedule.StopFun(self.destroySchedule);
    end
    self.destroySchedule = nil;
    self.isTwoSecOrDownCom = nil;
    self.all = nil;

    if PlatformManager:GetInstance():IsMobile() then
        MapLayer.ExecuteFrequence = 5;
    end

    if LoadingCtrl:GetInstance().loadingPanel == self then
        LoadingCtrl:GetInstance().loadingPanel = nil
        GlobalEvent:Brocast(EventName.DestroyLoading)
        lua_resMgr:CheckUnUseAssset(true)
    end

    self.LoadingConfigs = nil;
    self.bg = nil;
    self.desText = nil;
    self.Text = nil;
    self.progress_bar = nil;
    self.loadingText = nil;
end

--function LoadingPanel:Open()
--    --WindowPanel.Open(self);
--end

function LoadingPanel:LoadCallBack()
    self.nodes = {
        "bg", "desText", "Text", "progress", "progress/progress_bar", "loadingText",
        "progress/light",
    }
    --logWarn("LoadingPanel:LoadCallBack".. Time.timeSinceLevelLoad);
    self:GetChildren(self.nodes)

    SetLocalPosition(self.transform, 0, 0, 0);

    --AddBgMask(self.gameObject , 0,0,0,255);
    --logWarn(">>>>>>>>>>lkjjhkjjhkjhkjh>>>>>>");
    --logWarn(self.is_dctored);
    self:InitUI(); 
    self:AddEvent();
    self.uiInitX = -432.1;


    -- 切换场景 释放lua内存
    -- collectgarbage("collect")

    -- C# gc 资源gc lua gc
    DebugManager:GC()

    Yzprint('--LaoY LoadingPanel.lua,line 102--', Time.time)
    SceneManager.Instance:CreateScene(SceneManager:GetInstance():GetSceneId());
    --LoadingCtrl:GetInstance():ShowMask(false);

    SetVisible(self.desText, false)

    self:StartTime()
end

function LoadingPanel:InitUI()
    self.bg = GetImage(self.bg);
    SetGameObjectActive(self.bg);
    self.desText = GetText(self.desText);
    self.desText.text = "";
    self.Text = GetText(self.Text);
    self.Text.text = "";
    self.progress_bar = GetImage(self.progress_bar);
    self.loadingText = GetText(self.loadingText);
    --self.loadingText.text = "0/100";
    self.Text.text = "Loading map";

    self.lightx,self.lighty,self.lightz = GetLocalPosition(self.light)

    self.progress_bar.fillAmount = 0
    self.loadingText.text = string.format("%d/100", 0)


    local configTabs = self.LoadingConfigs;
    if #configTabs == 0 then
        self:GetAllLoading();
        configTabs = self.LoadingConfigs;
    end
    local isSetFlag = false;
    local level = RoleInfoModel:GetInstance():GetMainRoleLevel();
    for i = 1, #configTabs do
        local configTab = configTabs[i];
        local levelTab = String2Table(configTab.lv);
        if levelTab then
            if level > tonumber(levelTab[1]) and level <= levelTab[2] then
                local key = LoadingPanel.LOGIN_TIME .. configTab.loading_type .. "@" .. configTab.id
                local logintime = CacheManager:GetInstance():GetInt(key);
                local timesTab = String2Table(configTab.n_image);
                if logintime >= #timesTab then
                    --随机显示
                    local randomTab = String2Table(configTab.image);
                    local max = 0;
                    for r = 1, #randomTab do
                        max = max + tonumber(randomTab[r][1]);
                    end
                    local randomNum = math.random(max);
                    local current = 0;
                    for r = 1, #randomTab do
                        current = current + randomTab[r][1];
                        if current > randomNum then
                            local config = randomTab[r];
                            if config and #config >= 3 then
                                local textConfig = Config.db_loading_text[config[3]]
                                if textConfig then
                                    --print2(tostring(textConfig.dec));
                                    self.desText.text = tostring(textConfig.dec);
                                end
                                --print2("preloading_" .. tostring(config[2]));
                                lua_resMgr:SetImageTexture(self, self.bg, self.image_ab, "preloading_" .. tostring(config[2]), false, nil, true, Constant.LoadResLevel.Urgent);
                                isSetFlag = true;
                            end
                            break ;
                        end
                    end
                else
                    --固定顺序显示
                    logintime = logintime + 1;
                    if LoadingCtrl:GetInstance():IsCanSave(key) then
                        CacheManager:GetInstance():SetInt(key, logintime);
                    end

                    local config = timesTab[logintime];--{1,10000,1}
                    if config and #config >= 3 then
                        local textConfig = Config.db_loading_text[config[3]];
                        if textConfig then
                            --print2(tostring(textConfig.dec));
                            self.desText.text = tostring(textConfig.dec);
                        end
                        --print2("preloading_" .. tostring(config[2]));
                        lua_resMgr:SetImageTexture(self, self.bg, self.image_ab, "preloading_" .. tostring(config[2]), false, nil, true, Constant.LoadResLevel.Urgent);
                        isSetFlag = true;
                    end

                end

            end
        end

    end
    if not isSetFlag then
        SetGameObjectActive(self.bg, true);
    end
    if PlatformManager:GetInstance():IsMobile() then
        MapLayer.ExecuteFrequence = 1;
    end
end

function LoadingPanel:AddEvent()
    -- local function call_back(has)
    --     if self.loaded then
    --         self.loaded = self.loaded + 1;
    --     else
    --         self.loaded = 1;
    --     end

    -- end
    -- --地图加载一格完成;
    -- AddEventListenerInTab(EventName.BLOCK_LOAD_FINISH, call_back, self.events);

    --print2(debug.traceback());
    --print2(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
    -- UpdateBeat:Add(self.Update, self, 1, 1);


    local function call_back(pre_object_count,pre_object_count_all_count)
        self.pre_object_count = pre_object_count
        self.pre_object_count_all_count = pre_object_count_all_count
        self:StartprogressTime()
    end
    self.events[#self.events+1] = GlobalEvent:AddListener(EventName.PreLoadObject, call_back)

    local function call_back(pre_load_count,pre_load_all_count)
        self.pre_load_count     = pre_load_count
        self.pre_load_all_count = pre_load_all_count
        self:StartprogressTime()
    end
    self.events[#self.events+1] = GlobalEvent:AddListener(EventName.BLOCK_LOAD_FINISH, call_back)
end


LoadingPanel.LoadingConfigs = {};
function LoadingPanel:GetAllLoading()
    self.LoadingConfigs = {};
    for k, v in pairs(Config.db_loading) do
        if v.loading_type == 2 then
            table.insert(self.LoadingConfigs, v);
        end
    end
end

function LoadingPanel:StartTime()
    local function step()
        local load_count = self.pre_load_count + self.pre_object_count
        local all_count = self.pre_load_all_count + self.pre_object_count_all_count
        if load_count ~= 0 and load_count >= all_count then
            self:StopTime()
            return
        end
        if not self.last_update_view_time or Time.time - self.last_update_view_time > 0.8 then
            self:UpdateView()
        end
    end
    self.time_id = GlobalSchedule:Start(step,1.0)
    step()
end

function LoadingPanel:StopTime()
    if self.time_id then
        GlobalSchedule:Stop(self.time_id)
        self.time_id = nil
    end
end

function LoadingPanel:StartprogressTime()
    if self.preo_gress_time_id then
        return
    end
    local function step()
        self:UpdateView()
        if self.preo_gress_time_id then
            GlobalSchedule:Stop(self.preo_gress_time_id)
            self.preo_gress_time_id = nil
        end
    end
    self.preo_gress_time_id = GlobalSchedule:StartOnce(step,1)
    -- step()
end

local allTime = 3.0
function LoadingPanel:UpdateView()
    self.last_update_view_time = Time.time
    local load_count = self.pre_load_count + self.pre_object_count
    local all_count = self.pre_load_all_count + self.pre_object_count_all_count
    local value = load_count/all_count

    if self.last_value and self.last_value >= value then
        value = self.last_value + 0.02
    end
    value = Mathf.Clamp01(value)

    local time
    if self.last_value and self.last_time then
        time = allTime * (value - self.last_value) + self.last_time * (1-self.last_action:getProgress())
    else
        time = allTime * value
    end

    local show_last_value = self.last_value and self.last_value * 100 or 0
    if self.number_action and not self.number_action:isDone() then
        show_last_value = self.number_action.cur_num 
    end

    self:RemoveAction()
    local pregress_bar_action = cc.ValueTo(time,value, self.progress_bar, "fillAmount")
    -- self.loadingText.text = string.format("%d/100", value * 100)

    local number_action = cc.NumberTo(time,show_last_value,value * 100,true,"%d/100",self.loadingText)
    
    -- local targetx = self.lightx - (20 * value) + value * 828
    local targetx=self.lightx+(value*828)

    local move_action = cc.MoveTo(time,targetx,self.lighty,0)
    local action = cc.Spawn(pregress_bar_action,move_action,number_action)
    action = cc.Sequence(action,cc.DelayTime(0.5),cc.CallFunc(function()
        -- if value == 1.0 then
        if load_count/all_count == 1.0 then
            -- GlobalEvent:Brocast(LoginEvent.OpenLoginPanel)
            self:destroy()
        end
    end))
    cc.ActionManager:GetInstance():addAction(action,self.light)
    self.last_value = value
    self.last_time = time
    self.last_action = move_action
    self.number_action = number_action
end

function LoadingPanel:RemoveAction()
    cc.ActionManager:GetInstance():removeAllActionsFromTarget(self.light)
end

function LoadingPanel:Update()
    do
        return
    end
    local loaded = 0;
    local isLoadAll = true;
    local mapmgr = MapManager:GetInstance();
    if not self.all then
        if mapmgr.map_layer.need_load_list then
            local all = 0;
            local loadingmapTab = mapmgr.map_layer.scene_map_list[mapmgr.map_layer.cur_scene_id];
            for k, v in pairs(loadingmapTab) do
                all = all + 1;
            end

            if all > 0 then
                self.all = all;
            end
        end

        self.Text.text = "Loading map....";
        self.progress_bar.fillAmount = 0;
        return ;
    end

    if self.all then
        if self.loaded then
            self.progress_bar.fillAmount = self.loaded / self.all;
            self.loadingText.text = string.format("%d/" .. self.all, self.loaded);

            if self.loaded >= self.all then
                self.progress_bar.fillAmount = self.loaded / self.all;

                self.Text.text = "Entering map...";
                --如果地图下载完成比较快,那就需要一个定时器
                self:CloseInSecond();
            end
        else
            self.progress_bar.fillAmount = 0;
            self.loadingText.text = string.format("%d/" .. self.all, 0);
        end
    end

    if self.progress_bar.fillAmount < 0.4 then
        if self.fillAmount then
            self.fillAmount = self.fillAmount + 0.001;
        else
            self.fillAmount = self.progress_bar.fillAmount;
        end
        self.progress_bar.fillAmount = self.fillAmount;
    end
end

function LoadingPanel:CloseInSecond()
    if not self.destroySchedule then
        local callback = function()
            self:destroy();
        end
        self.destroySchedule = GlobalSchedule.StartFunOnce(callback, 0.5);
    end
end