---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by win 10.
--- DateTime: 18/11/13 17:08
---

CountDownText = CountDownText or class("CountDownText", Node)
local this = CountDownText
--param支持如下参数
--[[
formatText,格式化字符串,默认为"%s"就是直接显示时间
isShowMin,是否需要显示分钟--默认为true
isShowHour,是否需要显示小时--默认为false
isShowDay,是否需要显示天数
isChineseType,是否显示中文
time,倒计时时间--没有默认
duration,间隔,默认为1秒,
formatTime,时间的格式化,默认为%02d
is_auto_hide,在时间单位为0的时候不显示
nodes 默认为"countdowntext",可修改为其它
--]]
function CountDownText:ctor(obj, param)
    --self.parent_node = LayerManager:GetInstance():GetLayerByName(LayerManager.LayerNameList.SceneText)
    --self.builtin_layer = LayerManager.BuiltinLayer.Default
    --self.position = {x=0,y=0, z=0}
    if not obj then
        return
    end
    self.transform = obj.transform
    self.gameObject = self.transform.gameObject;

    self.param = param;
    self.time = param.time;
    self.duration = param.duration or 1;
    self.formatTime = param.formatTime or "%02d";--格式化,默认00这样,
    self.formatText = param.formatText or "%s";
    self.isShowMin = param.isShowMin;
    self.isShowHour = param.isShowHour;
    self.isShowDay = param.isShowDay;
    self.isChineseType = param.isChineseType
    self.split = param.split or ":"
    self.is_auto_hide = param.is_auto_hide
    self.nodes = param.nodes;

    self.isRuning = false;
    self.image_ab = "system_image";

    self.transform_find = self.transform.Find;
    self.events = {};

    self:Init();
    self:AddEvent();
end

function CountDownText:ResetParam(param)
    self.param = param;
    self.time = param.time;
    self.duration = param.duration or 1;
    self.formatTime = param.formatTime or "%02d";--格式化,默认00这样,
    self.formatText = param.formatText or "%s";
    self.isShowMin = param.isShowMin;
    self.isShowHour = param.isShowHour;
    self.isShowDay = param.isShowDay;
    self.split = param.split or ":"
end

function CountDownText:dctor()
    self.transform = nil
    self.gameObject = nil
    GlobalEvent:RemoveTabListener(self.events);
    self:StopSchedule();
    self.call_back = nil;
    self.update_call_back = nil;
    self.isRuning = false;
    self.param = nil;
end

function CountDownText:StopSchedule()
    if self.schedule then
        GlobalSchedule:Stop(self.schedule);
        self.schedule = nil
    end
    self.isRuning = false;
end

function CountDownText:Init()
    self.is_loaded = true;
    if not self.nodes then
        self.nodes = {
            "countdowntext",
        }
    end

    self:GetChildren(self.nodes)

    self.countdowntext = GetText(self[self.nodes[1]]);

    if self.time then
        self:StartSechudle(self.time);
    end
    self:AddEvent();
end

function CountDownText:AddEvent()

end
--ex:time = os.time() + 60
function CountDownText:StartSechudle(time, call_back, update_call_back)
    self.time = time;
    self.call_back = call_back;
    self.update_call_back = update_call_back;
    self.countdowntext.text = "";
    local timeTab = TimeManager:GetLastTimeData(os.time(), time);
    if timeTab then
        self:StopSchedule();
        self.schedule = GlobalSchedule.StartFun(handler(self, self.CountTime), self.duration, -1);
        self.isRuning = true;
        SetVisible(self.countdowntext, true);
        -- self.countdowntext:SetVisible(true)
        self:CountTime();
    else
        if call_back then
            call_back();
        end
    end
end

function CountDownText:CountTime()
    local timeTab = TimeManager:GetLastTimeData(os.time(), self.time);
    local timestr = "";
    local deference = self.time - os.time()
    if timeTab then
        if self.isShowMin then
            timeTab.min = timeTab.min or 0;
            if timeTab.min == 0 and self.is_auto_hide and deference < 60 then
                timeTab.min = nil
            end
        end
        if self.isShowHour then
            timeTab.hour = timeTab.hour or 0;
            if timeTab.hour == 0 and self.is_auto_hide and deference < TimeManager.HourSec then
                timeTab.hour = nil
            end
        end
        if self.isShowDay then
            timeTab.day = timeTab.day or 0;
            if timeTab.day == 0 and self.is_auto_hide and deference < TimeManager.DaySec then
                timeTab.day = nil
            end
        else
            timeTab.day = nil;
        end
        if self.isChineseType then
            if timeTab.day and timeTab.day ~= 0 then
                timestr = timestr .. string.format(self.formatTime, timeTab.day) .. "Days ";
            end
            if timeTab.hour then
                timestr = timestr .. string.format(self.formatTime, timeTab.hour) .. "hr ";
            end
            if timeTab.min then
                timestr = timestr .. string.format(self.formatTime, timeTab.min) .. "min ";
            end
        else
            if timeTab.day then
                timestr = timestr .. string.format(self.formatTime, timeTab.day) .. self.split;
            end
            if timeTab.hour then
                timestr = timestr .. string.format(self.formatTime, timeTab.hour) .. self.split;
            end
            if timeTab.min then
                timestr = timestr .. string.format(self.formatTime, timeTab.min) .. self.split;
            end
        end
        if self.isChineseType then
            if timeTab.sec then
                timestr = timestr .. string.format(self.formatTime, timeTab.sec) .. "sec";
            end
        else
            if timeTab.sec then
                timestr = timestr .. string.format(self.formatTime, timeTab.sec);
            end
        end
        self.countdowntext.text = string.format(self.formatText, timestr);
        self.isRuning = true;
        if self.update_call_back then
            self.update_call_back(timeTab);
        end
    else
        self:StopSchedule()
        self.countdowntext.text = ""
        self.countdowntext.gameObject:SetActive(false);
        if self.call_back then
            self.call_back(self);
        end
        self.isRuning = false;
        self.call_back = nil;
    end
end

function CountDownText:SetColor(color, outline_color)
    if color then
        SetColor(self.countdowntext, color.r, color.g, color.b, color.a)
    end
    if outline_color then
        SetOutLineColor(self.countdowntext, outline_color.r, outline_color.g, outline_color.b, outline_color.a)
    end
end

function CountDownText:SetGlobalPosition(x, y, z)
    self.position = { x = x, y = y, z = z }
    SetGlobalPosition(self.transform, x, y, z)
end

function CountDownText:ActiveText()
    SetVisible(self.countdowntext, true)
end

