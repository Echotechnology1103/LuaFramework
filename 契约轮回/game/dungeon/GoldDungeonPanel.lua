---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by win 10.
--- DateTime: 2018/10/9 17:34
--- 经验副本的UI

GoldDungeonPanel = GoldDungeonPanel or class("GoldDungeonPanel", DungeonMainBasePanel)
local this = GoldDungeonPanel

function GoldDungeonPanel:ctor()
    self.abName = "dungeon"
    self.assetName = "GoldDungeonPanel"

    self.events = {};
    self.schedules = {};
end

function GoldDungeonPanel:dctor()
    self.model = nil;
    GlobalEvent:RemoveTabListener(self.events);
    self:StopAllSchedules()
    if self.boom_exit_schedule then
        GlobalSchedule.StopFun(self.boom_exit_schedule);
    end
    self.staritems = nil;
    if self.onceFade then
        GlobalSchedule.StopFun(self.onceFade);
    end
    self.onceFade = nil;
end

function GoldDungeonPanel:Open(data)
    WindowPanel.Open(self);
    self.data = data;
end

function GoldDungeonPanel:LoadCallBack()
    self.nodes = {
        "dungeonNamebg", "dungeonNametxt", "expshow/txt", "expshow/txt/text_1", "expshow/txt/text_2", "expshow/stars/star_1", "expshow/stars/star_2",
        "expshow/stars/star_3", "expshow/txt/text_3", "expshow/expget", "expshow", "expshow/stars",
        "startTime", "startTime/time", "endTime", "endTime/endText", "expshow/goldget", "boom_exit",
        "expshow/killedmon",
    }
    self:GetChildren(self.nodes);

    SetLocalPosition(self.transform, 0, 0, 0)

    SetAlignType(self.expshow, bit.bor(AlignType.Left, AlignType.Null));
    local posx, posy, posz = GetLocalPosition(self.expshow.transform);
    SetLocalPosition(self.expshow.transform, posx, posy + 50, posz);

    self:Init();

    self:AddEvent();

    --开一个定时器固定时间请求副本信息
    self:RequestInfo();
    self.schedules[1] = GlobalSchedule:Start(handler(self, self.RequestInfo), 2, -1);

    --结束副本时间
    self.schedules[3] = GlobalSchedule:Start(handler(self, self.EndDungeon), 1, -1);

    self.onceFade = GlobalSchedule.StartFunOnce(function()
        if self.dungeonNametxt and self.dungeonNamebg then
            local moveAction = cc.FadeOut(3, self.dungeonNametxt);
            cc.ActionManager:GetInstance():addAction(moveAction, self.dungeonNametxt.transform);
            moveAction = cc.FadeOut(3, self.dungeonNamebg);
            cc.ActionManager:GetInstance():addAction(moveAction, self.dungeonNamebg.transform);
        end
    end, 1);

    --为了红点
    DungeonCtrl:GetInstance():RequestDungeonPanel(enum.SCENE_STYPE.SCENE_STYPE_DUNGE_COIN);
end

function GoldDungeonPanel:RequestInfo()
    --print2("请求经验副本信息");
    DungeonCtrl:GetInstance():RequeseExpDungeonInfo();
end

function GoldDungeonPanel:StartDungeon()
    --print2(self.start_dungeon_time .. "倒数开始经验副本");
    self.start_dungeon_time = self.start_dungeon_time - 1;
    self.time.text = tostring(self.start_dungeon_time);
    if self.start_dungeon_time <= 0 then
        self.startTime.gameObject:SetActive(false);

        if self.schedules[2] then
            GlobalSchedule:Stop(self.schedules[2]);
        end
        self.schedules[2] = nil;
        --防止自动战斗不打
        TaskModel:GetInstance():StopTask();--先停掉任务,因为任务优先级高
        --停止自动寻路
        OperationManager:GetInstance():StopAStarMove();
    end
end

function GoldDungeonPanel:EndDungeon()
    if self.endDungeonTime and self.start_dungeon_time <= 0 then
        self.endTime.gameObject:SetActive(true);
    end
    if self.endDungeonTime and self.endTime.gameObject.activeSelf then
        --self.endDungeonTimeTab = os.date("*t" , (self.endDungeonTime - os.time()));
        self.endDungeonTimeTab2 = TimeManager:GetLastTimeData(os.time(), self.endDungeonTime);
        if not self.endDungeonTimeTab2 then
            self.endTime.gameObject:SetActive(false);
            if self.schedules[3] then
                GlobalSchedule:Stop(self.schedules[3]);
                return ;
            end
        end
        if not self.endDungeonTimeTab2.min then
            self.endDungeonTimeTab2.min = 0;
        end
        self.endText.text = tostring(string.format("%02d", self.endDungeonTimeTab2.min) .. ":" .. string.format("%02d", self.endDungeonTimeTab2.sec));
    end
    GoldDungeonPanel.super.EndDungeon(self);
end
--[[
expget.text = "通关提醒:<color=#EBE288>优先击杀随机出现的炸弹怪可加速通关</color>"
--]]
function GoldDungeonPanel:Init()
    self.expget = GetText(self.expget);

    self.text_1 = GetText(self.text_1);
    self.text_2 = GetText(self.text_2);
    self.text_3 = GetText(self.text_3);

    self.boom_exit = GetImage(self.boom_exit);
    SetGameObjectActive(self.boom_exit.gameObject, false);
    self.goldget = GetText(self.goldget);

    self.staritems = {};--三颗星
    for i = 1, 3, 1 do
        self.staritems[i] = GetToggle(self["star_" .. i]);
        self.staritems[i].isOn = false;
    end

    self.killedmon = GetText(self.killedmon);

    self.time = GetText(self.time);--倒数时间

    self.endText = GetText(self.endText);

    self.endTime.gameObject:SetActive(false);

    if self.data then
        local enter = DungeonModel.GetInstance().DungeEnter[self.data.scene];
        if enter and enter.floor then
            local data = Config.db_dunge_coin[enter.floor];
            if data then
                local tab = String2Table(data.rating);
                self.text_1.text = "Clear Dungeon";
                if tab and #tab > 1 then
                    self.text_2.text = "Defeat<color=#13C110>" .. tostring(tab[1]) .. "</color>Vault guards";
                    self.text_3.text = "Defeat<color=#13C110>" .. tostring(tab[2]) .. "</color>Vault guards";
                end
            end
        end
    end

    self.killedmon.text = "Slain: <color=#9AF63F>0</color>"

    self.dungeonNametxt = GetImage(self.dungeonNametxt);
    self.dungeonNamebg = GetImage(self.dungeonNamebg);
end

function GoldDungeonPanel:AddEvent()
    local call_back = function()
        SetGameObjectActive(self.endTime.gameObject, false);
        self.hideByIcon = true;
    end

    self.events[#self.events + 1] = GlobalEvent.AddEventListener(MainEvent.ShowTopRightIcon, call_back);

    local call_back1 = function()
        SetGameObjectActive(self.endTime.gameObject, true);
        self.hideByIcon = false;
    end

    self.events[#self.events + 1] = GlobalEvent.AddEventListener(MainEvent.HideTopRightIcon, call_back1);
    --[[
        ["star"]=0,
        ["prep_time"]=1543479082,
        ["id"]=11008,
        ["cur_wave"]=1,
        ["max_wave"]=1,
        ["end_time"]=1543479452,
        ["coin_gain"]=0
    --]]
    local function callBack1 (data)
        --print2(Table2String(data));
        self.goldget.text = GetShowNumber(tonumber(data.coin_gain));
        --if data.coin_gain > 100000000 then
        --    data.coin_gain = (data.coin_gain / 100000000) .. "亿";
        --else
        --    data.coin_gain = (data.coin_gain / 10000) .. "万";
        --end



        for i = 1, 3, 1 do
            self.staritems[i].isOn = false;
        end

        if data["star"] then
            local bs = BitState(data["star"])
            for i = 1, 3, 1 do
                self.staritems[i].isOn = bs:Contain(BitState.State[i]);
            end
        end
        local killnum = 0;
        if data["count"] then
            for k, v in pairs(data["count"]) do
                killnum = killnum + v;
            end
        end

        self.killedmon.text = "Slain: <color=#9AF63F>" .. killnum .. "</color>"

        --self.expget.text = tostring(data.coin_gain);--获得到的金币

        if not self.endDungeonTime then
            self.endDungeonTime = data.end_time;
            --self.endDungeonTimeTab = os.date("*t" , (data.end_time - os.time()));
            self.endDungeonTimeTab2 = TimeManager:GetLastTimeData(os.time(), data.end_time) or {};
            self.endDungeonTimeTab2.min = self.endDungeonTimeTab2.min or 0;
            self.endDungeonTimeTab2.sec = self.endDungeonTimeTab2.sec or 0;

            self.endText.text = tostring(string.format("%02d", self.endDungeonTimeTab2.min) .. "f" .. string.format("%02d", self.endDungeonTimeTab2.sec));
        end

        if data.prep_time and not self.start_dungeon_time then
            if data.prep_time < os.time() then
                self.start_dungeon_time = 0;
                self.time.text = tostring(self.start_dungeon_time);
                self:StartDungeon();
            else
                local preptime = data.prep_time;
                local ostime = math.round(os.time());
                self.start_dungeon_time = preptime - ostime - 1;
                self.time.text = tostring(self.start_dungeon_time);
                self.schedules[2] = GlobalSchedule:Start(handler(self, self.StartDungeon), 1, -1);
            end
        end
    end

    self.events[#self.events + 1] = GlobalEvent:AddListener(DungeonEvent.DUNGEON_EXP_GOLD_INFO, callBack1)

    GlobalEvent.AddEventListenerInTab(EventName.NewSceneObject, handler(self, self.HandleNewCreate), self.events);
    AddEventListenerInTab(DungeonEvent.DUNGEON_AUTO_EXIT, handler(self, self.HandleAutoExit), self.events);

end

function GoldDungeonPanel:HandleAutoExit()
    self.dungeon_is_exit = true;
    SetGameObjectActive(self.endTime.gameObject, false);
end

function GoldDungeonPanel:HandleNewCreate(monster)
    if monster and monster.object_type == enum.ACTOR_TYPE.ACTOR_TYPE_CREEP then
        if monster.object_info and monster.object_info["ext"] and monster.object_info["ext"]["disappear"] then
            local time = monster.object_info["ext"]["disappear"];
            --print2(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
            --print2(time);
            SetGameObjectActive(self.boom_exit.gameObject, true);

            local call_back = function()
                SetGameObjectActive(self.boom_exit.gameObject, false);
                SetColor(self.boom_exit, 255, 255, 255, 255);
            end
            if self.boom_exit_schedule then
                GlobalSchedule.StopFun(self.boom_exit_schedule);
            end

            cc.ActionManager:GetInstance():removeAllActionsFromTarget(self.boom_exit)
            local value_action = cc.FadeTo(4, 0.5, self.boom_exit);
            local delay = cc.DelayTime(3);
            local action = cc.Sequence(delay, value_action)
            cc.ActionManager:GetInstance():addAction(action, self.boom_exit)

            self.boom_exit_schedule = GlobalSchedule.StartFunOnce(call_back, 8);

            local call_back1 = function()
                if monster and monster.object_info and monster.object_info.hp <= 0 then
                    call_back();
                    monster.object_info:RemoveListener(self.update_blood);
                end
            end

            self.update_blood = monster.object_info:BindData("hp", call_back1);
        end
    end
end

function GoldDungeonPanel:StopAllSchedules()
    for i = 1, #self.schedules, 1 do
        GlobalSchedule:Stop(self.schedules[i]);
    end
    if self.schedules[3] then
        GlobalSchedule:Stop(self.schedules[3]);
    end
    self.schedules = {};
end