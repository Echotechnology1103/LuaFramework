---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by win 10.
--- DateTime: 2018/10/9 17:33
---
DungeonModel = DungeonModel or class("DungeonModel", BaseModel)
-- local this = DungeonModel

DungeonModel.ExpData = {
    silverCount = 0, --金币鼓舞次数
    goldCount = 0, --元宝鼓舞次数

};

--本服的乱斗战场
DungeonModel.MELEE_SELF_ACTIVITY_ID = 10111;

--本服的乱斗战场
DungeonModel.MELEE_CROSS_ACTIVITY_ID = 10112;

--公会守卫场景ID
DungeonModel.GuildGuardSceneID = 30381;

DungeonModel.GuildGuardRankId = 1015;

DungeonModel.CheckUseGoods = {
    [10810] = 0,
    [11101] = 0,
    --[10806] = 0;
}

DungeonModel.hard_level = {
    [1] = "";
    [2] = "Common",
    [3] = "Hard",
    [4] = "Nightmare",
    [5] = "Hell",
    [6] = "Very Hard",
}

DungeonModel.NumToChinese = {
    [1] = "1",
    [2] = "2",
    [3] = "3",
    [4] = "4",
    [5] = "5",
    [6] = "6",
    [7] = "7",
    [8] = "8",
    [9] = "9",
    [10] = "10",
}

DungeonModel.Timeboss_Floor = {
    [1] = "Sand Realm",
    [2] = "Phantom Realm",
    [3] = "Inferno Ocean",
    [4] = "Frozen Throne",
    [5] = "Behemoth Abyss",
}

DungeonModel.tired = 0;
DungeonModel.enter = 0;--蛮荒进入次数

DungeonModel.Entrance = {};

DungeonModel.DungeEnter = {};

function DungeonModel:GetCurrentEnter()
    return self.DungeEnter[self.curDungeonID];
end

DungeonModel.angryData = {};
--所有装备副本列表
DungeonModel.allEquipDunge = {};
--所有宠物副本列表
DungeonModel.allPetDunge = {};
--进阶副本数据
DungeonModel.advanceData = {};
--是否一键鼓舞金币
DungeonModel.isOneKeyGuwuGold = false;
--是否一键鼓舞钻石
DungeonModel.isOneKeyGuwuDiamond = false;
--异兽岛疲劳
DungeonModel.beast_tired = 0;
--异兽岛大水晶采集次数
DungeonModel.beast_coll = 0;
--异兽岛小水晶采集次数
DungeonModel.beast_coll2 = 0;


-- 最大的记录点
DungeonModel.godsMaxReword = 0
-- 扫荡的次数
DungeonModel.godsSDCount = 0
-- 是否全部通关
DungeonModel.godsIsAll = false
-- 当前波数
DungeonModel.curWave = 1

DungeonModel.CheckReviveHelpPromptList = {} --求助忽略列表

function DungeonModel:ctor()
    DungeonModel.Instance = self
    self:Reset()

    self.BossInfo = {};--key = bossType , value = p_boss_array
    self.spacetime_boss_list_info = {} --时空裂缝boss列表信息
    self.spacetime_boss_list_info.enter = 0
    self:InitAllBoss();

    self:InitBossLocal();

    self:InitEquipDunge();
    self:InitPetDunge();

    self:InitPetBossData();
	-- 默认显示一次红点
	self.isShowRed = CacheManager:GetInstance():GetBool("GodsPanel2225", true)
	
    self.isOneKeyGuwuGold = CacheManager:GetInstance():GetBool("DungeonModel.isOneKeyGuwuGold", false);
    self.isOneKeyGuwuDiamond = CacheManager:GetInstance():GetBool("DungeonModel.isOneKeyGuwuDiamond", false);
end

function DungeonModel:dctor()

end

function DungeonModel.GetInstance()
    if DungeonModel.Instance == nil then
        DungeonModel()
    end
    return DungeonModel.Instance
end

function DungeonModel:Reset()
    -- 默认进入游戏的场景不是副本
    self.cur_scene_is_dungeon = false

    --/*副本信息 key=dungeon_type*/
    self.dungeon_info_list = {}

    --/*转盘信息*/
    self.loto_info = {}

    self.red_dot_list = {}

    self.curDungeonID = nil;

	-- 最大的波数
	self.maxWave = 1

    self.stigmasInfo = {}
    DungeonCtrl:GetInstance().isExpDungeon = nil;
    DungeonCtrl:GetInstance().isGoldDungeon = nil;
    DungeonCtrl:GetInstance().isEquipDungeon = nil;
    DungeonCtrl:GetInstance().isAdvanceDungeon = nil;
    DungeonCtrl:GetInstance().isMeleeDungeon = nil;
    DungeonCtrl:GetInstance().is_dungeon = nil;
    DungeonCtrl:GetInstance().isBossDungeon = nil;
    DungeonCtrl:GetInstance().isExpDungeon = nil;
    DungeonCtrl:GetInstance().isExpDungeon = nil;


    self.exp_merge_count = 0

    self:DestroySosIcon()
end

function DungeonModel.GetDungeonInfo()
    return DungeonModel:GetInstance().dungeonInfo;
end

function DungeonModel:InitAllBoss()
    self.worldBossTab = {};
    self.homeBossTab = {};
    self.savageBossTab = {};
    self.beastBossTab = {};
    self.crossbeastBossTab = {};
    self.spacetimeCrackBossTab = {}  --时空裂缝boss表
    for k, v in pairs(Config.db_boss) do
        if v.type == 1 then
            table.insert(self.worldBossTab, v);
        elseif v.type == 2 then
            table.insert(self.homeBossTab, v);
        elseif v.type == 3 then
            table.insert(self.savageBossTab, v);
        elseif v.type == enum.BOSS_TYPE.BOSS_TYPE_BEAST then
            if v.seq ~= 0 then
                table.insert(self.beastBossTab, v);
            end
        elseif v.type == enum.BOSS_TYPE.BOSS_TYPE_BEAST_CROSS then
            if v.seq ~= 0 then
                table.insert(self.crossbeastBossTab, v);
            end
        elseif self:IsSpacetimeCrackBoss(v.type) then
            if v.seq ~= 0 then
                table.insert(self.spacetimeCrackBossTab, v);
            end
            
        end
    end
end

function DungeonModel:InitBossLocal()
    self.localBossTab = {};
    for k, v in pairs(Config.db_boss_local) do
        if not self.localBossTab[v.map_id] then
            self.localBossTab[v.map_id] = {};
        end
        table.insert(self.localBossTab[v.map_id], v);
    end
end

function DungeonModel:GetDungeonBossInfo(bossType, bossID)

    if bossType == enum.BOSS_TYPE.BOSS_TYPE_SPATIOTEMPORAL2 then
       bossType = enum.BOSS_TYPE.BOSS_TYPE_SPATIOTEMPORAL 
    end

    if self.BossInfo and self.BossInfo[bossType] then
        local tab = self.BossInfo[bossType];
        for i = 1, #tab, 1 do
            if tab[i].id == bossID then
                return tab[i];
            end
        end
    end
    return nil;
end

function DungeonModel:DoDungeonTask(dungeon_stype,param)
    if dungeon_stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER then
        UnpackLinkConfig("150@1@1@1")
    elseif dungeon_stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EXP then
        UnpackLinkConfig("150@1@1@2")
    elseif dungeon_stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_COIN then
        UnpackLinkConfig("150@1@1@3")
    else
        if self:CheckIsDailyOrNoviceDungeon(dungeon_stype) then
            DungeonCtrl:GetInstance():RequestEnterDungeon(nil, nil, dungeon_stype,nil,nil,param)
        else
            DungeonCtrl:GetInstance():RequestEnterDungeon(dungeon_stype,nil,nil,nil,nil,param)
        end

    end
end

function DungeonModel:InitEquipDunge()
    self.allEquipDunge = {};
    for k, v in pairs(Config.db_dunge) do
        if v.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EQUIP then
            table.insert(self.allEquipDunge, v);
        end
    end
    table.sort(self.allEquipDunge, function(cp1, cp2)
        return cp1.level < cp2.level;
    end);
end

function DungeonModel:InitPetDunge()
    self.allPetDunge = {};
    for k, v in pairs(Config.db_dunge) do
        if v.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_PET then
            table.insert(self.allPetDunge, v);
        end
    end
    table.sort(self.allPetDunge, function(cp1, cp2)
        return cp1.level < cp2.level;
    end);
end

--判断是否是新手或者日常副本
function DungeonModel:CheckIsDailyOrNoviceDungeon(dungeon_stype)
    local cfg = Config.db_dunge[dungeon_stype]
    if not cfg then
        return false
    end
    if cfg.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_DAILY or cfg.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_NEWBIE
      or cfg.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_NEWBIE_SUMMON or cfg.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_NEWBIE_ANGER then
        return true
    end

    return false

end

function DungeonModel:GetBossIDByTypeLevel(boss_type, level)
    local boss_list = self:GetBossListByType(boss_type)
    if table.isempty(boss_list) then
        return
    end
    local min_level
    local target_boss_id
    for k, v in pairs(boss_list) do
        local id = v.id
        local cf = Config.db_creep[id]
        if (not min_level or cf.level < min_level) and (not level or cf.level >= level) then
            min_level = cf.level
            target_boss_id = id
        end
    end
    return target_boss_id
end

function DungeonModel:GetBossListByType(boss_type)
    local list = {}
    for k, v in pairs(Config.db_boss) do
        if v.type == boss_type then
            list[#list + 1] = v
        end
    end
    return list
end

------宠物BOSS相关
function DungeonModel:ChangeBoss(oldId, newId, bossType)
    local bType = bossType or enum.BOSS_TYPE.BOSS_TYPE_PET
    local tab = DungeonModel:GetInstance().BossInfo[bType]
    for _, v in ipairs(tab) do
        if v.id == oldId then
            v.id = newId
        end
    end
end

function DungeonModel:SetPetBossInfo(petBossData)
    self.PetBossInfo = self.PetBossInfo or {}
    self.PetBossInfo.enter = petBossData.enter
    self.PetBossInfo.maxTimes = petBossData.max_times
    self.PetBossInfo.tired = petBossData.tired
    self.PetBossInfo.num = petBossData.num
end

function DungeonModel:PrintPetBoss()
    local petBossList = self.BossInfo[enum.BOSS_TYPE.BOSS_TYPE_PET]
    for i, v in ipairs(petBossList) do
        local config = Config.db_boss[v.id]
        logError(string.format("<color=#00ff00>id=%s-->floor=%s-->qual=%s->wake=%s-->born=%s-->name=%s</color>",
                v.id, config.floor, config.qual, v.weak or "N", v.born, config.name))
    end
end

function DungeonModel:GetPetBossList(floor, group)

    local bossList = {}
    local tempTab = nil
    local petBossList = self.BossInfo[enum.BOSS_TYPE.BOSS_TYPE_PET]

    for i, v in ipairs(petBossList) do
        local config = Config.db_boss[v.id]
        if (config and config.floor == floor) then

            tempTab = {}
            tempTab.id = v.id
            tempTab.born = v.born
            tempTab.care = v.care
            tempTab.weak = v.weak
            tempTab.config = config

            if (group) then
                if group == config.group then
                    table.insert(bossList, tempTab)
                end
            else
                table.insert(bossList, tempTab)
            end
        end
    end

    table.sort(bossList, function(a, b)
        --if (a.config.qual == b.config.qual) then
        return a.config.seq < b.config.seq
        --else
        --    return a.config.qual < b.config.qual
        --end
    end)

    return bossList
end

function DungeonModel:InitPetBossData()
    self.PetBossFloorList = {}
    ---数据格式 [floor]-[quality]-[sequence]
    self.PetBossSortedList = {}
    ---场景与层的关系
    self.PetBossSceneAndFloor = {}
    local tempList

    for _, v in pairs(Config.db_boss) do

        if (v.type == enum.BOSS_TYPE.BOSS_TYPE_PET) then

            self.PetBossSceneAndFloor[v.scene] = v.floor

            if not self.PetBossFloorList[v.floor] then
                self.PetBossFloorList[v.floor] = true
            end

            if not self.PetBossSortedList[v.floor] then
                self.PetBossSortedList[v.floor] = {}
            end

            tempList = self.PetBossSortedList[v.floor]

            if not tempList[v.qual] then
                tempList[v.qual] = {}
            end
            tempList[v.qual][v.seq] = v

        end
    end
end

function DungeonModel:GetFloorBySceneId(sceneId)
    if (self.PetBossSceneAndFloor and self.PetBossSceneAndFloor[sceneId]) then
        return self.PetBossSceneAndFloor[sceneId]
    end

    return 1
end

function DungeonModel:GetPetBossByFloor(floor, quality)
    if self.PetBossSortedList[floor] then
        return self.PetBossSortedList[floor][quality]
    end
    return nil
end

function DungeonModel:SetSelectedPetId(id)
    self.PetSelectId = id
end

---@param1 如为true则取出后移除，用以进入后立即寻路，后不再自动寻路
function DungeonModel:GetSelectedPetId(isPop)
    if (self.PetSelectId) then
        local tempId = self.PetSelectId
        if (isPop) then
            self.PetSelectId = nil
        end
        return tempId
    else
        return 0
    end
end

---进入宠物首领的剩余次数
function DungeonModel:GetRemainTimes()
    local l = RoleInfoModel:GetInstance():GetMainRoleVipLevel()
    local vipKey = "vip" .. l
    if not self.PetBossInfo then
        return 0, nil, nil
    end
    --local num = tonumber(Config.db_vip_rights[32][vipKey])
    local num = self.PetBossInfo.maxTimes
    local remain = num - self.PetBossInfo.enter

    l = l + 1
    vipKey = "vip" .. l
    local next = Config.db_vip_rights[32][vipKey]
    if (next) then
        return remain, l, tonumber(next)
    else
        return remain, nil, nil
    end
end

---所有宠物副本层
function DungeonModel:GetPetBossFloorList()
    return self.PetBossFloorList
end

function DungeonModel:GetExpDunTimes()
    local data = self.dungeon_info_list[enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EXP];
    if data and data.info.rest_times > 0 then
        return data.info.rest_times;
    end
    return nil;
end

---魔法塔当前层级
function DungeonModel:GetTowerFloor()
    local towerInfo = self.dungeon_info_list[enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER]
    if towerInfo and towerInfo.info and towerInfo.info.cur_floor then
        return towerInfo.info.cur_floor
    else
        return 1
    end
end

function DungeonModel:UpdateReddot()
    if self.Rschedule then
        GlobalSchedule.StopFun(self.Rschedule);
    end
    self.Rschedule = GlobalSchedule.StartFunOnce(handler(self, self.RUpdateReddot), 0.2);
end

function DungeonModel:RUpdateReddot()
    --入口部份
    local tab = { enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EQUIP, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_PET, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MOUNT, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EXP,
                  enum.SCENE_STYPE.SCENE_STYPE_DUNGE_COIN, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_ROLE_BOSS, enum.SCENE_STYPE.SCENE_STYPE_BOSS_PET,
                   enum.SCENE_STYPE.SCENE_STYPE_DUNGE_SOUL, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_GOD, enum.SCENE_STYPE.SCENE_STYPE_TIMEBOSS}
    for k, stype in pairs(tab) do
        self.red_dot_list[stype] = false;
        local data = self.dungeon_info_list[stype];
        --装备本宠物本有次数就显示红点
        if stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EQUIP or
                stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_PET or
                stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EXP or
                stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_COIN then
            if data and data.info.rest_times > 0 then
                self.red_dot_list[stype] = true;
            end
			--神灵之路
        elseif stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_GOD then
            local isred = false

            if data and data.info.sweep_times == 0  then
				if self.maxWave == data.info.max_wave then
					self.isShowRed = false
                    CacheManager:GetInstance():SetBool("GodsPanel2225", false)
					self.red_dot_list[stype] = true;
					isred = true
				end
				if self.godsMaxReword > self.curWave  then
					self.red_dot_list[stype] = true;
					isred = true
				end
            end
            if self.isShowRed then
                self.red_dot_list[stype] = true;
                isred = true
            end

            if data and not isred then
                local level = data.level or {}
                local num  = data.info.max_wave
                for i = 1, num do
                    if not level[i] then
                        self.red_dot_list[stype] = true;
                        break
                    end
                end
            end
            GlobalEvent:Brocast(MainEvent.ChangeSystemShowInStronger, 60, isred)
            --进阶副本也不一样
        elseif stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MOUNT then
            data = self.advanceData;
            if data then
                local enter = data.enter;
                local star = data.star;
                local fetch = data.fetch;

                if enter then

                end
                local allStar = 0;
                if star then
                    for k, v in pairs(AdvanceEntrancePanel.DungeID) do
                        local starNum = star[v];
                        if starNum == 0 then
                            self.red_dot_list[stype] = true;
                        end
                    end
                else
                    self.red_dot_list[stype] = true;
                end
            end
            --魔法塔呢就比较奇葩
        elseif stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER then
            self:CheckTowerReddot();
            --个人boss那边也比较特别
        elseif stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_ROLE_BOSS then
            if data then
                local viplv = RoleInfoModel:GetInstance():GetRoleValue("viplv")
                local vip_count = tonumber(Config.db_vip_rights[enum.VIP_RIGHTS.VIP_RIGHTS_ROLE_BOSS]["vip" .. viplv] or 0)
                local left_count = Config.db_dunge[30351].enter_times - data.info.cur_times + vip_count;--镇炎说的30351次数是多少就是多少
                local costNum = 2;
                local costItemid = 10806;
                local sceneConfig = Config.db_scene[Config.db_dunge[30351].scene];
                if sceneConfig then
                    local cost = LString2Table(sceneConfig.cost);
                    cost = cost and cost[1] or {};
                    costItemid = cost[1];
                    costNum = cost[2];
                end
                local num = BagModel:GetInstance():GetItemNumByItemID(costItemid);
                if viplv >= 4 and tonumber(left_count) > 0 and num >= costNum then
                    self.red_dot_list[stype] = true;
                end
            end
        elseif stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_PET then
            -- 宠物Boss
            if self:GetRemainTimes() > 0 then
                --剩余次数大于0
                self.red_dot_list[stype] = true
            end
        elseif stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_SOUL then
            if  StigmasModel:GetInstance().rTimes > 0 then
                self.red_dot_list[stype] = true
            end
        elseif stype == enum.SCENE_STYPE.SCENE_STYPE_TIMEBOSS then
            self.red_dot_list[stype] = TimeBossModel.GetInstance():IsHaveRedDot()
        end

    end
    --首领部份
    local tab = {
        [enum.BOSS_TYPE.BOSS_TYPE_WORLD] = enum.SCENE_STYPE.SCENE_STYPE_BOSS_WORLD,
    }
    for bosstype, stype in pairs(tab) do
        self.red_dot_list[stype] = false;
        --local data = self.BossInfo[bosstype];
        --if data then
        if Config.db_game["boss_tired"] then
            local val = String2Table(Config.db_game["boss_tired"].val);
            local tired = tonumber(val[1]);
            if not self:IsSemptytired(enum.SCENE_STYPE.SCENE_STYPE_BOSS_WORLD) then
                self.red_dot_list[stype] = true;
            end
        end
        --end
    end
    self:CheckMainReddot();

    --幻之岛部份
    local tab = {
        [enum.BOSS_TYPE.BOSS_TYPE_BEAST] = enum.BOSS_TYPE.BOSS_TYPE_BEAST,
        [enum.BOSS_TYPE.BOSS_TYPE_BEAST_CROSS] = enum.BOSS_TYPE.BOSS_TYPE_BEAST_CROSS,
    }
    for bosstype, stype in pairs(tab) do
        self.red_dot_list[stype] = false;
        if Config.db_game["beast_tired"] then
            local val = String2Table(Config.db_game["beast_tired"].val);
            local tired = tonumber(val[1]);
            if not self:IsSemptytired(enum.SCENE_STYPE.SCENE_STYPE_BOSS_BEAST) then
                self.red_dot_list[stype] = true;
            end
            --if self.beast_tired < tired then
            --    self.red_dot_list[stype] = true;
            --end
        end
    end

    self:CheckBeastReddot();

    BrocastModelEvent(DungeonEvent.UpdateReddot);
end

function DungeonModel:CheckBeastReddot()
    local show1 = toBool(self.red_dot_list[enum.BOSS_TYPE.BOSS_TYPE_BEAST_CROSS])

    local lv = RoleInfoModel.GetInstance():GetMainRoleLevel() or 0
    local nedlv = GetSysOpenDataById("160@15")
    if lv < nedlv then
        show1 = false
    end

    local show_red = show1 or toBool(self.red_dot_list[enum.SCENE_STYPE.SCENE_STYPE_TIMEBOSS]) or self:CheckpaceTimeCrackReddot()

    GlobalEvent:Brocast(MainEvent.ChangeRedDot, "cross", show_red);
end

function DungeonModel:CheckMainReddot()
    local bool = false;
    local tab = { enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EQUIP, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_PET, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MOUNT, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EXP,
                  enum.SCENE_STYPE.SCENE_STYPE_DUNGE_COIN, enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER }
    for k, v in pairs(tab) do
        if self.red_dot_list[v] then
            bool = true;
        end
    end
    GlobalEvent:Brocast(MainEvent.ChangeRedDot, "dungeon", bool)

    bool = false;
    tab = { enum.SCENE_STYPE.SCENE_STYPE_DUNGE_ROLE_BOSS, enum.SCENE_STYPE.SCENE_STYPE_BOSS_WORLD, enum.BOSS_TYPE.BOSS_TYPE_BEAST };
    for k, v in pairs(tab) do
        if self.red_dot_list[v] then
            bool = true;
        end
    end
    GlobalEvent:Brocast(MainEvent.ChangeRedDot, "worldBoss", bool);

    if self.red_dot_list[enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER] then
        GlobalEvent:Brocast(MainEvent.ChangeSystemShowInStronger, 44, true)
    else
        GlobalEvent:Brocast(MainEvent.ChangeSystemShowInStronger, 44, false)
    end

    --if self.red_dot_list[enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EQUIP] then
    --    GlobalEvent:Brocast(MainEvent.ChangeSystemShowInStronger, 44, true)
    --else
    --    GlobalEvent:Brocast(MainEvent.ChangeSystemShowInStronger, 44, false)
    --end
    --GlobalEvent:Brocast(MainEvent.ChangeRightIcon, "dungeon", bool);
end

function DungeonModel:CheckTowerReddot()
    local data = self.dungeon_info_list[enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER];
    self.red_dot_list[enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER] = false;
    if data then
        if data.info.daily_gift ~= 1 and data.info.cur_floor > 1 then
            self.red_dot_list[data.stype] = true;
        end
        if data.info then
            if data.info.loto_times > 0 then
                self.red_dot_list[data.stype] = true;
            end
        end
    end
end

function DungeonModel:GetDungeonInfoByStype(stype)
    return self.dungeon_info_list[stype]
end

function DungeonModel:IsBeastIsland(item)
    local data = item.data;
    if data and self:IsBeastBoss(data.type) then
        return true;
    end
    return false;
end

function DungeonModel:IsBeastBoss(bossType)
    return bossType == enum.BOSS_TYPE.BOSS_TYPE_BEAST or bossType == enum.BOSS_TYPE.BOSS_TYPE_BEAST_CROSS;
end

function DungeonModel:IsBeastScene()
    local config = Config.db_scene[SceneManager:GetInstance():GetSceneId()]
    if config and config.type == enum.SCENE_TYPE.SCENE_TYPE_BOSS and config.kind == enum.SCENE_KIND.SCENE_KIND_LOCAL then
        return true;
    end
    return false;
end

function DungeonModel:IsCrossBeastScene()
    local config = Config.db_scene[SceneManager:GetInstance():GetSceneId()]
    if config and config.type == enum.SCENE_TYPE.SCENE_TYPE_BOSS and config.kind == enum.SCENE_KIND.SCENE_KIND_CROSS then
        return true;
    end
    return false;
end

function DungeonModel:GetBossesByType(sceneType)
    local config = Config.db_scene[SceneManager:GetInstance():GetSceneId()]

    if config then
        if config.stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_WORLD then
            return self.worldBossTab;
        elseif config.stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_WORLD then
            return self.homeBossTab;
        elseif config.stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_WORLD then
            return self.savageBossTab;
        elseif config.stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_BEAST then
            if self:IsCrossBeastScene() then
                return self.crossbeastBossTab;
            else
                return self.beastBossTab;
            end
        end
    end
    return Config.db_boss;
end

function DungeonModel:ExitScene(callback)
    local sceneid = SceneManager:GetInstance():GetSceneId()
    local config = Config.db_scene[sceneid] or {}
    -- 当前是主城或者野外，随便切地图
    if config.type == enum.SCENE_TYPE.SCENE_TYPE_CITY or config.type == enum.SCENE_TYPE.SCENE_TYPE_FIELD then
        -- callback 外面自己执行 千万不要这里执行
        -- if callback then
        --     callback()
        -- end
        return true
    end

    local str
    if config.type == enum.SCENE_TYPE.SCENE_TYPE_DUNGE and config.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EXP then
        str = "Are you sure you want to leave?\n(Leave now will still cost your attempts)"
    elseif config.type == enum.SCENE_TYPE.SCENE_TYPE_DUNGE and config.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_COIN then
        str = "Are you sure you want to leave?\n(Leave now will still cost your attempts)"
    elseif config.type == enum.SCENE_TYPE.SCENE_TYPE_DUNGE and config.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_EQUIP then
        str = "You haven't claimed all dungeon rewards yet,\nleave?"
    elseif config.type == enum.SCENE_TYPE.SCENE_TYPE_ACT and config.stype == enum.SCENE_STYPE.SCENE_STYPE_MELEEWAR then
        str = "If you leave brawl battleground now,all points you earned will be cleared.\nExit?"
    elseif config.type == enum.SCENE_TYPE.SCENE_TYPE_DUNGE and config.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_MAGICTOWER then
        str = "Leave current scene and go?"
    else
        local sceneConfig = Config.db_scene[sceneid];
        if sceneConfig then
            str = "Are you sure to leave current scene?"
        end
    end
    if str then
        if not callback then
            callback = function()
                SceneControler:GetInstance():RequestSceneLeave()
            end
        end
        Dialog.ShowTwo("Tip", str, "Confirm", callback, nil, "Cancel", nil, nil)
        local lv = RoleInfoModel:GetInstance():GetMainRoleLevel()
        if lv and lv > 0 then
            DebugLog("=====Dungeon ExitScene=====", debug.traceback())
        end
        return false
    end

    -- callback 外面自己执行 千万不要这里执行
    -- if callback then
    --     callback()
    -- end
    return true
end
--983是世界boss疲劳,982是幻之岛疲劳
function DungeonModel:IsSemptytired(stype,sceneId)
    local mainroledata = RoleInfoModel:GetInstance():GetMainRoleData();
    if stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_WORLD then
        if mainroledata then
            return mainroledata:IsBossTired(983)
        end
        return self.tired >= 3;
    elseif stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_BEAST then
        if mainroledata then
            return mainroledata:IsBossTired(982)
        end
        return self.beast_tired >= 3;
    elseif stype == enum.SCENE_STYPE.SCENE_STYPE_BOSS_HOME then
		if sceneId ~= 20100 and sceneId ~= 20102 and sceneId ~= 20101 then
			return false
		end
        local main_role_data = RoleInfoModel:GetInstance():GetMainRoleData()
        local buffer = main_role_data:GetBuffByID(enum.BUFF_ID.BUFF_ID_HOME_BOSS_VIGOR)
        local used_energe = (buffer and buffer.value or 0)
        return used_energe >= 100
    end
    return false
end

function DungeonModel:IsDungeonScene(scene_id)
    scene_id = scene_id or SceneManager:GetInstance():GetSceneId()
    local config = Config.db_scene[scene_id]
    if not config then
        return false
    end
    return config.type == enum.SCENE_TYPE.SCENE_TYPE_DUNGE or
            config.type == enum.SCENE_TYPE.SCENE_TYPE_BOSS or
            config.type == enum.SCENE_TYPE.SCENE_TYPE_ACT
end

function DungeonModel:SetTargetPos(targetX, targetY)
    self.targetPos = {x=targetX, y=targetY}
end

--是否是新手副本
function DungeonModel:IsNoviceDungeon(sceneId)
    sceneId = sceneId or SceneManager:GetInstance():GetSceneId()
    local config = Config.db_scene[sceneId]
    if not config then
        --   print2("不存在场景配置" .. tostring(sceneId));
        return false
    end
    if config.type == enum.SCENE_TYPE.SCENE_TYPE_DUNGE and config.stype == enum.SCENE_STYPE.SCENE_STYPE_DUNGE_NEWBIE then
        return true
    end

    return false
end

function DungeonModel:SetSoSInfo(data)
    --self.sosRoleId = data.role_id
    if DungeonModel.CheckReviveHelpPromptList[data.role.id]  then
        return
    end
    self.sosData = data

    if RoleInfoModel:GetInstance():GetMainRoleId() ~= data.role.id then
        self:StartShowSosIcon(600)
    end


end

function DungeonModel:StartShowSosIcon(time)
    if self.SosSchedule then
        GlobalSchedule:Stop(self.SosSchedule)
        self.SosSchedule = nil
    end
    if DungeonModel.CheckReviveHelpPromptList[self.sosData.role.id]  then
        return
    end
    GlobalEvent:Brocast(DungeonEvent.ShowSosIcon,true)
    local time = time
    local function call_back()
        time = time - 1
        if time <= 0 then
            if self.SosSchedule then
                GlobalSchedule:Stop(self.SosSchedule)
                self.SosSchedule = nil
            end
            GlobalEvent:Brocast(DungeonEvent.ShowSosIcon,false)
        end

    end
    self.SosSchedule = GlobalSchedule.StartFun(call_back, 1, -1)
end

function DungeonModel:DestroySosIcon()
    if self.SosSchedule then
        GlobalSchedule:Stop(self.SosSchedule)
        self.SosSchedule = nil
    end
    GlobalEvent:Brocast(DungeonEvent.ShowSosIcon,false)
end

--获取可用于寻路的时空裂缝boss坐标
--宝箱 守卫 隐藏boss 返回nil
--普通boss返回第一个坐标
function DungeonModel:GetSpacetimeCrackBossCoord(tab)
    if tab.seq <= 3 then
        return nil
    end

    local coord = String2Table(tab.coord)
    coord = {coord[1][1],coord[1][2]}
    return coord
end

--是否是时空裂缝boss
function DungeonModel:IsSpacetimeCrackBoss(type)
    local flag = type == enum.BOSS_TYPE.BOSS_TYPE_SPATIOTEMPORAL or type == enum.BOSS_TYPE.BOSS_TYPE_SPATIOTEMPORAL2
    return flag
end

--设置时空裂缝boss列表信息
function DungeonModel:SetSpaceTimeCrackBossInfo( data )
    self.spacetime_boss_list_info = data
end

--检查是否有时空裂缝进入次数
function DungeonModel:CheckSpaceTimeCrackEnterNum(  )
    local vipLevel = RoleInfoModel:GetInstance():GetMainRoleVipLevel();
    local vipRightTab = Config.db_vip_rights[enum.VIP_RIGHTS.VIP_RIGHTS_SPATIOTEMPORAL_BOSS];
    local base = tonumber(vipRightTab.base);
    local added = tonumber(vipRightTab["vip" .. vipLevel]);
    local maxtime = base + added;
    local enterTimes = self.spacetime_boss_list_info.enter
    if (maxtime - enterTimes) <= 0 then
        return false
    end

    return true
end

--检查是否有时空裂缝boss疲劳
function DungeonModel:CheckSpaceTimeCrackTired(  )
    local curTired = 0
    local main_role_data = RoleInfoModel:GetInstance():GetMainRoleData()
    if main_role_data then
        local buffer = main_role_data:GetBuffByID(enum.BUFF_ID.BUFF_ID_FISSURE_BOSS_TIRED)
        local value = (buffer and buffer.value or 0)
        local tired = 2;
        local vip_lv = RoleInfoModel:GetInstance():GetMainRoleVipLevel();
        local vipRightTab = Config.db_vip_rights[enum.VIP_RIGHTS.VIP_RIGHTS_FISSURE_TIRED];
        local base = tonumber(vipRightTab.base);
        local added = tonumber(vipRightTab["vip" .. vip_lv]);
        tired = base + added;

        curTired = SafetoNumber(tired) - SafetoNumber(value)
    end

    return curTired > 0
end

--检查时空裂缝红点
function DungeonModel:CheckpaceTimeCrackReddot(  )
    local level = RoleInfoModel:GetInstance():GetMainRoleLevel() or 1
    return DungeonModel.GetInstance():CheckSpaceTimeCrackTired() 
    and DungeonModel.GetInstance():CheckSpaceTimeCrackEnterNum()
    and tonumber(GetSysOpenDataById("160@17")) <= level
end

--获取时空裂缝隐藏boss总数
function DungeonModel:GetSpaceTimeCrackConcealmentBossNum(  )
    local sum = 0
    if not self.spacetime_boss_list_info.bosses then
        return  sum
    end

    local floor = 0
    local panel = lua_panelMgr:GetPanel(CrossPanel)
    if panel and panel.currentView._class_type.__cname == SpacetimeCrackDungePanel.__cname then
        floor = panel.currentView.currentFloor
    else
        local cur_scene_id = SceneManager.GetInstance():GetSceneId()
        floor = self:GetSpaceTimeCrackConcealmentFloor(cur_scene_id)
    end
    --logError("floor-"..floor)
    for k,v in pairs(self.spacetime_boss_list_info.bosses) do
        local boss_cfg = Config.db_boss[v.id]
        if boss_cfg.type == enum.BOSS_TYPE.BOSS_TYPE_SPATIOTEMPORAL2 and boss_cfg.floor == floor then
           --logError("隐藏boss id-"..v.id..",num-"..v.num)
            sum  = sum + v.num
        end
    end
    --logError("隐藏boss总数量为-".. sum)
    return sum
end

--根据场景id获取时空裂缝层数
function DungeonModel:GetSpaceTimeCrackConcealmentFloor( scene_id )
    local floor = 0
    for k,v in pairs(self.spacetimeCrackBossTab) do
        if v.scene == scene_id then
            floor = v.floor
            break
        end
    end
    return floor
end