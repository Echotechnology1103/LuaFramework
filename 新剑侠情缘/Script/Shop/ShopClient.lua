Shop.tabUiKeyName = {
    tabActShop = "限时限购";
    tabActShopDress = "黎饰限购";
    tabLimitShop = "每周限购";
    tabAllShop = "全部";
    tabDressWaiyiShop = "衣服外观";
    tabDressHeadShop = "头饰外观";
    tabDressWeaponShop = "武器外观";
    tabDressHorseShop = "坐骑外观";
    tabDressOtherShop = "其他";
    tabDressRareShop = "珍稀物品";
};

Shop.tbActShopPartName = {
    { "2017.11.3 0:0:0", "2017.12.2 23:59:59",  "天剑令打折" }; --天剑令打折活动
    { "2017.12.12 00:00:01", "2017.12.12 23:59:59","枫华绝代限时折扣" };
    { "2017.12.13 00:00:01", "2017.12.18 23:59:59","枫华绝代限时特卖" };
    { "2017.12.24 00:00:01", "2017.12.30 23:59:59","圣诞外观限时特卖" };
    { "2018.1.18 4:00:01", "2018.1.23 23:59:59","丝路流纱外观限时特卖" };
    { "2018.2.10 4:00:01", "2018.2.28 23:59:59","金玉满堂外观限时折扣" };
    { "2018.2.12 4:00:01", "2018.2.28 23:59:59","家园小萌犬限时特卖" };
    { "2018.2.28 0:00:01", "2018.3.04 23:59:59","丝路流纱外装限时返场" };
    { "2018.2.28 0:00:02", "2018.3.04 23:59:59","邪魅狷狂外装限时返场" };
    { "2018.2.28 0:00:03", "2018.3.04 23:59:59","浮光若梦外装限时返场" };
    { "2018.3.2 0:00:01", "2018.3.04 23:59:59","元宵礼盒限时特卖" };
    { "2018.4.13 0:04:00", "2018.4.20 23:59:59","苍澜花间外观限时特卖" };
    { "2019.9.5 4:00:00", "2019.9.11 3:59:59","师徒礼盒" };
    { "2019.1.14 4:00:03", "2019.1.31 23:59:59","缀芳沐雪限时特卖" };
    { "2019.1.28 4:00:00", "2019.2.7 23:59:59","新年限时特惠" };
    { "2019.3.8 4:00:00", "2019.3.11 3:59:59","女侠节限定" };
    { "2019.5.31 4:00:00", "2019.6.8 3:59:59","周年寄语特售" };
    { "2019.3.18 4:00:02", "2019.3.24 23:59:59","春风特惠背挂、武器外装" };
    { "2019.3.18 4:00:03", "2019.3.24 23:59:59","春风特惠外装宝箱" };
    { "2019.3.18 4:00:01", "2019.3.24 23:59:59","春风特惠外装" };
    { "2019.4.18 4:00:01", "2019.4.25 3:59:59","翩燕流云外观限时特卖" };
    { "2019.4.18 4:00:00", "2019.4.25 3:59:59","水龙吟限时特惠" };
    { "2019.5.23 4:00:00", "2019.5.26 23:59:59","三周年黎饰特惠" };
    { "2019.5.27 4:00:00", "2019.5.31 23:59:59","三周年头饰特惠" };
    { "2019.5.27 4:00:01", "2019.5.31 23:59:59","三周年背挂特惠" };
    { "2019.6.1 4:00:00", "2019.6.5 23:59:59","三周年商城特惠" };
    { "2019.7.4 4:00:03", "2019.7.10 23:59:59","盛夏特惠外装宝箱" };
    { "2019.7.4 4:00:02", "2019.7.10 23:59:59","盛夏特惠背挂、武器外装" };
    { "2019.7.4 4:00:01", "2019.7.10 23:59:59","盛夏特惠外装" };
    { "2019.7.4 4:00:00", "2019.7.10 23:59:59","盛夏特惠头饰" };
    { "2019.11.21 4:00:00", "2019.12.3 3:59:59","银杏寄情" };
    { "2019.8.15 4:00:00", "2019.8.18 23:59:59","墨问江湖限时特惠" };
    { "2019.8.15 4:00:00", "2019.8.21 23:59:59","风华绝代外观限时特卖" };
    { "2019.12.9 4:00:00", "2019.12.16 3:59:59","武勋令牌" };
    { "2019.12.16 4:00:00", "2019.12.23 3:59:59","武勋令牌" };
    { "2019.12.23 4:00:00", "2019.12.30 3:59:59","武勋令牌" };
    { "2019.12.30 4:00:00", "2020.1.6 3:59:59","武勋令牌" };
    { "2020.1.6 4:00:00", "2020.1.13 3:59:59","武勋令牌" };
    { "2020.1.13 4:00:00", "2020.1.20 3:59:59","武勋令牌" };
    { "2020.1.20 4:00:00", "2020.1.27 3:59:59","武勋令牌" };
    { "2020.1.27 4:00:00", "2020.2.3 3:59:59","武勋令牌" };
    { "2019.10.1 4:00:00", "2019.10.7 23:59:59","金秋黎饰特惠" };
    { "2019.10.30 4:00:04", "2019.11.6 23:59:59","万圣节特惠头饰" };
    { "2019.10.30 4:00:03", "2019.11.6 23:59:59","万圣节特惠背挂" };
    { "2019.10.30 4:00:02", "2019.11.6 23:59:59","万圣节特惠武器外观" };
    { "2019.10.30 4:00:01", "2019.11.6 23:59:59","万圣节特惠外装宝箱" };
    { "2019.10.30 4:00:00", "2019.11.6 23:59:59","万圣节特惠外装" };
    { "2019.12.19 4:00:00", "2019.12.25 23:59:59","名扬四海商城特惠" };
    { "2019.12.19 12:00:00", "2019.12.26 03:59:59","故梦星辰外观限时特卖" };
    { "2019.12.19 4:00:00", "2019.12.26 03:59:59","绒雪外观限时特卖" };
}

function Shop:GetActShopPartName(nTime1, nTime2)
    if not self.tbActShopPartTimeName then
        self.tbActShopPartTimeName = {};
        for i,v in ipairs(Shop.tbActShopPartName) do
            local nTimr1 = Lib:ParseDateTime(v[1])
            local nTimr2 = Lib:ParseDateTime(v[2])
            self.tbActShopPartTimeName[nTimr1] = self.tbActShopPartTimeName[nTimr1] or {};
            self.tbActShopPartTimeName[nTimr1][nTimr2] = v[3];
        end
    end
    if self.tbActShopPartTimeName[nTime1] then
        return self.tbActShopPartTimeName[nTime1][nTime2]
    end
end

function Shop:CheckRedPoint()
    local bShowRed = false
    local nSeeShopActStartTime = Client:GetFlag("SeeShopActStartTime") or 0;
    local nSeeWeek = Lib:GetLocalWeek(nSeeShopActStartTime - self.TREASURE_REFRESH)
    if nSeeWeek < Lib:GetLocalWeek(GetTime() - self.TREASURE_REFRESH) then
        bShowRed = true
        self.nLimitSynced = nil;
    end
    if not bShowRed then
        if Shop.nNewsShopActStartTime and nSeeShopActStartTime < Shop.nNewsShopActStartTime then
            bShowRed = true
        end
    end

    if bShowRed then
        Ui:SetRedPointNotify("CommonShopTab")
    else
        Ui:ClearRedPointNotify("CommonShopTab")
    end
end

function Shop:GetShopWares(szShopType, szTabKey, bNotCopy)
    if Shop.tbFamilyShopCharToId[szShopType] then
        return self:GetFamilyShopWares(szShopType)
    end
    local tbRet = {};
    local tbShopWares = self.ShopWares[szShopType];
    if szShopType == "Treasure" then --珍宝阁限量与普通商品分开显示
        if szTabKey == "tabAllShop" then --非限购
            for k, v in pairs(tbShopWares) do
                if not v.nLimitType then
                    table.insert(tbRet, v);
                end
            end
        elseif szTabKey == "tabLimitShop" then --周限购的
            for k, v in pairs(tbShopWares) do
                if v.nLimitType == self.WEEK_LIMIT_TYPE then
                    table.insert(tbRet, v);
                end
            end
        elseif not szTabKey then
            tbRet = tbShopWares or {}
        else
            for k, v in pairs(tbShopWares) do
                if v.SubType == szTabKey then
                    table.insert(tbRet, v);
                end
            end
        end
    elseif szShopType == "Dress" then
        if not szTabKey then
            tbRet = tbShopWares or {}
        else
            for k, v in pairs(tbShopWares) do
                if v.SubType == szTabKey then
                    -- 检查玩家身上打折券信息;
                    local tbDiscountMsg = Shop:CheckDressDiscount(me,v);
                    if tbDiscountMsg then
                        local TmpV = Lib:CopyTB(v);
                        TmpV.nOriginPrice = v.nPrice;
                        TmpV.nPrice = tbDiscountMsg.nPrice;
                        TmpV.nDiscount = tbDiscountMsg.nDiscount;
                        table.insert(tbRet,TmpV);
                    else
                        table.insert(tbRet, v);
                    end
                end
            end
        end
    else
        tbRet = tbShopWares or {}
    end

    local tbAfterFilter = {};
    for k,v in pairs(tbRet) do
        if self:CheckWareAvaliable(v, me) then
            table.insert(tbAfterFilter, v);
        end
    end

    if #tbAfterFilter == 0 and self.tbActShopTypes and szTabKey == "tabActShop" then
        self.tbActShopTypes[szShopType] = nil;
        UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE)
    end

    if not bNotCopy then
        return Lib:CopyTB(tbAfterFilter);
    else
        return tbAfterFilter;
    end
end


function Shop:GetFamilyShopWares(szShopType)
    local nBuildingId = self.tbFamilyShopCharToId[szShopType]
    if not nBuildingId then
        return
    end
    -- 现在战争坊是根据领土战那边需求只是用家族商店的ui
    --不用家族随机限购的，就直接本地根据家族等级读取
    if not self.FamilyPool[szShopType] then
        local nMyLevel = self:GetBuildingLevel(me, nBuildingId);
        if not self.tbLocalUpdateWareBuidLevel[nBuildingId] or nMyLevel > self.tbLocalUpdateWareBuidLevel[nBuildingId] then
            local tbShopData = {}
            self.tbFamilyShopData[szShopType] = tbShopData
            local tbWares = self.ShopWares[szShopType];
            for nLevel, v in pairs(tbWares) do
                if nMyLevel >= nLevel then
                    for TemplateId, _ in pairs(v) do
                        table.insert(tbShopData, {nTemplateId = TemplateId})
                    end
                end
            end
            self.tbLocalUpdateWareBuidLevel[nBuildingId] = nMyLevel
        end
    end

    local tbWares = self.tbFamilyShopData[szShopType];
    if not tbWares then
        return
    end

    local tbRet = {};

     for i, v in ipairs(tbWares) do
        local tbCur = self:GetAWare(szShopType, v.nTemplateId)
        if tbCur then --如果更新版本前随机到的道具在版本后不存在了就可能会空
            local tbWare = Lib:CopyTB1(tbCur);
            tbWare.nRemainCount = v.nCount;
            tbWare.nPrice, tbWare.nDiscount = self:GetPrice(me, tbWare);
            table.insert(tbRet, tbWare);
        end
    end

    return tbRet;
end

function Shop:GetFaimlyWareRemainClient(szShopType, nTemplateId)
    if not self.FamilyPool[szShopType] then
        return
    end

    local tbWares = self.tbFamilyShopData[szShopType];

    for _, tbWare in pairs(tbWares) do
        if tbWare.nTemplateId == nTemplateId then
            return tbWare.nCount;
        end
    end

    Log("ERROR IN GetFaimlyWareRemainClient", szShopType, nTemplateId);
    return 0;
end

function Shop:GetBuildingLevelClient(nBuildingId)
    local tbBuildingData = Kin:GetBuildingData(nBuildingId);
    local nBuildingLevel = tbBuildingData and tbBuildingData.nLevel or 0;
    return nBuildingLevel;
end


--有nSyncTemplateId 就是只同步该一个，否则就是同步全部
-- todo 现在只有家族商店的同步了，到时改吧
function Shop:OnSyncShopWares(szShopType, tbShopWares, nSyncTemplateId)
    local tbWares = self.ShopWares[szShopType];
    if nSyncTemplateId then
        if self:IsFamilyShop(szShopType) then
            tbWares[tbShopWares.nLevel][tbShopWares.nPool][nSyncTemplateId] = tbShopWares
        else
            tbWares[nSyncTemplateId] = tbShopWares
        end

    else
        for nTemplateId, tbWare in pairs(tbShopWares) do
            tbWares[nTemplateId] = tbWare;
        end
    end

    UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE);
end

function Shop:OnSyncFamilyShopData(szShopType, tbWareData)
    self.tbFamilyShopData[szShopType] = tbWareData;
    UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE);
end

function Shop:OnBuyResponse(bSuccess, szTip, nRequestIndex, nGoodsId)
    if nRequestIndex then
        self.nRequestIndex = nRequestIndex
    end
    UiNotify.OnNotify(UiNotify.emNOTIFY_SHOP_BUY_RESULT, bSuccess, nGoodsId);
    if szTip then
        me.CenterMsg(szTip);
    end
end

function Shop:OnSellResponse(bSuccess, szTip, nRequestIndex)
    if nRequestIndex then
        self.nRequestIndex = nRequestIndex
    end
    UiNotify.OnNotify(UiNotify.emNOTIFY_SHOP_SELL_RESULT, bSuccess);
    if szTip then
        me.CenterMsg(szTip);
    end
end

function Shop:GetLimitInfo(pPlayer, nLimitType)
    if nLimitType == self.ACT_LIMIT_TYPE then
        return self.tbActLimitInfo
    elseif nLimitType == self.Special_LIMIT_TYPE then
        return self.tbActivityLimitSell
    else
        return self.tbAllWeekLimit
    end
end

function Shop:OnSyncBuyLimitInfo(tbWeekInfo)
    self.tbAllWeekLimit = tbWeekInfo
    self.nLimitSynced = me.dwID
    UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE)
end

function Shop:OnSyncSpecailBuyLimitInfo(tbLimitInfo)
    self.tbActivityLimitSell = tbLimitInfo
    UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE)
end

function Shop:RequestLimitInfo()
    if self.nLimitSynced ~= me.dwID then
        RemoteServer.OnShopRequest("SyncBuyLimitInfo")
    end
    --因为self.nNewsShopActStartTime没有针对活动已经结束,所以还是用了__IsActInProcessByType
    if Activity:__IsActInProcessByType("ShopAct") and self.nNewsShopActStartTime then
        local nTimeNow = GetTime();
        if not self.nNewstActWareUpdateTime  or self.nNewsShopActStartTime > self.nNewstActWareUpdateTime
            or nTimeNow - (self.nLastUpdateTime or 0) >= 4 * 3600 then
            RemoteServer.OnShopRequest("SyncActWaresInfo")
        end
    else
        if self.nNewstActWareUpdateTime then
            self.nNewstActWareUpdateTime = nil;
            self.tbActShopTypes = nil;
            self.tbActLimitInfo = {};
            UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE)
        end
    end
end

function Shop:ConfirmSell(nItemId)
    Ui:CloseWindow("ItemTips")
    Ui:OpenWindow("ItemSellPanel", nItemId)
end

function Shop:SellFakeItem(szType, nItemTemplateId, nCount)
    Ui:CloseWindow("ItemTips")
    Ui:OpenWindow("ItemTemplateSellPanel", szType, nItemTemplateId, nCount);
end

function Shop:QuickSellItem(nItemId, szDesc)
    local pItem = KItem.GetItemObj(nItemId)
    if not pItem then
        return
    end

    local nPrice, szMoneyType = self:GetSellSumPrice(me, pItem.dwTemplateId, pItem.nCount);
    if not szMoneyType or not nPrice then
        return
    end

    local fnAgree = function ()
        local tbToSell = {
            {
                nId = nItemId,
                nCount = pItem.nCount,
            }
        };
        RemoteServer.OnShopRequest("Sell", tbToSell, self.nRequestIndex);
    end

    local szName = Item:GetDBItemShowInfo(pItem, me.nFaction, me.nSex)
    local szMsg = "";
    if szDesc then
        szMsg = string.format(szDesc, nPrice, Shop:GetMoneyName(szMoneyType))
    else
        szMsg = string.format("您确定以 [FFFE0D]%d%s[-] 的价格卖出 [FFFE0D]%s[-] 吗？", nPrice, Shop:GetMoneyName(szMoneyType), szName)
    end
    Ui:OpenWindow("MessageBox",szMsg,
     { {fnAgree},{} },
     {"同意", "取消"});
end

function Shop:ViewMyEquip(nSelItemTemplate)
    local tbBaseInfo = KItem.GetItemBaseProp(nSelItemTemplate);
    if tbBaseInfo.szClass == "Unidentify" then
        nSelItemTemplate = KItem.GetItemExtParam(nSelItemTemplate, 1);
        tbBaseInfo = KItem.GetItemBaseProp(nSelItemTemplate);
    end

    if tbBaseInfo.szClass ~= "equip" then
        return
    end

    local nSelPos = Item.EQUIPTYPE_POS[tbBaseInfo.nItemType]
    local tbEquips = me.GetEquips();
    local nWareId = tbEquips[nSelPos]
    if not nWareId then
        me.CenterMsg("您身上没有装备" .. Item.EQUIPPOS_NAME[nSelPos] )
        return
    end

    Ui:OpenWindowAtPos("EquipTips", -315, 234, nWareId)
end

function Shop:MakeEquip(nId)
    local nCan, szErr = self:CanMakeEquip(me, nId)
    if not nCan then
        me.CenterMsg(szErr)
        return false
    end

    RemoteServer.OnShopRequest("MakeEquip", nId)
    return true
end

function Shop:GetEquipMakerQualities(nHouseId)
    local tbHouseItemId = self.tbEquipMakerIdMap[nHouseId]
    local tbRet = {}
    for nQuality, tb in pairs(tbHouseItemId) do
        if self:IsEquipMakerQualityOpen(nQuality) then
            local tbSetting = self.tbEquipMakerSettings[tb[1]]
            table.insert(tbRet, {
                nQuality = nQuality,
                szQualityName = tbSetting.szQualityName,
            })
        end
    end
    table.sort(tbRet, function(tbA, tbB)
        return tbA.nQuality>tbB.nQuality
    end)
    return tbRet
end

function Shop:GetEquipMakerItems(nHouseId, nQuality)
    local tbRet = {}
    local tbHouseItemId = self.tbEquipMakerIdMap[nHouseId]
    for _, nId in ipairs(tbHouseItemId[nQuality] or {}) do
        table.insert(tbRet, self.tbEquipMakerSettings[nId])
    end
    return tbRet
end

function Shop:OnEquipMakerRet(nItemId)
    UiNotify.OnNotify(UiNotify.emNOTIFY_EQUIP_MAKE_RSP, nItemId)
end

function Shop:AutoChooseItem(nItemId)
    local tbAllTreaste = Shop:GetShopWares("Treasure", "tabLimitShop", true)
    for i,v in ipairs(tbAllTreaste) do
        if v.nTemplateId == nItemId then
            if Shop:GetWareRemainCount(me, v) > 0 then
                Ui:OpenWindow("CommonShop","Treasure", "tabLimitShop", nItemId)
                Ui:CloseWindow("ItemTips")
                return true
            end
            break;
        end
    end

    local tbAllTreaste = Shop:GetShopWares("Treasure", "tabAllShop", true)
    for i,v in ipairs(tbAllTreaste) do
        if v.nTemplateId == nItemId then
            Ui:OpenWindow("CommonShop","Treasure", "tabAllShop", nItemId)
            Ui:CloseWindow("ItemTips")
            return true
        end
    end
    return false
end

function Shop:OnSyncActWaresInfo(tbWares, tbActLimitInfo, nNewstActWareUpdateTime)
    for szShopType,tbTreatureWares in pairs(Shop.ShopWares) do
        for nGoodsId,v in pairs(tbTreatureWares) do
            if v.nLimitType == self.ACT_LIMIT_TYPE then
                tbTreatureWares[nGoodsId] = nil;
            end
        end
    end

    local tbShowShopTypes = {};
    for k,v in pairs(tbWares) do
        --可能出现已经过期的，客户端过滤去掉并去掉对应的shopType
        if Shop:CheckWareAvaliable(v, me) then
            local szShopType = v.szShopType
            local tbTreatureWares = Shop.ShopWares[szShopType]
            if Lib:IsEmptyStr(v.SubType) then
                v.SubType = "tabActShop";
            end
            tbTreatureWares[v.nGoodsId] = v;
            tbShowShopTypes[szShopType] = 1;
        end
    end
    self.tbActShopTypes = tbShowShopTypes;

    self.tbActLimitInfo = tbActLimitInfo
    self.nNewstActWareUpdateTime = nNewstActWareUpdateTime
    self.nLastUpdateTime = GetTime();
    UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE)
end

function Shop:OnSyncActBuyLimitInfo( tbActLimitInfo)
    self.tbActLimitInfo = tbActLimitInfo;
    UiNotify.OnNotify(UiNotify.emNOTIFY_SYNC_SHOP_WARE)
end

function Shop:RenownShopRefresh()
    if not self:ShouldRenownShopRefresh(me) then
        return
    end
    RemoteServer.OnShopRequest("RenownShopRefresh")
end

function Shop:RenownShopBuy(nId, nCount)
    local bOk, szErr = self:RenownShopCheckBeforeBuy(me, nId, nCount)
    if not bOk then
        me.CenterMsg(szErr)
        return
    end
    local tbSetting = self.tbRenownShop[nId]
    RemoteServer.OnShopRequest("RenownShopBuy", nId, nCount, tbSetting.nPrice)
end

function Shop:RenownShopRefreshed()
    UiNotify.OnNotify(UiNotify.emNoTIFY_RENOWN_SHOP_REFRESH)
end

function Shop:RenownShopBought(tbInfo)
    me.CenterMsg("购买成功")
    UiNotify.OnNotify(UiNotify.emNoTIFY_RENOWN_SHOP_REFRESH)
end

function Shop:RenownShopGetItems()
    local tbRet = {}
    for nId, tbSetting in pairs(self.tbRenownShop) do
        local nCount = me.GetUserValue(self.nRenownShopSaveGrp, nId)
        if nCount~=0 then
            table.insert(tbRet, {
                nId = nId,
                nIndex = tbSetting.nIndex,
                nItemId = tbSetting.nItemId,
                nPrice = tbSetting.nPrice,
                nLeft = nCount<0 and 0 or nCount,
            })
        end
    end
    table.sort(tbRet, function(tbA, tbB)
        return tbA.nIndex<tbB.nIndex or (tbA.nIndex==tbB.nIndex and tbA.nId<tbB.nId)
    end)
    return tbRet
end

Shop.tbBuyNotiyMsgFunc = {
    ["waiyi_exchange"] = function (nTemplateId, tbItemBase)
        local nTargetId = Item.tbEquipExchange:GetTargetItem(nTemplateId)
        if nTargetId then
            local tbBaseTar = KItem.GetItemBaseProp(nTargetId)
            if tbBaseTar.nFactionLimit > 0 then
                local szColor = tbBaseTar.nFactionLimit == me.nFaction and "FFFE0D" or "FF0000"
                return string.format("您即将购买[%s]%s[-]永久外装，此外装仅[%s]%s人士[-]可使用，切换其他门派后该外装即无法使用。您确认要购买吗？", szColor, tbItemBase.szName, szColor, Faction:GetName(tbBaseTar.nFactionLimit))
            end
        end
    end;
    ["ProposeItem"] = function (nTemplateId, tbItemBase)
        local nCount = me.GetItemCountInBags(nTemplateId)
        if nCount > 0 then
            return string.format("背包中已有[FFFE0D]%s[-]，确定要继续购买吗？", tbItemBase.szName)
        end
    end;
}

function Shop:TryBuyItem(bKinStore, szShopType, nTemplateId, nGoodsId, nbuyCount, nPrice)
    local fnYes;
    if bKinStore then
        fnYes = function ()
            RemoteServer.OnShopRequest("Buy", szShopType, nTemplateId, nbuyCount, nPrice, Shop.nRequestIndex);
        end
    else
        fnYes = function ()
            RemoteServer.OnShopRequest("BuyGoods", szShopType, nGoodsId, nbuyCount, nPrice, Shop.nRequestIndex);
        end
    end

    local szMsg;
    local tbItemBase = KItem.GetItemBaseProp(nTemplateId)
    local fnNotiyMsgFunc = self.tbBuyNotiyMsgFunc[tbItemBase.szClass]
    if fnNotiyMsgFunc then
        szMsg = fnNotiyMsgFunc(nTemplateId, tbItemBase)
    end

    if szMsg then
        me.MsgBox(szMsg ,{
            {"确认", fnYes},
            {"取消"},
        })
    else
       fnYes();
    end
end

function Shop:GetWaiyiItemFromItemInfo(tbItemBase, nTemplateId, nFaction)
    if tbItemBase.szClass == "ExchangeItemByFaction" then
       return Item:GetClass("ExchangeItemByFaction"):GetExhangeItemId(nTemplateId, nFaction)
    elseif Item.tbEquipExchange.tbItemSetting[nTemplateId] then
        return  Item.tbEquipExchange.tbItemSetting[nTemplateId].WaiYiItem
    elseif tbItemBase.szClass == "waiyi" then
        return nTemplateId
    elseif tbItemBase.szClass == "AddWaiyiColor" then
        return KItem.GetItemExtParam(nTemplateId, 1);
    end
end

function Shop:CanPreViewTargetWaiyiListFromItemPack(nTemplateId, nFaction)
    local tbItemBase = KItem.GetItemBaseProp(nTemplateId)
    -- local nTargetWaiyi;
    local tbTargetWaiyis = {};
    local tbPackItems = {}; --对应的外面包的一层的道具

    local tbItemClass = Item:GetClass(tbItemBase.szClass)
    if tbItemClass and tbItemClass.GetFixRandItemAward then
        local nParamId = KItem.GetItemExtParam(nTemplateId, 1);
        local nRet, tbAward = tbItemClass:GetFixRandItemAward(nParamId)
        if nRet == 1 and tbAward then
            for i,v in ipairs(tbAward) do
                local szType,nItemId = unpack(v)
                if Player.AwardType[szType] == Player.award_type_item then
                    local _tbItemBase = KItem.GetItemBaseProp(nItemId)
                    local nSubTargetWaiyi = self:GetWaiyiItemFromItemInfo(_tbItemBase, nItemId, nFaction)
                    if nSubTargetWaiyi then
                        table.insert(tbTargetWaiyis, nSubTargetWaiyi)
                        table.insert(tbPackItems, nItemId)
                        -- nTargetWaiyi = nSubTargetWaiyi
                    end
                end
            end
        end
    else
        local nTargetWaiyi =  self:GetWaiyiItemFromItemInfo(tbItemBase, nTemplateId, nFaction)
        if nTargetWaiyi then
            table.insert(tbTargetWaiyis, nTargetWaiyi)
            table.insert(tbPackItems, nTemplateId)
        end
    end
    return tbTargetWaiyis, tbPackItems
end

function Shop:ClinetInit()
    --家族商店的商品，由服务端通过来过给客户端
    self.tbFamilyShopData = {
        ["DrugShop"]        = {};
        ["WarShop"]      = {};
    }
    self.nLimitSynced = nil;
    self.nNewstActWareUpdateTime = nil;
    self.nNewsShopActStartTime = nil;
    self.tbActLimitInfo = {};

    self.tbLocalUpdateWareBuidLevel = {}
    self.nRequestIndex = 0; --每次交易成功后操作客户端单号+1, 失败则单号不变 ,服务端不会处理已成功的单号
end

Shop:ClinetInit()
