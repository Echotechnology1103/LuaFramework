local NetClient = class("NetClient")

local SocketManager=cc.SocketManager:getInstance()
local NetCC=cc.NetClient:getInstance()

NetCC:setNetMsgListen(NetProtocol.cNotifyMapEnter,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyMapMiniNpc,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyMapConn,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyHPMPChange,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyMapOption,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyInjury,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyGuildInfo,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyForceMove,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyCharacterLoad,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyAvatarChange,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyPowerChange,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyBuffChange,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyStatusChange,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyListBuff,true)
NetCC:setNetMsgListen(NetProtocol.cNotifyTeamInfo,true)
--这两条在C++修改后可以去掉
--NetCC:setNetMsgListen(NetProtocol.cNotifyRelive,true)
--NetCC:setNetMsgListen(NetProtocol.cNotifyMapBye,true)


local zlib = require("zlib")

-- 去掉装备名称末尾的数字标识
local function reNameEquip(name)
	return string.gsub(name,"(.+)(.)([1-3])$",function(s,n,m)
		local temp = tonumber(n)
		if not temp and m then
			return s..n
		else
			return s..n..m
		end
	end)
end

function NetClient:ctor()

	cc.GameObject.extend(self):addComponent("components.behavior.EventProtocol"):exportMethods()

	self._netChars={}
	self._reqChar=false
	self._connected=false
	self.nearByGroupInfo = {}
	
	self.PKMapIds = {"chiwooBattle",}
	-- self.inviteGQueue = {}
	-- self.applyGQueue = {}
	self.mGroupMembers = {}

	-- self.tipsMsg = {}
	self.applyList={}

	self.mails = {}

	self.guideTab={}

	self.skillRed={}

	self:init()

	self.NetFunc={

	[NetProtocol.cNotifySessionClosed] = function(mMsg)
		local msgstr=mMsg:readString()
		local function exitDelay()
			PlatformTool.showMsg(msgstr)
			game.ExitToRelogin()
		end
		local scene=cc.Director:getInstance():getRunningScene()
		scene:runAction(cc.Sequence:create(cc.DelayTime:create(3), cc.CallFunc:create(exitDelay)));
	end,

	[NetProtocol.cResAuthenticate] = function(mMsg)
		local param=mMsg:readInt()
		if param == 100 and self.kuaFuInfo then
			NetClient:EnterGame(game.chrName,game.seedName)
		end
		self:dispatchEvent({name=Notify.EVENT_AUTHENTICATE,result=param})
	end,

	[NetProtocol.cNotifyYouKeSessionID] = function(mMsg)
		local param = mMsg:readString()
		self:dispatchEvent({name=Notify.EVENT_AUTHENTICATE,result=param})
	end,

	[NetProtocol.cResListCharacter] = function(mMsg)
		local netchar={}
		local mCharListChinaLimit = mMsg:readInt()
		local charlistnumber = mMsg:readInt()
		local curSvrid = 1
		if game.lastSvr then
			curSvrid = tonumber(game.lastSvr.serial) or 0
		end
		local isCurSvr = false
		for i=1,charlistnumber do
			-- if charlistnumber >0 and charlistnumber >= i then
			local char = {}
			char.mLevel			= mMsg:readInt()
			char.mJob			= mMsg:readInt()
			char.mGender		= mMsg:readInt()
			char.mSvrid			= mMsg:readInt()
			char.mOnline		= mMsg:readInt()
			char.mName			= mMsg:readString()
			char.mSeedName		= mMsg:readString()
			char.mCloth			= mMsg:readInt()
			char.mWeapon		= mMsg:readInt()
			char.mFashionCloth	= mMsg:readInt()
			char.mFashionWeapon	= mMsg:readInt()
			char.mWing			= mMsg:readInt()
			-- char.mRoleId		= mMsg:readString()
			-- char.mCreateTime    = mMsg:readInt()
			netchar[i] = char
			-- end
			if char.mSvrid>0 and curSvrid>0 and char.mSvrid == curSvrid then
				isCurSvr = true
			end
		end
		if self._reqChar then
			if isCurSvr then
				self._netChars = {}
				for k,v in ipairs(netchar) do
					if v.mSvrid == curSvrid or v.mSvrid == 0 then
						table.insert(self._netChars,v)
					end
				end
			else
				self._netChars=netchar
			end
			self:dispatchEvent({name=Notify.EVENT_LOADCHAR_LIST})
			self._reqChar=false
		end
	end,

	[NetProtocol.cResDeleteCharacter] = function(mMsg)
		local result = mMsg:readInt()
		if result == 100 then
			self:ListCharacter()
			--这个地方的url要检查
			--local url = CONFIG_CENTER_URL.."deleteRole?sku="..game.sku.."&account="..game.gameUserid.."&serverId="..game.zoneId
			--	.."&pid="..PlatformTool.getConfigString("platform_id").."&idfa="..PlatformTool.getConfigString("system_code")
			--util.httpRequest(url)--服务删角记录
		end
	end,

	[NetProtocol.cResEnterGame] = function(mMsg)

		local result=mMsg:readInt()
		if result==100 then
			game.storyIndex = nil--防止意外掉线重连后不放剧情主线不继续

			if cc.UserDefault:getInstance():getStringForKey("last_receipt","")~="" then
				local last_receipt = "receipt|"..cc.UserDefault:getInstance():getStringForKey("last_receipt","")
				local last_money = cc.UserDefault:getInstance():getStringForKey("last_money","0")

				HttpManager:appCheckReceipt(last_receipt,last_money)

				local count = tonumber(cc.UserDefault:getInstance():getStringForKey("last_count","0"))
				cc.UserDefault:getInstance():setStringForKey("last_count",tostring(count+1))
				cc.UserDefault:getInstance():flush()
			end

			if not game.noSubmit then
				if PLATFORM_APP_STORE then

				end
				game.noSubmit = false
			end

			-- game.cleanGame()
		elseif result==103 then
			game.storyIndex = nil--防止意外掉线重连后不放剧情主线不继续

		else
			-- game.ExitToRelogin()
			-- PlatformTool.hideWaiting()
			-- PlatformTool.showMsg("账号登录失败")
			-- util.showAlert("", "账号登录失败", "知道了")
		end
		self:dispatchEvent({name=Notify.EVENT_RES_ENTER_GAME,result=result})
	end,

	--创建角色  和 修改名称共用
	[NetProtocol.cResCreateCharacter] = function(mMsg)
		local result = mMsg:readInt()
		local seedname = mMsg:readString()
		local roleid = mMsg:readString()
		local createtime = mMsg:readInt()

		local error_msg="角色创建成功"
		if result ~= 100 then
			if result == 101 then
				error_msg = "角色创建失败,系统错误"
			elseif result == 102 then
				error_msg = "角色创建失败,不能创建更多的人物了"
			elseif result == 103 then
				error_msg = "角色创建失败,名称重复"
			elseif result == 104 then
				error_msg = "角色创建失败, 名称中包含非法字符"
			elseif result == 105 then
				error_msg = "角色名已存在，修改失败！"
			elseif result == 106 then
				error_msg = "名称中包含非法字符"
			elseif result == 107 then
				error_msg = "名字修改成功"
			end
		else
			
			--这个地方的url要检查
			-- local url = CONFIG_CENTER_URL.."createRole?sku="..game.sku.."&account="..game.gameUserid.."&serverId="..game.zoneId
			-- 	.."&pid="..PlatformTool.getConfigString("platform_id").."&idfa="..PlatformTool.getConfigString("system_code")
			-- util.httpRequest(url)--服务创角记录

			game.newRole = true
		end
		if result <= 104 then
			self:dispatchEvent({name=Notify.EVENT_CREATECHARACTOR,result=result,msg=error_msg,seedname=seedname,roleid=roleid,createtime=createtime})
		else
			if result == 107 then
				self:dispatchEvent({name = Notify.EVENT_HIDE_TIPS, str = "modifyName"})	
			end
			self:alertLocalMsg(error_msg)
		end
	end,
	
	[NetProtocol.cNotifyListUpgradeDesp] = function (mMsg)
		local count = mMsg:readInt()
		for i=1,count do
			local tt=mMsg:getValues("iiiiiiiiiiiii")
			local uid = {}
			uid.mJob = tt[1]
			uid.mEquipType = tt[2]
			uid.mLevel = tt[3]
			uid.mDC = tt[4]
			uid.mDCMax = tt[5]
			uid.mMC = tt[6]
			uid.mMCMax = tt[7]
			uid.mSC = tt[8]
			uid.mSCMax = tt[9]
			uid.mAC = tt[10]
			uid.mACMax = tt[11]
			uid.mMAC = tt[12]
			uid.mMACMax = tt[13]
			self.mUpgradeDesp[uid.mJob*10000+uid.mEquipType*100+uid.mLevel]=uid
		end
		-- --print("/////////cNotifyListUpgradeDesp///////////", count, util.encode(self.mUpgradeDesp))
	end,

	-- [NetProtocol.cNotifyListShengshiDesp] = function(mMsg)
		-- local count = mMsg:readInt()
		-- for i=1, count do
			-- local tt = mMsg:getValues("iiiiz")
			-- local newItem = {}
			-- newItem.mShengshiId = tt[1]
			-- newItem.mEquipType = tt[2]
			-- newItem.mNeedItemId = tt[3]
			-- newItem.mEffectId = tt[4]
			-- newItem.mDesc = tt[5]

			-- self.mShengshiList[newItem.mShengshiId] = newItem
		-- end
	-- end,

	[NetProtocol.cNotifyListItemChange] = function (mMsg)
		local count = mMsg:readInt()
		for i=1,count do
			local tt=mMsg:getValues("iiiiiiisssssssssssssississiiii")
			local newItem = {}
			newItem.position = tt[1]
			newItem.mTypeID = tt[2]
			newItem.mDuraMax = tt[3]
			newItem.mDuration = tt[4]
			newItem.mItemFlags = tt[5]

			newItem.mLevel = tt[6]
			newItem.mNumber = tt[7]

			newItem.mAddAC = tt[8]
			newItem.mAddMAC = tt[9]
			newItem.mAddDC = tt[10]
			newItem.mAddMC = tt[11]
			newItem.mAddSC = tt[12]

			newItem.mUpdAC = tt[13]
			newItem.mUpdMAC = tt[14]
			newItem.mUpdDC = tt[15]
			newItem.mUpdMC = tt[16]
			newItem.mUpdSC = tt[17]

			newItem.mUpdMaxCount = tt[18]
			newItem.mUpdFailedCount = tt[19]

			newItem.mLuck = tt[20]
			local show_flags = tt[21]
			newItem.mProtect = tt[22]

			newItem.mSellPriceType = tt[23]
			newItem.mSellPrice = tt[24]

			newItem.mAddHp = tt[25]
			newItem.mAddMp = tt[26]
			newItem.mCreateTime = tt[27]
			newItem.mLastTime = tt[28]
			newItem.mZLevel = tt[29]
			newItem.mLock = tt[30]
newItem.role = mMsg:readString()
			newItem.from = mMsg:readString()
			newItem.map = mMsg:readString()
			if newItem.mTypeID > 0 and newItem.position > -999 then
				self.mItems[newItem.position] = newItem
			end
		end
		self:dispatchEvent({name=Notify.EVENT_ALL_ITEM_LOADED})
	end,

	[NetProtocol.cNotifyItemChange] = function(mMsg)
		local tt=mMsg:getValues("iiiiiiisssssssssssssississiiii")

		local newItem = {}
		newItem.position = tt[1]
		newItem.mTypeID = tt[2]
		newItem.mDuraMax = tt[3]
		newItem.mDuration = tt[4]
		newItem.mItemFlags = tt[5]

		newItem.mLevel = tt[6]
		newItem.mNumber = tt[7]

		newItem.mAddAC = tt[8]
		newItem.mAddMAC = tt[9]
		newItem.mAddDC = tt[10]
		newItem.mAddMC = tt[11]
		newItem.mAddSC = tt[12]

		newItem.mUpdAC = tt[13]
		newItem.mUpdMAC = tt[14]
		newItem.mUpdDC = tt[15]
		newItem.mUpdMC = tt[16]
		newItem.mUpdSC = tt[17]

		newItem.mUpdMaxCount = tt[18]
		newItem.mUpdFailedCount = tt[19]


		newItem.mLuck = tt[20]
		local show_flags = tt[21]
		newItem.mProtect = tt[22]

		newItem.mSellPriceType = tt[23]
		newItem.mSellPrice = tt[24]

		newItem.mAddHp = tt[25]
		newItem.mAddMp = tt[26]
		newItem.mCreateTime = tt[27]
		newItem.mLastTime = tt[28]
		----print("======>>>",newItem.position,newItem.mTypeID,newItem.mLastTime)
		newItem.mZLevel = tt[29]
		newItem.mLock = tt[30]
		
			newItem.role = mMsg:readString()
			newItem.from = mMsg:readString()
			newItem.map = mMsg:readString()
		local oldType=nil
		if self.mItems[newItem.position] ~= nil then
			--装备卸下
			oldType=self.mItems[newItem.position].mTypeID
			self.mItems[newItem.position] = nil
		end
		if game.isPinTu(newItem.mTypeID) then
			NetClient:PushLuaTable("gui.PanelBossPictrue.handlePanelData",util.encode({actionid = "reqCheckRedPoint",params={}}))
		end
		if newItem.mTypeID > 0 and newItem.position > -999 then
			self.mItems[newItem.position] = newItem
			if show_flags > 0 and show_flags ~= 100 then --获得更好装备提示以及需要提示使用消耗丹药
				local itemdef = self:getItemDefByID(newItem.mTypeID)
				if itemdef then
					if game.IsPosInBag(newItem.position) then
						if itemdef.mCanPush == 1 then
							if game.IsEquipment(newItem.mTypeID) then
								-- --print("///////////////check_better_item///////////////", newItem.position, self:check_better_item(newItem.position))
								if self:check_better_item(newItem.position) then
									-- if not self.tipsMsg["tip_equip"] then self.tipsMsg["tip_equip"] = {} end
									-- 右侧装备提示
									-- table.insert(game.PROMPT_ITEM.equip,1,{newItem.mTypeID, newItem.position, time = os.time()})
									self:dispatchEvent({name=Notify.EVENT_BETTER_ITEM, itemPos = newItem.position, mTypeID = newItem.mTypeID})
								end
							else
								-- if game.isUsageTipProp(newItem.mTypeID) then
									self:dispatchEvent({name=Notify.EVENT_BETTER_ITEM, itemPos = newItem.position, mTypeID = newItem.mTypeID})
								-- end
								-- if itemdef.mEquipLevel > 0 and show_flags ~= 110 then -- 获得消耗品的使用提示--暂时屏蔽
								-- 	-- table.insert(game.PROMPT_ITEM.diss,1,{newItem.mTypeID, newItem.position})
								-- 	-- self:dispatchEvent({name=Notify.EVENT_BETTER_ITEM, diss = true})
								-- end
							end
						end

						--------------获得物品动画--------------
						self:dispatchEvent({name = Notify.EVENT_ITEM_GOT_ANIMATION, typeid = newItem.mTypeID})
					end

					local msg = {
						{"获得装备:", "30FF00"},	--mxwx	
						{itemdef.mName, "30FF00"}
					}
					local jpmsg = {
						{"获得极品装备:", "D71345"},	--mxwx	
						{itemdef.mName, "D71345"}
					}
					local djmsg = {
						{"获得道具:", "918597"},	--mxwx	
						{itemdef.mName, "918597"}
					}
					if itemdef.mColor > 0 then msg[2][2] = util.getColorHex(itemdef.mColor) end
					if itemdef.mColor == 1 then --mxwx itemdef在color填写1位普通装备
						self:alertLocalMsg(util.encode(msg),"right")
					end	
					if itemdef.mColor == 2 then --mxwx itemdef在color填写2位极品装备
						self:alertLocalMsg(util.encode(msg),"right")
					end
					if itemdef.mColor == 3 then --mxwx itemdef在color填写3位位道具，其他不提示
						self:alertLocalMsg(util.encode(msg),"right")
					end
				end
			end

			-- if newItem.position < 0 then -- 装备穿戴
				-- local b = self:checkTaskState(1000)
				-- if b == 74 or b == 78 or b == 82 then
				-- 	self:PushLuaTable("gui.moduleGuide.checkMainTaskEquip","")
				-- end
				-- self:PushLuaTable("gui.PanelEquipPreview.onPanelData",util.encode({actionid = "onEquipUpgraded"}))
				-- if MainRole then MainRole.handleEquipChange(newItem.position) end
			-- end
			if newItem.position < 0 then
				if newItem.position == -2 then
					PlayAudio.play("sound/equipweapon.mp3")
				elseif newItem.position == (-28 * 2) then		--坐骑
					PlayAudio.play("sound/equipcloth.mp3")
					self:dispatchEvent({name=Notify.EVENT_MOUNT_CHANGE,{pos=newItem.position}})
				else
					PlayAudio.play("sound/equipcloth.mp3")
				end
			elseif newItem.position == (-28 * 2) then
				self:dispatchEvent({name=Notify.EVENT_MOUNT_CHANGE,{pos=newItem.position}})
			end
		end

		game.bagFullFlag=self:isBagFull()
		-- --print(newItem.position,newItem.position,newItem.position,newItem.position)

		self:dispatchEvent({name=Notify.EVENT_ITEM_CHANGE,pos=newItem.position,oldType=oldType})

		if show_flags ~= 100 then
			self:dispatchEvent({name = Notify.EVENT_CHECK_BETTER_EQUIP})
		end

		if MainRole then -- 主线检测强化转移
			MainRole.checkShiftEquip()
		end

		if self:isPosInBag(newItem.position) then--背包物品
			self:checkBagFull(newItem.position)
			-- self.bagItems[newItem.position] = newItem
			-- game.recordBoxMatch()
			self:checkBagRedDot()
		end

		if self.mGemItems[newItem.position]~=nil then
			self.mGemItems[newItem.position]=nil
		end

		--宝石背包
		-- if newItem.position >= Const.ITEM_XUANJING_BEGIN and newItem.position < Const.ITEM_XUANJING_BEGIN + Const.ITEM_XUANJING_SIZE then
		-- 	self.mGemItems[newItem.position] = newItem
		-- 	self:PushLuaTable("gui.PanelQiangHua.handlePanelData",util.encode({actionid = "chechGemRed",params = {}}))
		-- end
		-- if newItem.mTypeID>=10154 and newItem.mTypeID<=10163 then--称号升级材料
			-- self:PushLuaTable("gui.PanelTitle.onPanelData",util.encode({actionid = "reqTitleUp",params = {}}))
		-- end
		if newItem.mTypeID == 40000019 then--称号升级材料
			self:PushLuaTable("gui.PanelTitle.onPanelData",util.encode({actionid = "reqTitleUp",params = {}}))
		end
	end,
	[NetProtocol.cNotifyListItemDesp] = function (mMsg)
		local count = mMsg:readInt()
		for i=1,count do
			-- local tt=mMsg:getValues("zziiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiz")
			local tt=mMsg:getValues("zziiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiziiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
			
			local nid = {}
			nid.mName = tt[1]
			nid.mDesp = tt[2]
			nid.mTypeID = tt[3]
			nid.mIconID = tt[4]
			nid.mPrice = tt[5]

			nid.mWeight = tt[6]
			nid.mLastTime = tt[7]

			nid.mDurationMax = tt[8]
			nid.mNeedType = tt[9]
			nid.mNeedParam = tt[10]

			nid.mNeedReinLv = tt[11]
			nid.mColor = tt[12]
			nid.mNotips = tt[13]
			nid.mResMale = tt[14]
			nid.mResFeMale = tt[15]

			nid.mAC = tt[16]
			nid.mACMax = tt[17]
			nid.mMAC = tt[18]
			nid.mMACMax = tt[19]
			nid.mDC = tt[20]
			nid.mDCMax = tt[21]
			nid.mMC = tt[22]
			nid.mMCMax = tt[23]
			nid.mSC = tt[24]
			nid.mSCMax = tt[25]

			nid.mLuck = tt[26]

			nid.mCurse = tt[27]
			nid.mAccuracy = tt[28]
			nid.mDodge = tt[29]
			nid.mAntiMagic = tt[30]
			nid.mAntiPoison = tt[31]

			nid.mHpRecover = tt[32]
			nid.mMpRecover = tt[33]
			nid.mPoisonRecover = tt[34]
			nid.SubType = tt[35]
			nid.HPChange = tt[36]

			nid.MPChange = tt[37]
			nid.ZipType = tt[38]
			nid.ZipNumber = tt[39]
			nid.mMabiProb = tt[40]
			nid.mMabiDura = tt[41]

			nid.mDixiaoPres = tt[42]
			nid.mFuyuanCd = tt[43]
			nid.mFuyuanPres = tt[44]
			nid.mMaxHp = tt[45]
			nid.mMaxMp = tt[46]

			nid.mMaxHpPres = tt[47]
			nid.mMaxMpPres = tt[48]
			nid.mNeedZsLevel = tt[49]
			nid.mEquipLevel = tt[50]
			nid.mEquipComp = tt[51]
			nid.mEquipGroup = tt[52]
			nid.mEquipContribute = tt[53]
			nid.mShowDest = tt[54]
			nid.mAddPower = tt[55]
			nid.mJob = tt[56]
			nid.mGender = tt[57]
			nid.mBaoji = tt[58]

			nid.mDrop_luck = tt[59]
			nid.mStackMax = tt[60]
			nid.mEquipType = tt[61]
			nid.mXishouProb = tt[62]
			nid.mXishouPres = tt[63]

			nid.mFantanProb = tt[64]
			nid.mFantanPres = tt[65]
			nid.mBaojiProb = tt[66]
			nid.mBaojiPres = tt[67]
			nid.mXixueProb = tt[68]

			nid.mXixuePres = tt[69]
			nid.mRandAC = tt[70]
			nid.mRandMAC = tt[71]
			nid.mRandDC = tt[72]
			nid.mRandMC = tt[73]

			nid.mRandSC = tt[74]
			nid.mItemBg = tt[75]

			nid.mRecycleExp = tt[76]
			nid.mRecycleXuefu = tt[77]
			nid.mCanUse = tt[78]
			nid.mCanDestroy = tt[79]
			nid.mCanDepot = tt[80]
			nid.mCanPush = tt[81]
			nid.mBagShow = tt[82]
			nid.mTimesLimit = tt[83]
			nid.mSource = tt[84]
			nid.mDropEffect = tt[85]
			nid.mBeiGong_prob = tt[86]
            nid.mBeiGong_dura= tt[87]
			nid.mQieGe_prob = tt[88]
			nid.mQieGe_dura = tt[89]
			nid.mMovespeed = tt[90]
				 nid.mAtkSpeed_prob = tt[91]
			nid.mAtkSpeed_dura = tt[92]
			 nid.mBurstRate = tt[93]
		nid.mjiansu_prob = tt[94]
		nid.mjiansu_dura = tt[95]
		nid.mBeiJing = tt[96]

		nid.mIconDesc = tt[97]--品阶
		nid.mEqeffect = tt[98]--icon特效
		---套装属性显示
		nid.mTzdc = tt[99]
		nid.mTzac = tt[100]
		nid.mTzhp = tt[101]
		nid.mTzbaoji = tt[102]
		nid.mTzdamage = tt[103]
		nid.mTzacjian = tt[104]
		nid.mTzaccuracy = tt[105]
		nid.mTzdodge = tt[106]
		nid.mTzluck = tt[107]
		nid.mRecycleMoney = tt[108]
		nid.mRecycleVcionBind = tt[109]
		nid.mUserCon = tt[110]
		nid.mPkIncrement = tt[111]
		nid.mFangmabi = tt[112]
		nid.mBingdong_prob = tt[113]
		nid.mBingdong_pres = tt[114]
			-- nid.mBeiShang = tt[85]--倍伤
			-- nid.mMianShang = tt[86]--免伤
			-- nid.mACRatio = tt[87] --人物总体物防万分比
			-- nid.mMCRatio = tt[88] --人物总体魔防万分比
			-- nid.mDCRatio = tt[89] --人物总体战攻万分比
			-- nid.mIgnoreDCRatio = tt[90] --忽视防御万分比
			-- nid.mPlayDrop = tt[91]    --人物爆率万分比提升
			-- nid.mMonsterDrop = tt[92]    --人物爆率万分比提升
			-- nid.mDropProtect = tt[93]    --防爆几率万分比
			-- nid.mMabiProtect = tt[94]    --防止麻痹万分比

			nid.mPlusA={}
			nid.mPlusB={}

			self.mItemDesp[nid.mTypeID]=nid
			-- --print("cNotifyListItemDesp", nid.mTypeID, util.encode(nid));
		end

		-- self:dispatchEvent({name = Notify.EVENT_NOTIFY_GETITEMDESP,type_id = nid.mTypeID})
	end,

	[NetProtocol.cNotifyItemDesp] = function(mMsg)
		local nid={}

		local tt=mMsg:getValues("zziiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiziiiiiiiiiiiiiii")
		nid.mName = tt[1]
		nid.mDesp = tt[2]
		nid.mTypeID = tt[3]
		nid.mIconID = tt[4]
		nid.mPrice = tt[5]

		nid.mWeight = tt[6]
		nid.mLastTime = tt[7]

		nid.mDurationMax = tt[8]
		nid.mNeedType = tt[9]
		nid.mNeedParam = tt[10]

		nid.mNeedReinLv = tt[11]
		nid.mColor = tt[12]
		nid.mNotips = tt[13]
		nid.mResMale = tt[14]
		nid.mResFeMale = tt[15]

		nid.mAC = tt[16]
		nid.mACMax = tt[17]
		nid.mMAC = tt[18]
		nid.mMACMax = tt[19]
		nid.mDC = tt[20]
		nid.mDCMax = tt[21]
		nid.mMC = tt[22]
		nid.mMCMax = tt[23]
		nid.mSC = tt[24]
		nid.mSCMax = tt[25]

		nid.mLuck = tt[26]

		nid.mCurse = tt[27]
		nid.mAccuracy = tt[28]
		nid.mDodge = tt[29]
		nid.mAntiMagic = tt[30]
		nid.mAntiPoison = tt[31]

		nid.mHpRecover = tt[32]
		nid.mMpRecover = tt[33]
		nid.mPoisonRecover = tt[34]
		nid.SubType = tt[35]
		nid.HPChange = tt[36]

		nid.MPChange = tt[37]
		nid.ZipType = tt[38]
		nid.ZipNumber = tt[39]
		nid.mMabiProb = tt[40]
		nid.mMabiDura = tt[41]

		nid.mDixiaoPres = tt[42]
		nid.mFuyuanCd = tt[43]
		nid.mFuyuanPres = tt[44]
		nid.mMaxHp = tt[45]
		nid.mMaxMp = tt[46]

		nid.mMaxHpPres = tt[47]
		nid.mMaxMpPres = tt[48]
		nid.mNeedZsLevel = tt[49]
		nid.mEquipLevel = tt[50]
		nid.mEquipComp = tt[51]
		nid.mEquipGroup = tt[52]
		nid.mEquipContribute = tt[53]
		nid.mShowDest = tt[54]
		nid.mAddPower = tt[55]
		nid.mJob = tt[56]
		nid.mGender = tt[57]
		nid.mBaoji = tt[58]

		nid.mDrop_luck = tt[59]
		nid.mStackMax = tt[60]
		nid.mEquipType = tt[61]
		nid.mXishouProb = tt[62]
		nid.mXishouPres = tt[63]

		nid.mFantanProb = tt[64]
		nid.mFantanPres = tt[65]
		nid.mBaojiProb = tt[66]
		nid.mBaojiPres = tt[67]
		nid.mXixueProb = tt[68]

		nid.mXixuePres = tt[69]
		nid.mRandAC = tt[70]
		nid.mRandMAC = tt[71]
		nid.mRandDC = tt[72]
		nid.mRandMC = tt[73]

		nid.mRandSC = tt[74]
		nid.mItemBg = tt[75]

		nid.mRecycleExp = tt[76]
		nid.mRecycleXuefu = tt[77]
		nid.mCanUse = tt[78]
		nid.mCanDestroy = tt[79]
		nid.mCanDepot = tt[80]
		nid.mCanPush = tt[81]
		nid.mBagShow = tt[82]
		nid.mTimesLimit = tt[83]
		nid.mSource = tt[84]
		nid.mIconDesc = tt[85]--品阶
		nid.mEqeffect = tt[86]--icon特效
		---套装属性显示
		nid.mTzdc = tt[87]
		nid.mTzac = tt[88]
		nid.mTzhp = tt[89]
		nid.mTzbaoji = tt[90]
		nid.mTzdamage = tt[91]
		nid.mTzacjian = tt[92]
		nid.mTzaccuracy = tt[93]
		nid.mTzdodge = tt[94]
		nid.mTzluck = tt[95]
		nid.mRecycleMoney = tt[96]--新加回收和别
		nid.mRecycleVcionBind = tt[97]--新加回收货币
		nid.mUserCon = tt[98]--新加回收货币
		nid.mPkIncrement = tt[99]
		-- nid.mBeiShang = tt[85]
		-- nid.mMianShang = tt[86]
		-- nid.mACRatio = tt[87] --人物总体物防万分比
		-- nid.mMCRatio = tt[88] --人物总体魔防万分比
		-- nid.mDCRatio = tt[89] --人物总体战攻万分比
		-- nid.mIgnoreDCRatio = tt[90] --忽视防御万分比
		-- nid.mPlayDrop = tt[91]    --人物爆率万分比提升
		-- nid.mMonsterDrop = tt[92]    --人物爆率万分比提升
		-- nid.mDropProtect = tt[93]    --防爆几率万分比
		-- nid.mMabiProtect = tt[94]    --防止麻痹万分比

		nid.mPlusA={}
		nid.mPlusB={}

		-- if nid.mName and not (nid.mName == "" ) then
		-- 	nid.mName = reNameEquip(nid.mName)
		-- end

		self.mItemDesp[nid.mTypeID]=nid
		self:dispatchEvent({name = Notify.EVENT_NOTIFY_GETITEMDESP,type_id = nid.mTypeID})

	end,

	[NetProtocol.cNotifyItemPlusDespGroup] = function(mMsg)
		local count = mMsg:getValues("i")[1]
		for i=1,count do
			local tt=mMsg:getValues("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")

			local ipd={}

			ipd.mItemPlusDef = tt[1]
			ipd.mItemTypeID = tt[2]
			ipd.mNeedType = tt[3]
			ipd.mNeedParam1 = tt[4]
			ipd.mNeedParam2 = tt[5]
			ipd.mNeedParam3 = tt[6]
			ipd.mNeedParam4 = tt[7]
			ipd.mNeedParam5 = tt[8]

			ipd.mAC = tt[9]
			ipd.mACMax = tt[10]
			ipd.mMAC = tt[11]
			ipd.mMACMax = tt[12]
			ipd.mDC = tt[13]

			ipd.mDCMax = tt[14]
			ipd.mMC = tt[15]
			ipd.mMCMax = tt[16]
			ipd.mSC = tt[17]
			ipd.mSCMax = tt[18]

			ipd.mLuck = tt[19]
			ipd.mCurse = tt[20]
			ipd.mAccuracy = tt[21]
			ipd.mDodge = tt[22]
			ipd.mAntiMagic = tt[23]

			ipd.mAntiPosion = tt[24]
			ipd.mHpRecover = tt[25]
			ipd.mMpRecover = tt[26]
			ipd.mPosionRecover = tt[27]
			ipd.mMabiProb = tt[28]

			ipd.mMabiDura = tt[29]
			ipd.mDixiaoPres = tt[30]
			ipd.mFuyuanCd = tt[31]
			ipd.mFuyuanPres = tt[32]
			ipd.mMaxHP = tt[33]

			ipd.mMaxMP = tt[34]
			ipd.mMaxHPPres = tt[35]
			ipd.mMaxMPPres = tt[36]
			ipd.mHalfBaoji = tt[37]

			local itemdef = self:getItemDefByID(ipd.mItemTypeID)
			if itemdef then
				if ipd.mItemPlusDef > 40000 then
					if not table.keyof(itemdef.mPlusB,ipd) then
						table.insert(itemdef.mPlusB,ipd)
					end
				else
					if not table.keyof(itemdef.mPlusA,ipd) then
						table.insert(itemdef.mPlusA,ipd)
					end
				end
			end
		end
	end,
----------------------------------------------------------------------------人物状态相关
	[NetProtocol.cResUseSkill] = function(mMsg)
		-- result:(1:不可使用技能；3:魔不够)
		local result=mMsg:readInt()
		local skill_type=mMsg:readInt()

		-- --print("=================res skill "..result)
		if MainRole then
			if game.IsLieHuoTypeSkill(skill_type) then
				if result == 9 then
					self.mLiehuoAction = true
					self.mLiehuoType = skill_type

					local curtime = game.getTime()
					local mSkillCD, mPublicCD = game.getSkillCDTime(skill_type)
					self.mPublicCDTime[mPublicCD] = curtime
					self.mSkillCDTime[skill_type] = curtime

					if not game.IsSwitchSkill(skill_type) then
					--	--print("-------------================,Notify.EVENT_SKILL_COOLDOWN")
						self:dispatchEvent({name=Notify.EVENT_SKILL_COOLDOWN,type=skill_type})
					end

				elseif result == 7 and skill_type == self.mLiehuoType then
					self.mLiehuoAction = false
					self.mLiehuoType = 0
				end
			end
			self:dispatchEvent({name = Notify.EVENT_SKILL_CHANGE})
			-- MainRole.showSkillName(skill_type)
			-- if result == 1 then
			-- 	if self.mStartAutoFight and self.mCharacter.mJob == 100 then
			-- 		MainRole._moveToNearAttack = true
			-- 	end
			-- end
			-- MainRole._readyUseSkill = true

		end
		-- self.isWaitingSkill = false
		-- if self.waitMove and not self.isWaitingSkill then --执行等待的寻路
		-- 	--print("I'm going to move to the wait pos 111111111111111111111111111111111111111111111111111111")
		-- 	MainRole.startAutoMoveToMap(self.waitMove.mapName, self.waitMove.mX, self.waitMove.mY, self.waitMove.flag)
		-- 	self.waitMove = nil
		-- end
	end,

	[NetProtocol.cNotifyInjury] = function(mMsg)
		local srcid = mMsg:readUInt()
		local newhp = mMsg:readInt()
		local newpower = mMsg:readInt()
		local change = mMsg:readInt()
		local ttdelay = mMsg:readInt()
		local attacker = mMsg:readUInt()
		local effect_flags = mMsg:readInt()
		local change_power = mMsg:readInt()
		-- local tttime = game.getTime() + ttdelay

		local param = {}
		param.srcid = srcid
		param.hp = newhp
		-- param.mp = mp
		-- param.maxhp = maxhp
		-- param.maxmp = maxmp
		param.power = newpower

		local pGhost = NetCC:getGhostByID(srcid)
		if pGhost then
			local delay = game.getSkipTime() + ttdelay/1000--延时
			pGhost:setNetValue(Const.net_attacked_time,delay)
		end

		if srcid==MainRole.mID then
			self:dispatchEvent({name=Notify.EVENT_SELF_HPMP_CHANGE,param=param})
			MainRole.handleAttacked(attacker)
		end
	end,

	-- [NetProtocol.cNotifyAttackMiss] = function(mMsg)
	-- 	mMsg:readInt()
	-- end,
	-- [NetProtocol.cNotifyMapItemOwner] = function(mMsg)
	-- 	--print(1111111)
	-- 	local srcid = mMsg:readInt()
	-- 	local mMapItemOwner = mMsg:readInt()
	-- 	local mMapItemType = mMsg:readInt()

	-- 	local item = self.mNetGhosts[srcid]
	-- 	if item then
	-- 		item.mMapItemOwner=mMapItemOwner
	-- 		item.mMapItemType=mMapItemType
	-- 		self:dispatchEvent({name=Notify.EVENT_NEAR_LIST})
	-- 	end
	-- end,

	[NetProtocol.cResRelive] = function (mMsg)
		local src_id = mMsg:readInt()
		--print("relive-----------------------src_id",src_id)
		if MainRole and MainRole.mID == src_id then
			self:dispatchEvent({name = Notify.EVENT_PLAYER_RELIVE, srcId = src_id})
		end
	end,

	[NetProtocol.cNotifyDie] = function(mMsg)
		local srcid = mMsg:readUInt()
		local ttdelay = mMsg:readInt()

		-- if self.mNetGhosts[srcid]~=nil then
		-- 	self.mNetGhosts[srcid].mNextHp=0
		-- 	self.mNetGhosts[srcid].mDead = true
		-- --print("die-------------------",MainRole._mainAvatar.mX,MainRole._mainAvatar)
		if type(MainRole._mainAvatar)=="table" then
			for k,v in pairs(MainRole._mainAvatar) do
				-- --print("_mainAvatar",k,v)
			end
		end
	end,

	[NetProtocol.cNotifyFindRoadGotoNotify] = function(mMsg)
		local map_name = mMsg:readString()
		local mx = mMsg:readInt()
		local my = mMsg:readInt()
		local target = mMsg:readString()
		local flag = mMsg:readInt()
		MainRole._mainAvatar = MainRole._mainAvatar or CCGhostManager:getMainAvatar()

		if target ~= "" then
			MainRole._targetNPCName = target
		end
		-- if not game.checkMainTaskPaused() then
			-- if not self.isWaitingSkill then
				----print("MainRole.startAutoMoveToMap",map_name,mx,my,flag)
				if MainRole.startAutoMoveToMap then
					MainRole.startAutoMoveToMap(map_name,mx,my,flag)
				end
				-- self.m_AutoMovePos = cc.p(mx,my)
				-- self.m_AutoMoveFlag = flag -- 9表示 藏宝图寻路
				-- self:dispatchEvent({name = Notify.EVENT_FLY_PARAM, mapid = map_name, x = mx, y = my, visible = true})--小飞鞋提示
			-- else
			-- 	self.waitMove = {
			-- 		mapName = map_name,
			-- 		mX = mx,
			-- 		mY = my,
			-- 		flag = flag,
			-- 	}
			-- end
		-- end
		-- self:dispatchEvent({name=Notify.EVENT_FLYBOOT_SHOW})
	end,
----------------------------------------------------------------------------
	-- [NetProtocol.cNotifyPlayerAddInfo] = function(mMsg)
	-- 	local id = mMsg:readUInt()
	-- 	local level = mMsg:readInt()
	-- 	local ghostJob = mMsg:readInt()
	-- 	local ghostGender = mMsg:readInt()
	-- 	local maxHp = mMsg:readInt()
	-- 	local hp = mMsg:readInt()
	-- 	if self.mNetGhosts[id]~=nil then
	-- 		self.mNetGhosts[id].mLevel = level
	-- 		self.mNetGhosts[id].mJob = ghostJob
	-- 		self.mNetGhosts[id].mGender = ghostGender
	-- 		self.mNetGhosts[id].mMaxHp = maxHp

	-- 		if id == self.mCharacter.mID then
	-- 			self.mCharacter.mJob = ghostJob
	-- 			self.mCharacter.mGender = ghostGender
	-- 		end

	-- 		if id == NetClient.mLastAimGhost then
	-- 			if MainRole then
	-- 				MainRole:changeTheAim(id)
	-- 			end
	-- 		end
	-- 	end
	-- end,

--------------------------------------------------------------------------

	[NetProtocol.cNotifyTeamInfo] = function(mMsg)
		local srcId = mMsg:readInt()
		local team_id = mMsg:readInt()
		local team_name = mMsg:readString()
		-- local netghost = self.mNetGhosts[id]
		-- if netghost then
		-- 	netghost.mTeamID = team_id
		-- 	netghost.mTeamName = team_name
		-- 	-- netghost.cmdRefreshName = true
		-- 	-- game.GhostManager():updateSomeOneName(id)
		-- end

		local pGhost = CCGhostManager:getPixesGhostByID(srcId)
		if pGhost then
			pGhost:updateName(true)
		end
		--print("cNotifyTeamInfo-------------",srcId,team_id,team_name)
	end,
	[NetProtocol.cResFriendApply] = function( mMsg )
		local friendName = mMsg:readString()
		if not self.tipsMsg["tip_friend"] then self.tipsMsg["tip_friend"] = {} end
		local exist = false
		for i,v in ipairs(self.tipsMsg["tip_friend"]) do
			if v.name == friendName then
				exist = true
			end
		end
		local friend = self:getPlayerInfo(friendName)
		if friend and _G["G_ShieldAddFriend"] == 0 then
			if not exist then
				table.insert(self.tipsMsg["tip_friend"],1,friend)
			end
			self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_friend"})
		end

		-- self:dispatchEvent({name=Notify.EVENT_SHOW_TIPS,str = "addFriend",pName = name})
	end,
	[NetProtocol.cResFriendChange] = function(mMsg)

		local name = mMsg:readString()
		local title = mMsg:readInt()
		title = title%1000
		local online_state = mMsg:readInt()--0不在线，1在线，2表示不在线，不知是好友还是陌生人不改变friend基本信息
		local job = mMsg:readInt()
		local gender = mMsg:readInt()
		local level = mMsg:readInt()
		local guild = mMsg:readString()
		self.mFriends = self.mFriends or {}

		if title>0 and online_state<2 then
			self.mFriends[name] = self.mFriends[name] or {}
			self.mFriends[name].name = name
			self.mFriends[name].title = title
			self.mFriends[name].online_state = online_state
			self.mFriends[name].gender = gender
			self.mFriends[name].job = job
			self.mFriends[name].level = level
			self.mFriends[name].guild = guild
		else--陌生人或者好友下线
			if self.mFriends[name] then
				self.mFriends[name].title = title--删除好友需要改变title，不改变基本信息
				self.mFriends[name].online_state = online_state == 2 and 0 or online_state
			end
		end
		for k,v in pairs(self.chatRecent) do
			if v.name == name then
				self.chatRecent[k].online_state = online_state == 2 and 0 or online_state
				self:dispatchEvent({name = Notify.EVENT_CHAT_RECENT,str="private"})
				break
			end
		end
		if title == 102 then
			self:removeChatRecentPlayer(name)
		end
		self:dispatchEvent({name=Notify.EVENT_FRIEND_FRESH})
	end,

	[NetProtocol.cResFriendFresh] = function(mMsg)
		self:dispatchEvent({name=Notify.EVENT_FRIEND_FRESH, action="fresh"})
	end,

	[NetProtocol.cNotifyBlackBoard] = function(mMsg)
		self.mBlackBoardFlags = mMsg:readInt()
		self.mBlackBoardTitle = mMsg:readString()
		self.mBlackBoardMsg = mMsg:readString()
		self:dispatchEvent({name=Notify.EVENT_LABEL_ZC})
	end,

	[NetProtocol.cNotifyAlert] = function(mMsg)

		local param={}
		local firstInQueue = nil
		param.lv = mMsg:readInt()
		param.flags = mMsg:readInt()
		param.msg = mMsg:readString()
		if self.mTradeInfo.mTradeResult == 1 and param.msg=="交易取消" then
			return
		end

		if param.flags % 10 == 1 then
			firstInQueue = true
		end

		if param.flags == 2 then
			local ret = util.decode(param.msg)
			param.msg = ret.notice
		end
		if param.lv%10 == 1 then--在中间部位从下方移动到屏幕中间
			self:alertLocalMsg(param.msg,"alert",nil, firstInQueue)
		end
		if math.floor(param.lv%1000 / 100) == 1 then -- 头顶上方提示
			self:alertLocalMsg(param.msg,"mid",nil, firstInQueue)
		end

		if math.floor(param.lv%10000 / 1000) == 1 then -- 人脚下提示
			self:alertLocalMsg(param.msg,"bottom",nil, firstInQueue)
		end

		if math.floor(param.lv%100000 / 10000) == 1 then -- 走马灯
			self:alertLocalMsg(param.msg,"post",nil, firstInQueue)
		end

		if math.floor(param.lv%1000000 / 100000) == 1 then -- 收益类型
			local msg = param.msg
			local award = "right"
			if not util.decode(param.msg) then
				-- if string.find(param.msg,"获得内功") then
				-- 	award = "centerInnerPower"
				-- end
				msg = util.encode({
						[1] = {param.msg, "30FF00"},
					})
			end
			self:alertLocalMsg(msg,award,nil, firstInQueue)
		end

		if math.floor(param.lv%100 / 10) == 1 then
			local channel = "system"
			local chatmsg,num = string.gsub(param.msg,"^%b[]",function(p)
				channel = string.sub(p,2,-2)
				return ""
			end)
			local netChat = {}
			if channel == "system" then
				netChat.m_strType = Const.str_chat_system--"【系统】"
			elseif channel =="world" then
				netChat.m_strType = Const.str_chat_world
			elseif channel =="guild" then
				netChat.m_strType = Const.str_chat_guild
			elseif channel =="group" then
				netChat.m_strType = Const.str_chat_group
			elseif channel =="near" then
				netChat.m_strType = Const.str_chat_near
			elseif channel =="private" then
				netChat.m_strType = Const.str_chat_private
			end
			-- netChat.m_strName = Const.str_channel_system--需要就加，不需要就空值
			netChat.m_uSrcId = 0
			netChat.m_strMsg = chatmsg--string.gsub(param.msg,"^%b[]","")
			self:addToMsgHistory(netChat)
		end
	end,

	[NetProtocol.cNotifyLableInfo] = function(mMsg)
		local param={}
		param.id = mMsg:readInt()
		param.info = mMsg:readString()
	end,

	[NetProtocol.cNotifyFreeDirectFly] = function(mMsg)
		local param = mMsg:readInt()
    end,

	[NetProtocol.cNotifySlaveState] = function(mMsg)
		self.mSlaveState = mMsg:readInt()
    end,

	[NetProtocol.cNotifyTaskChange] = function(mMsg)
		local param={}
		param.mTaskID = mMsg:readInt()
		param.mFlags = mMsg:readInt()
		param.mState = mMsg:readInt()
		param.mParam_1 = mMsg:readShort()
		param.mParam_2 = mMsg:readShort()
		param.mParam_3 = mMsg:readShort()
		param.mParam_4 = mMsg:readInt()
		param.mName = mMsg:readString()
		param.mShortDesp = mMsg:readString()

		self.mTasks[param.mTaskID]=nil
		param.mInfo=util.decode(param.mShortDesp)
		self.mTasks[param.mTaskID]=param
		if param.mTaskID >=3000 and param.mTaskID<=3010 and param.mParam_2 ==1 then
			self.mTasks.lastFBId = param.mTaskID
		end
		if param.mTaskID == 1000 then
			self.mTaskTargetMon = nil
			self.mTaskTargetMap = nil
			if param.mInfo and param.mInfo.target_type == "mon" and param.mInfo.target_name ~= "任意怪物" then
				self.mTaskTargetMon = param.mInfo.target_name
				self.mTaskTargetMap = param.mInfo.target_map
			end
		end

		self:dispatchEvent({name=Notify.EVENT_TASK_CHANGE,cur_id = param.mTaskID})
	end,

	[NetProtocol.cNotifySkillDesp] = function(mMsg)

		local nsd={}
		nsd.skill_id = mMsg:readInt()
		nsd.mName= mMsg:readString()
		nsd.mDesp= mMsg:readString()
		nsd.mIconID = mMsg:readInt()
		nsd.mLevel = mMsg:readInt()
		nsd.mLevelMax = mMsg:readInt()
		nsd.mShortcut = mMsg:readInt()
		nsd.mEffectType = mMsg:readInt()
		nsd.mEffectResID = mMsg:readInt()
		nsd.mBaseSpell = mMsg:readInt()
		nsd.mSpell = mMsg:readInt()
		nsd.mConsumeMp = mMsg:readInt()
		nsd.mUseRange =mMsg:readInt()
		nsd.mMinDis = mMsg:readInt()
		nsd.mMaxDis = mMsg:readInt()
		nsd.mSoundID = mMsg:readInt()

		-- nsd.mNeedL1= mMsg:readInt()
		-- nsd.mL1Train= mMsg:readInt()
		-- nsd.mNeedL2= mMsg:readInt()
		-- nsd.mL2Train= mMsg:readInt()
		-- nsd.mNeedL3= mMsg:readInt()
		-- nsd.mL3Train= mMsg:readInt()
		nsd.mIsShow = mMsg:readInt()
		nsd.mCastWay = mMsg:readInt()
		nsd.mSeletWay = mMsg:readInt()
		nsd.mSKillCD = mMsg:readInt()
		nsd.mPublicCD = mMsg:readInt()
		nsd.mOrderID = mMsg:readInt()
		nsd.mNeedLevel = mMsg:readInt()
		nsd.mNeedExp = mMsg:readInt()

		nsd.mDamageDesp = mMsg:readString()
		nsd.mRangeDesp = mMsg:readString()
		nsd.mCDDesp = mMsg:readString()
		nsd.mExtEffectDesp = mMsg:readString()

		nsd.mDamageDespNext = mMsg:readString()
		nsd.mRangeDespNext = mMsg:readString()
		nsd.mCDDespNext = mMsg:readString()
		nsd.mExtEffectDespNext = mMsg:readString()
		nsd.mDamageEffect = mMsg:readInt()

		if not self.mSkillCDTime[nsd.skill_id] then
			self.mSkillCDTime[nsd.skill_id] = 0
		end

		if not self.mPublicCDTime[nsd.mPublicCD] then
			self.mPublicCDTime[nsd.mPublicCD] = 0
		end

		for i=1,#self.m_skillsDesp do
			if self.m_skillsDesp[i].skill_id == nsd.skill_id then
				self.m_skillsDesp[i] = nsd
				return
			end
		end
		table.insert(self.m_skillsDesp,nsd)
	end,

	[NetProtocol.cNotifySkillChange] = function(mMsg)
		--var skill_type:int = -1
		local skill_temp = {}
		skill_temp.mTypeID = mMsg:readInt()
		skill_temp.mLevel = mMsg:readInt()
		skill_temp.mExp = mMsg:readInt()
		skill_temp.mParam1 = mMsg:readInt()
		-- if skill_temp.mTypeID == Const.SKILL_TYPE_Jump then
		-- 	return
		-- end
		-- if not self.m_netSkill[skill_temp.mTypeID] then
		-- 	if not game.IsPassiveSkill(skill_temp.mTypeID) then
		-- 		table.insert(self.m_skillAddList,skill_temp.mTypeID)
		-- 		-- self:dispatchEvent({name=Notify.EVENT_SKILL_CHANGE})
		-- 	end
		-- end

		if skill_temp.mLevel == 0 then
			for i=1,#self.m_skillsDesp do
				if self.m_skillsDesp[i].skill_id == skill_temp.mTypeID then
					self.m_skillsDesp[i] = nil
					local keyindex = table.keyof(self.m_skillAddList,skill_temp.mTypeID)
					if keyindex then
						table.remove(self.m_skillAddList,keyindex)
						self:dispatchEvent({name=Notify.EVENT_SKILL_CHANGE,remove_id = skill_temp.mTypeID})
						self:checkSkillRedPoint(skill_temp)
						return
					end
				end
			end
		end
		local needUpdate
		local passiveSkill = {102,103,412,513,614}---被动技能
		if not self.m_netSkill[skill_temp.mTypeID] then
			needUpdate = true
		end
		-- if not self.m_netSkill[skill_temp.mTypeID] and not table.indexof(passiveSkill, skill_temp.mTypeID) then
		-- 	needUpdate = true
		-- end

		local skillLevelUp = false
		if self.m_netSkill[skill_temp.mTypeID] and skill_temp.mLevel > self.m_netSkill[skill_temp.mTypeID].mLevel then
			skillLevelUp = true
		end

		self.m_netSkill[skill_temp.mTypeID] = skill_temp
		if skill_temp.mTypeID == Const.SKILL_TYPE_BanYueWanDao then
			self.m_bBanYueOn = (skill_temp.mParam1 > 0) and true or false
			self:dispatchEvent({name=Notify.EVENT_SKILL_STATE, skill_type = skill_temp.mTypeID})
		elseif skill_temp.mTypeID == Const.SKILL_TYPE_CiShaJianShu then
			self.m_bCiShaOn = (skill_temp.mParam1 > 0) and true or false
			self:dispatchEvent({name=Notify.EVENT_SKILL_STATE, skill_type = skill_temp.mTypeID})
		elseif game.IsLieHuoTypeSkill(skill_temp.mTypeID) then
			if skill_temp.mParam1 == 0 and skill_temp.mTypeID == self.mLiehuoType then
				self.mLiehuoAction = false
				self.mLiehuoType = 0
			end
		end


		if needUpdate then
			-- local mainAvatar = CCGhostManager:getMainAvatar()
			-- MainRole._mainAvatar = MainRole._mainAvatar or CCGhostManager:getMainAvatar()
			-- if MainRole._mainAvatar then MainRole._mainAvatar:clearAutoMove() end
			local nsd = game.getSkillDesp(skill_temp.mTypeID)
			local param = {
				name = Notify.EVENT_SHOW_TIPS,
				str = "newSkill",
				skillId = skill_temp.mTypeID,
				skillName = nsd.mName,
			}
			-- --print("")
			self:dispatchEvent(param)

			MainRole.stopAutoFight()
			game.isNewSkill = true
			-- self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str = "panel_generaltips",skillId=skill_temp.mTypeID})
		end
		-- if needUpdate then self:dispatchEvent({name=Notify.EVENT_SKILL_CHANGE, add_id = skill_temp.mTypeID}) end
		if skillLevelUp then
			self:dispatchEvent({name = Notify.EVENT_SKILL_LEVEL_UP, skill_type=skill_temp.mTypeID})
		end

		self:checkSkillRedPoint(skill_temp)
	end,

	[NetProtocol.cNotifyStatusDef] = function(mMsg)
		local status_id = mMsg:readInt()
		local num = mMsg:readInt()
		for i=1,num do
			local sd={}
			sd.mStatusID = status_id
			sd.mLv = mMsg:readInt()
			sd.mIcon = mMsg:readInt()
			sd.mAC = mMsg:readInt()
			sd.mACmax = mMsg:readInt()
			sd.mMAC = mMsg:readInt()
			sd.mMACmax = mMsg:readInt()
			sd.mDC = mMsg:readInt()
			sd.mDCmax = mMsg:readInt()
			sd.mMC = mMsg:readInt()
			sd.mMCmax = mMsg:readInt()
			sd.mSC = mMsg:readInt()
			sd.mSCmax = mMsg:readInt()
			sd.mHPmax = mMsg:readInt()
			sd.mMPmax = mMsg:readInt()
			sd.mNodef = mMsg:readInt()
			sd.mFightPoint = mMsg:readInt()
			sd.baoji = mMsg:readInt()
			sd.baoprob = mMsg:readInt()
			sd.mName = mMsg:readString()
			self.mStatusDesp[sd.mStatusID*100+sd.mLv] = sd
		end
	end,

	-- [NetProtocol.cNotifyBuffDesp] = function(mMsg)
	-- 	local bd = {}
	-- 	bd.id = mMsg:readInt()
	-- 	bd.name = mMsg:readString()
	-- 	bd.icon = mMsg:readString()
	-- 	bd.ui = mMsg:readInt()
	-- 	bd.uiSort = mMsg:readInt()
	-- 	bd.mType = mMsg:readInt()
	-- 	bd.level = mMsg:readInt()
	-- 	bd.desp = mMsg:readString()
	-- 	bd.effType= mMsg:readInt()
	-- 	bd.effres= mMsg:readInt()
	-- 	bd.validTimeMax = mMsg:readInt()
	-- 	self.mBuffDef[bd.id] = bd
	-- 	-- for k,v in pairs(bd) do
	-- 	-- 	--print("buffDef----------------------",k,v)
	-- 	-- end
	-- end,

--以下麻痹提示
	[NetProtocol.cNotifyStatusChange] = function(mMsg)
		--[[
		local msg = {
			[1] = {"bbbbbbbbbbbbbb", "30FF00"}, --aE为标识
		}
		self:alertLocalMsg(util.encode(msg),"right")
		self:alertLocalMsg("111111111111111111111111bbbb", "alert")
		util.showAlert("","名称中包含非法字符","确定")
		]]
		local srcId = mMsg:readInt()
		local buffId = mMsg:readShort()
		local status_param = mMsg:readInt()
		local timeRemain = mMsg:readDouble()
		local gap = mMsg:readInt()
		
		if srcId == MainRole.mID and buffId==20 then
			if timeRemain>0 then
				--self.mMabiFlag = true
				self:alertLocalMsg("您已被麻痹,无法移动!!!！", "alert")
				--self.actionMoving = false--动作移动
				--MainRole._moveToNearAttack = false--近战攻击
				--MainRole._autoMoving = false--自动移动
				--MainRole._readyKeepAttack = false--准备继续攻击
			else
				self.mMabiFlag = false
				--self.actionMoving = true--动作移动
				--MainRole._autoMoving = true--自动移动
				self:alertLocalMsg("麻痹失效,恢复移动!!!！", "alert")
			end
		end
		if srcId == MainRole.mID and buffId==21 then
			if timeRemain>0 then
				--self.mMabiFlag = true
				self:alertLocalMsg("您已被冰冻,无法移动!!!", "alert")
				--self.actionMoving = false--动作移动
				--MainRole._moveToNearAttack = false--近战攻击
				--MainRole._autoMoving = false--自动移动
				--MainRole._readyKeepAttack = false--准备继续攻击
			else
				self.mMabiFlag = false
				--self.actionMoving = true--动作移动
				--MainRole._autoMoving = true--自动移动
				self:alertLocalMsg("冰冻失效,恢复移动!!!", "alert")
			end
		end
		
	end,
--以上麻痹提示

	[NetProtocol.cNotifyBuffChange] = function(mMsg)
		local srcId = mMsg:readInt()
		local buffId = mMsg:readInt()
		local opCode = mMsg:readInt()
		local timeRemain = mMsg:readDouble()
		
		self.mNetBuff[srcId] = self.mNetBuff[srcId] or {}
		if opCode == 0 then
			if self.mNetBuff[srcId][buffId] then
				-- local buffdef = self.mNetBuff[srcId][buffId].buffdef
				self.mNetBuff[srcId][buffId] = nil
			end
		elseif opCode == 1 or opCode == 2 then
			self.mNetBuff[srcId] = self.mNetBuff[srcId] or {}
			local buffdef = NetCC:getBuffDef(buffId)
			if buffdef and buffdef.id then
				self.mNetBuff[srcId][buffId] = {
					buffId = buffId,
					timeRemain = timeRemain,
					buffdef = buffdef,
					enable = true,
					starttime = os.time()---(buffdef.timemax/1000-timeRemain),
				}
			end
		elseif opCode == 3 or opCode == 4 then
			if self.mNetBuff[srcId] and self.mNetBuff[srcId][buffId] then
				self.mNetBuff[srcId][buffId].enable = opCode>3  --3是禁用4是启用
			end
		end
		if srcId == MainRole.mID then
			self:dispatchEvent({name = Notify.EVENT_BUFF_CHANGE, srcId = srcId,opCode = opCode})
		end
	end,

	[NetProtocol.cNotifyListBuff] = function(mMsg)
		local srcId = mMsg:readInt()
		local num = mMsg:readInt()
		local buffId,timeRemain
		for i=1,num do
			buffId = mMsg:readInt()
			timeRemain = mMsg:readDouble()
			local buffdef = NetCC:getBuffDef(buffId)
			if buffdef and buffdef.id then
				self.mNetBuff[srcId] = self.mNetBuff[srcId] or {}
				self.mNetBuff[srcId][buffId] = {
					buffId = buffId,
					timeRemain = timeRemain,
					buffdef = buffdef,
					starttime = os.time()---(buffdef.timemax/1000-timeRemain),
				}
			end
		end
		if srcId == MainRole.mID then
			self:dispatchEvent({name = Notify.EVENT_BUFF_CHANGE, srcId = srcId})
		end
	end,

	-- [NetProtocol.cNotifyPushCocosGui] = function(mMsg)
	-- 	local gui_type = mMsg:readInt()
	-- 	local gui_name = mMsg:readString()
	-- 	local gui_state = mMsg:readInt()
	-- end,

	[NetProtocol.cNotifyProsperityChange] = function(mMsg)
		local mProsperity = mMsg:readInt()
		local mProsperityNext = mMsg:readInt()
	end,

	[NetProtocol.cNotifyMiniMapConn] = function(mMsg)

		local num = mMsg:readInt()
		for i=1,num do
			local from = mMsg:readString()
			local to = mMsg:readString()
			if self.mMiniMapConn[from] == nil then
				local mapConn = {}
				table.insert(mapConn,to)
				self.mMiniMapConn[from] = mapConn
			else
				table.insert(self.mMiniMapConn[from],to)
			end
		end
	end,

	[NetProtocol.cNotifyWarInfo] = function(mMsg)
		self.mWarState = mMsg:readInt()
		self.mKingGuild = mMsg:readString()
		self.mKingOfKings = mMsg:readString()
		CCGhostManager:updatePlayerName()
	end,

	[NetProtocol.cNotifyGuildCondition] = function(mMsg)
		local mGuildCondition = mMsg:readString()
	end,

	[NetProtocol.cNotifySlotAdd] = function(mMsg)
		--print("cNotifySloatAdd")
		local lastBag = self.mBagSlotAdd
		local lastDepot = self.mDepotSlotAdd
		self.mDepotSlotAdd = mMsg:readInt()
		self.mBagSlotAdd = mMsg:readInt()
		self.mBagMaxSlot = mMsg:readInt()
		self.mBagSlotAdd = 0
		local dispath = false
		if lastBag < self.mBagSlotAdd then
			for i=(self.mBagSlotAdd-5),self.mBagSlotAdd-1 do
				self:dispatchEvent({name=Notify.EVENT_ITEM_CHANGE,pos=Const.ITEM_BAG_SIZE+i})
			end
			dispath = true
		end
		if lastDepot < self.mDepotSlotAdd then
			for i=(self.mDepotSlotAdd-5),self.mDepotSlotAdd do
				self:dispatchEvent({name=Notify.EVENT_ITEM_CHANGE,pos=Const.ITEM_DEPOT_SIZE+1000+i})
			end
			dispath = true
		end
		if dispath == true then
			self:dispatchEvent({name=Notify.EVENT_SOLT_CHANGE})
		end
	end,

	[NetProtocol.cNotifyAttributeChange] = function(mMsg)
	--local tt=mMsg:getValues("iiiiiiiiiiiiiiiiiiiiiiiliiiiiii")
	local tt=mMsg:getValues("iiiiiiiiiiiiiiiiiiiiiiiliiiiiiiii")--kinyz新增通信两个i
		-- local tt=mMsg:getValues("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
		-- local itemdef = NetClient:getItemDefByID(typeid)

		if self.mCharacter.mMaxHp and self.mCharacter.mMAC  then
			local diff = {
				[1]  = {char = "mHp:",			value = tt[1 ] - self.mCharacter.mMaxHp,},
				[2]  = {char = "mAC:",			value = tt[10] - self.mCharacter.mAC, 			value2 = tt[9] - self.mCharacter.mMaxAC},
				[3]  = {char = "mMAC:",			value = tt[12] - self.mCharacter.mMAC,			value2 = tt[11] - self.mCharacter.mMaxMAC},
				[4]  = {char = "mDC:",			value = tt[14] - self.mCharacter.mDC, 			value2 = tt[13] - self.mCharacter.mMaxDC},
				[5]  = {char = "mMC:",			value = tt[16] - self.mCharacter.mMC, 			value2 = tt[15] - self.mCharacter.mMaxMC},
				[6]  = {char = "mSC:",			value = tt[18] - self.mCharacter.mSC, 			value2 = tt[17] - self.mCharacter.mMaxSC},
				[7]  = {char = "critPoint:",	value = tt[29] - self.mCharacter.critPoint,},
				[8]  = {char = "critProb:",		value = tt[28] - self.mCharacter.critProb,},
				[9]  = {char = "mLuck:",		value = tt[25] - self.mCharacter.mLuck,},
				-- [10] = {char = "mDodge:",		value = tt[20] - self.mCharacter.mDodge,},--mxwx 暂时注销了是为开启无敌闪避不显示，可以在funcParam重新做一个新的闪避来用于无敌，或者在物品库做个几率
				[10] = {char = "mAccuracy:",	value = tt[19] - self.mCharacter.mAccuracy,},
				[11] = {char = "tenacity:",		value = tt[30] - self.mCharacter.tenacity,},
				[12] = {char = "holyDam:",		value = tt[31] - self.mCharacter.holyDam,},
			}
			-- local itemdef = self:getItemDefByID(typeid)
			if not self.msgMid then--mxwx
				self.msgMid = {}
			else
			-- if itemdef.mColor == 0 then
			-- if self.mCharacter.mColor==0 then
				util.handleAttrChange(diff)
			-- end
			end
		end
		self.levelChanged = false


		self.mCharacter.mMaxHp			= tt[1]
		self.mCharacter.mMaxMp			= tt[2]
		self.mCharacter.mMaxBurden		= tt[3]
		self.mCharacter.mBurden			= tt[4]
		self.mCharacter.mMaxLoad		= tt[5]

		self.mCharacter.mLoad			= tt[6]
		self.mCharacter.mMaxBrawn		= tt[7]
		self.mCharacter.mBrawn			= tt[8]
		self.mCharacter.mMaxAC			= tt[9]
		self.mCharacter.mAC				= tt[10]

		self.mCharacter.mMaxMAC			= tt[11]
		self.mCharacter.mMAC			= tt[12]
		self.mCharacter.mMaxDC			= tt[13]
		self.mCharacter.mDC				= tt[14]
		self.mCharacter.mMaxMC			= tt[15]

		self.mCharacter.mMC				= tt[16]
		self.mCharacter.mMaxSC			= tt[17]
		self.mCharacter.mSC				= tt[18]
		self.mCharacter.mAccuracy		= tt[19]
		self.mCharacter.mDodge			= tt[20]

		self.mCharacter.mDropProb		= tt[21]
		self.mCharacter.mDoubleAttProb	= tt[22]
		self.mCharacter.mTotalUpdLevel	= tt[23]
		self.mCharacter.mFightPoint		= tt[24]
		self.mCharacter.mLuck			= tt[25]

		self.mCharacter.mHonor			= tt[26]
		self.mCharacter.mXishou			= tt[27]

		self.mCharacter.critProb		= tt[28]--暴击几率
		self.mCharacter.critPoint		= tt[29]--暴击伤害
		self.mCharacter.tenacity		= tt[30]--韧性
		self.mCharacter.holyDam		= tt[31]--神圣

		self.mCharacter.step_effid		= tt[32]--kinyz脚印
		self.mCharacter.guanghuanid		= tt[33]--kinyz光环
		-- --print("光环脚印检测----------------")
		-- --print(self.mCharacter.step_effid,self.mCharacter.guanghuanid)

		-- self:dispatchEvent({name=Notify.EVENT_POWER_CHANGE})
		self:dispatchEvent({name=Notify.EVENT_ATTRIBUTE_CHANGE})
		self:dispatchEvent({name=Notify.EVENT_POWER_CHANGE})
	end,

	-- [NetProtocol.cNotifyNameAdd] = function(mMsg)
	-- 	local srcid = mMsg:readUInt()
	-- 	local namepre = mMsg:readString()
	-- 	local namepro = mMsg:readString()
	-- 	local netghost = self.mNetGhosts[srcid]
	-- 	if netghost then
	-- 		netghost.mNamePre = namepre
	-- 		netghost.mNamePro = namepro
	-- 		-- netghost.cmdRefreshName = true
	-- 		game.GhostManager():updateSomeOneName(srcid)
	-- 	end
	-- end,

	[NetProtocol.cNotifyExpChange] = function(mMsg)
		self.mCharacter.mCurExperience = mMsg:readDouble()
		self.mCharacter.mCurrentLevelMaxExp = mMsg:readDouble()
		self.mCharacter.ExperienceChangeValue = mMsg:readInt()
		if self.mCharacter.ExperienceChangeValue > 0 then
			local msg = {
				[1] = {"获得经验:"..self.mCharacter.ExperienceChangeValue, "30FF00"}, --aE为标识
			}
			self:alertLocalMsg(util.encode(msg),"right")
		end
		self:dispatchEvent({name=Notify.EVENT_EXP_CHANGE})
	end,

	[NetProtocol.cNotifyLoadShortcut] = function(mMsg)
		local param = {}
		local num = mMsg:readInt()
		for i=1,num do
			local shortCut = {}
			shortCut.cut_id = mMsg:readInt()
			shortCut.type = mMsg:readInt()
			shortCut.param = mMsg:readInt()
			shortCut.itemnum = 1
			self.mShortCut[shortCut.cut_id] = shortCut
			-- --print("cNotifyLoadShortcut==99999999999999999999999", shortCut.cut_id, shortCut.type, shortCut.param, shortCut.itemnum)
		end
		-- cut_id 序号，type 类型 1 (物品) 2(技能)，param 物品id 或者 技能id， itemnum 默认为1
		-- 总长度为16 前8 分配给技能，9-12分配给物品 13-16待定
		-- --print("cNotifyLoadShortcut cNotifyLoadShortcut cNotifyLoadShortcut cNotifyLoadShortcut", num, util.encode(self.mShortCut))
		self:dispatchEvent({name = Notify.EVENT_SET_SHORTCUT})
	end,

	[NetProtocol.cNotifyFreeReliveLevel] = function(mMsg)
		local mFreeReliveLevel = mMsg:readInt()
	end,

	[NetProtocol.cNotifyLevelChange] = function(mMsg)
		self.levelChanged = true
		local level = mMsg:readInt()
		--PlatformTool.callPlatformFunc({func="setPlayerLevel", level=level})
		local netGhost = NetCC:getMainGhost()
		if netGhost then
			netGhost:setNetValue(Const.net_level, level)
			if  self.mCharacter.mLevel ~= level then
				self.mCharacter.mLevel = level
				game.level = self.mCharacter.mLevel
				self.m_bLevelChanged = true
				if PlatformTool then
					PlatformTool.doSubmitExtendData(PlatformTool.TYPE_LEVEL_UP)
				end
			end
			self:dispatchEvent({name = Notify.EVENT_LEVEL_CHANGE, level = level})
		end

		if game.GetMainRole() and (PLATFORM_360 or PLATFORM_UC or PLATFORM_LINYOU) then

		end
	end,

	[NetProtocol.cNotifyMapMiniNpc] = function(mMsg)
		local nmmn={}
		nmmn.mMapID = mMsg:readString()
		nmmn.mNpcName = mMsg:readString()
		nmmn.mNpcShortName = mMsg:readString()
		nmmn.mX = mMsg:readInt()
		nmmn.mY = mMsg:readInt()
		nmmn.mDirectFlyID = mMsg:readInt()
		nmmn.mShowNpcFlag = mMsg:readInt()
		nmmn.mNum = mMsg:readInt()

		if self.mNetMap.mMapID==nmmn.mMapID then
			local isExit = false
			for i=1,#self.mMiniNpc do
				if self.mMiniNpc[i].mNpcName == nmmn.mNpcName then
					self.mMiniNpc[i] = nmmn
					isExit = true
				end
			end
			if not isExit then
				table.insert(self.mMiniNpc,nmmn)
			end
		end
	end,

	[NetProtocol.cNotifyURL] = function(mMsg)
		local mRegURL = mMsg:readString()
		local mLoginURL = mMsg:readString()
		local mPayURL = mMsg:readString()
		local mWebhomeURL = mMsg:readString()
		local mBBSURL = mMsg:readString()
		local mDownloadURL = mMsg:readString()
		local mKefuURL = mMsg:readString()
		local mParamURL1 = mMsg:readString()
		local mParamURL2 = mMsg:readString()
		local mParamURL3 = mMsg:readString()
		local mParamURL4 = mMsg:readString()
		local mParamURL5 = mMsg:readString()
	end,

	[NetProtocol.cNotifyCapacityChange] = function(mMsg)
		local mCapacity = mMsg:readInt()
		local capacity = mMsg:readInt()
	end,

	[NetProtocol.cNotifyHPMPChange] = function(mMsg)

		local srcid = mMsg:readUInt()
		local hp = mMsg:readInt64()
		local mp = mMsg:readInt64()
		local maxhp = mMsg:readInt()
		local maxmp = mMsg:readInt()
		if hp<=0 then hp=0 end
		if mp<=0 then mp=0 end

		local param = {}
		param.srcid = srcid
		param.hp = hp
		param.mp = mp
		param.maxhp = maxhp
		param.maxmp = maxmp

		-- if self.mNetGhosts[srcid]~=nil then
		-- 	self.mNetGhosts[srcid].mHp=hp
		-- 	self.mNetGhosts[srcid].mMp=mp
		-- 	self.mNetGhosts[srcid].mMaxHp=maxhp
		-- 	self.mNetGhosts[srcid].mMaxmp=maxmp
		-- end
		-- MainRole.addGhostEffect(srcid,990012,"relive")
		if srcid==MainRole.mID then
			self:dispatchEvent({name=Notify.EVENT_SELF_HPMP_CHANGE,param=param})
		end
	end,

	[NetProtocol.cNotifyParamData] = function(mMsg)
		local srcid = mMsg:readInt()
		local id = mMsg:readInt()
		local desp = mMsg:readString()

		if not self.mParam[srcid] then
			self.mParam[srcid]={}
		end

		self.mParam[srcid][id]=desp
		-- --print("cNotifyParamData------------------",srcid,id,desp)
	end,

	[NetProtocol.cNotifyParamDataLsit] = function(mMsg)
		local srcid = mMsg:readInt()
		local num = mMsg:readInt()

		if not self.mParam[srcid] then
			self.mParam[srcid]={}
		end

		for i=1,num do
			local id = mMsg:readInt()
			local desp = mMsg:readString()
			self.mParam[srcid][id]=desp
		end
	end,

	[NetProtocol.cNotifyOfflineExpInfo] = function(mMsg)
		local mOfflineTime = mMsg:readInt()
		local mOfflineTimeValide = mMsg:readInt()
		local mOfflineTimeValideMax = mMsg:readInt()
		local mOfflineExp = mMsg:readInt()
		local mOfflinePrice1 = mMsg:readInt()
		local mOfflinePrice2 = mMsg:readInt()
		local mOfflinePrice4 = mMsg:readInt()

	end,

	[NetProtocol.cNotifySetModel] = function(mMsg)
		local src_id = mMsg:readUInt()
		local id = mMsg:readInt()
		local model = mMsg:readInt()

		self.mModels[src_id] = self.mModels[src_id] or {}
		self.mModels[src_id][id] = model
		self:dispatchEvent({name=Notify.EVENT_MODEL_SET,modelId = id})
		-- self.other_panel_save="saved"
		if id==5 then -- vip
			show_player_vip(src_id)
		end
		-- local mainAvatar = CCGhostManager:getMainAvatar()
		-- MainRole._mainAvatar = MainRole._mainAvatar or CCGhostManager:getMainAvatar()
		if MainRole._mainAvatar and  MainRole._mainAvatar:NetAttr(Const.net_id) == src_id and id == 7 and model > 0 then
			self:dispatchEvent({name = Notify.EVENT_HANDLE_FLOATING , btn = "main_mount" , visible = true})
		end
	end,

	-- [NetProtocol.cNotifyVipChange] = function(mMsg)
	-- 	local mVcoinAccu = mMsg:readInt()
	-- 	local mVipLevel = mMsg:readInt()
	-- end,

	[NetProtocol.cNotifyGameMoneyChange] = function(mMsg)
		self.mCharacter.mGameMoney = mMsg:readDouble()
		self.mCharacter.mGameMoneyBind = mMsg:readDouble()
		self.mCharacter.mVCoin = mMsg:readInt()
		self.mCharacter.mVCoinBind = mMsg:readInt()
		-- self.mCharacter.mVcoings = mMsg:readDouble()
		local param = {}
		param.gm_change = mMsg:readDouble()
		param.vc_change = mMsg:readInt()
		param.gmb_change = mMsg:readDouble()
		param.vcb_change = mMsg:readInt()
		-- PlayAudio.play(Const.SOUND.give_gole_coin)

		-- if param.gm_change ~= 0 then--此物品已经废除
		-- 	self:dispatchChangeAlertMsg("获得金币","失去金币",param.gm_change)
		-- end
		if param.gm_change ~= 0 then
			if param.gm_change > 0 then
				local msg = {
					[1] = {"获得金币:"..param.gm_change, "30FF00"},
				}
				self:alertLocalMsg(util.encode(msg),"right")
			else
				self:dispatchChangeAlertMsg("获得金币:","失去金币:",param.gm_change)
			end
		end
		if param.gmb_change ~= 0 then
			self:dispatchChangeAlertMsg("获得绑定金币:","失去绑定金币:",param.gmb_change)
		end
		if param.vc_change ~= 0 then
			self:dispatchChangeAlertMsg("获得钻石:","失去钻石:",param.vc_change)
		end
		if param.vcb_change ~= 0 then
			self:dispatchChangeAlertMsg("获得元宝:","失去元宝:",param.vcb_change)
		end

		if param.gm_change>0 or param.vc_change>0 or param.gmb_change>0 or param.vcb_change>0 then
			PlayAudio.play("sound/gold.mp3")
		end

		self:dispatchEvent({name=Notify.EVENT_GAME_MONEY_CHANGE})
	end,

	[NetProtocol.cNotifyForceMove] = function(mMsg)
		local srcid = mMsg:readUInt()
		local newX = mMsg:readShort()
		local newY = mMsg:readShort()
		local dir = mMsg:readByte()
		-- MainRole.addGhostEffect(srcid,990013,"entermap")

		-- if MainRole._targetNPCName and MainRole._targetNPCName ~= "" then
		-- 	local pGhost=NetCC:findGhostByName(MainRole._targetNPCName)
		-- 	if pGhost then
		-- 		if pGhost:NetAttr(Const.net_type)==Const.GHOST_MONSTER then
		-- 			MainRole._targetNPCName = ""
		-- 			CCGhostManager:selectSomeOne(pGhost:NetAttr(Const.net_id))
		-- 			MainRole.startAutoFight()
		-- 		end
		-- 	end
		-- end
		if MainRole.mID == srcid then
			MainRole.MoveToContinueTask()
		end
	end,

	[NetProtocol.cNotifyCharacterLoad] = function(mMsg)
		MainRole._mainAvatar = CCGhostManager:getMainAvatar()
	end,

	[NetProtocol.cNotifyMapEnter] = function(mMsg)

		self.mNetMap={}
		self.mMiniNpc = {}
		self.mMapConn = {}

		local tt=mMsg:getValues("ziiiizziii")
		self.mNetMap.mMapID=tt[1]
		self.mNetMap.mMiniMapID=tt[5]
		self.mNetMap.mMapFile=tt[6]
		self.mNetMap.mName=tt[7]

		local wanderdight = tonumber(tt[10])
		game.wanderFight=(wanderdight>0) and true or false
		--print("----------------------cNotifyMapEnter",game.wanderFight,MAIN_IS_IN_GAME)

		if MAIN_IS_IN_GAME then
			self:GameEnterMap()
			PlayAudio.mapMusic(self.mNetMap.mMapID)
			----print("self.mNetMap.mMapID=======",self.mNetMap.mMapID)
		end
	end,

	[NetProtocol.cNotifyMapLeave] = function(mMsg)

		self.mNetMap.mLastMapID = self.mNetMap.mMapID
		self.mNetMap.mMapID = nil
		self.mCharacter.mX = 0
		self.mCharacter.mY = 0

		-- if self.mNetMap.mLastMapID and string.find(self.mNetMap.mLastMapID, "fbgr") then
		-- 	local b = self:checkTaskState(1000)
		-- 	if b == 26 or b == 39 or b == 54 then
		-- 		self.mNeedContinueTask = true
		-- 	end
		-- end
		self:dispatchEvent({name=Notify.EVENT_MAP_LEAVE})
		--活动地图取消小飞鞋
		-- local activityMap = {"v203","v204","v205","v202","v201","v301","chiwooBattle","v219","v220","v221","v222","v223","v224","v225","v226","v227","v228","v229"}
		-- if table.indexof(activityMap, self.mNetMap.mLastMapID) then
		-- 	self:dispatchEvent({name = Notify.EVENT_FLY_PARAM, visible = false})
		-- end
	end,

	[NetProtocol.cNotifyMapOption] = function(mMsg)
		self.loginEnded = true
		local mp ={}
		mp.map_id = mMsg:readString()
		mp.pkprohibit = mMsg:readByte()
		mp.pkallow = mMsg:readByte()
		mp.autoalive = mMsg:readByte()
		mp.nointeract = mMsg:readByte()
		mp.lockaction = mMsg:readByte()
		mp.wanderdight = mMsg:readByte()
		mp.fightstate = mMsg:readByte()
		-- for k,v in pairs(mp) do
		-- 	--print("mp============",k,v)
		-- end
		NetClient.mapOption = NetClient.mapOption or {}
		NetClient.mapOption[mp.map_id] = mp
		game.wanderFight=(mp.wanderdight>0) and true or false

		if MainRole and MainRole._mainAvatar then --进入地图需要检测是否有自动移动的需求
			MainRole.checkAutoMove()
		end
	end,

	[NetProtocol.cNotifyTotalAttrParam] = function(mMsg)
		local num = mMsg:readInt()

		for i=1,num do
			local id = mMsg:readInt()
			self.mCharacter.mTotalAttrs[id] = {}
			self.mCharacter.mTotalAttrs[id].mJob 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mLevel 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mDC   			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mDCmax 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mMC   			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mMCmax 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mSC   			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mSCmax 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mAC   			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mACmax 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mMAC   			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mMACmax 		= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mHPmax 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mMPmax 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mAccuary 		= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mDodge 			= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mLuck	 		= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mDropProb 		= mMsg:readInt()
			self.mCharacter.mTotalAttrs[id].mDoubleAttProb 	= mMsg:readInt()
		end
	end,

	[NetProtocol.cNotifyMapConn] = function(mMsg)

		local nmc={}
		nmc.mMapID = mMsg:readString()
		nmc.mDesMapID = mMsg:readString()
		nmc.mDesMapName = mMsg:readString()
		nmc.mFromX = mMsg:readInt()
		nmc.mFromY = mMsg:readInt()
		nmc.mDesX = mMsg:readInt()
		nmc.mDesY = mMsg:readInt()
		nmc.mSize = mMsg:readInt()

		if self.mNetMap.mMapID==nmc.mMapID then
			self.mMapConn[nmc.mDesMapID] = nmc
		end

	end,

	[NetProtocol.cNotifyNpcShowFlags] = function(mMsg)
		local npc_id = mMsg:readUInt()
		local show_flag = mMsg:readInt()
	end,

	[NetProtocol.cNotifyAvatarChange] = function(mMsg)
		local srcid=mMsg:readUInt()
		local cloth=mMsg:readInt()
		local weapon=mMsg:readInt()
		--local mount=mMsg:readInt()
		local name=mMsg:readString()
		local lovename=mMsg:readString()
		local wing=mMsg:readInt()
		local fabao=mMsg:readInt()
		local fashion=mMsg:readInt()
		----print("=====,",cloth,fashion)
		local zslevel=mMsg:readInt()
		local bemonster=mMsg:readInt()
		local low=mMsg:readByte()
		self:dispatchEvent({name=Notify.EVENT_AVATAR_CHANGE})
	end,
	[NetProtocol.cNotifyPowerChange] = function(mMsg)
		local srcId = mMsg:readInt()
		local power = mMsg:readInt()
		local maxPower = mMsg:readInt()
		-- --print("innerpower_change --------------",srcId,power,maxPower)
		self:dispatchEvent({name=Notify.EVENT_INNERPOWER_CHANGE,srcId = srcId,power = power,maxPower = maxPower})
	end,

	-- [NetProtocol.cNotifyRelive] = function(mMsg)
	-- 	local srcId = mMsg:readInt()
	-- 	local rType = mMsg:readInt()
	-- 	local player = CCGhostManager:getPixesGhostByID(srcId)
	-- 	if player then
	-- 		player:showBloodBar()
	-- 	end
	-- end,

	-- [NetProtocol.cNotifyMapBye] = function(mMsg)
	-- 	local srcId = mMsg:readInt()
	-- 	ghost_map_bye(srcId)
	-- end,

	[NetProtocol.cResChangeAttackMode] = function(mMsg)
		local tempMode = mMsg:readInt()
		local changed = false
		if self.mAttackMode ~= tempMode then
			self.mAttackMode = tempMode
			changed = true
		end
		--print("modeChange---------------------------",self.mAttackMode)
		self:dispatchEvent({name=Notify.EVENT_ATTACKMODE_CHANGE, modeChange = changed})
		-- game.StatusManager().mAllReFreshName = true
		-- game.GhostManager():updateAllName()
	end,

	[NetProtocol.cNotifyCountDown] = function(mMsg)
		self.m_nCountDownDelay = mMsg:readInt()
		self.m_strCountDownMsg = mMsg:readString()
		self:dispatchEvent({name=Notify.EVENT_COUNT_DOWN})
	end,

	-- [NetProtocol.cNotifyPKStateChange] = function(mMsg)
	-- 	local id = mMsg:readUInt()
	-- 	local pkvalue = mMsg:readInt()
	-- 	local pkstate = mMsg:readInt()
	-- 	local netghost = self.mNetGhosts[id]
	-- 	if netghost then
	-- 		netghost.mPKState = pkstate
	-- 		netghost.mPKValue = pkvalue
	-- 		-- netghost.cmdRefreshName = true
	-- 		game.GhostManager():updateSomeOneName(id)
	-- 	end
	-- end,

	[NetProtocol.cNotifyGuildInfo] = function(mMsg)
		local guild_name = mMsg:readString()
		local guild_title = mMsg:readInt()
		local guild_seedid = mMsg:readString()

		local guildChanged = false -- 帮会是否改变，从无到有或者从有到无
		local titleChanged = false -- 帮会职务是否改变

		if self.mCharacter.mGuildName ~= guild_name then
			guildChanged = true
		end
		if self.mCharacter.mGuildTitle ~= guild_title then
			titleChanged = true
		end

		self.mCharacter.mGuildName = guild_name
		self.mCharacter.mGuildTitle = guild_title
		self.mCharacter.mGuildSeedId = guild_seedid

		-- PlatformTool.callVoiceChat("logout_room")
		-- if self.mCharacter.mGuildName~="" then
		-- 	PlatformTool.callVoiceChat("login_room",{seq=guild_seedid})
		-- end

		self:dispatchEvent({name=Notify.EVENT_GUILD_MSG, guildChanged = guildChanged, titleChanged = titleChanged})
		-- UISceneGame.initVoiceSetting()
		-- self.mCharacter.cmdRefreshName = true
		-- game.GhostManager():updateSomeOneName(self.mCharacter.mID)
	end,

	-- [NetProtocol.cNotifyGhostGuildInfo] = function(mMsg)
	-- 	local id = mMsg:readUInt()
	-- 	local guild_name = mMsg:readString()
	-- 	local guild_title = mMsg:readInt()
	-- 	local netghost = self.mNetGhosts[id]
	-- 	if netghost then
	-- 		-- --print("==========cNotifyGhostGuildInfo",guild_name,guild_title)
	-- 		netghost.mGuildName = guild_name
	-- 		netghost.mGuildTitle = guild_title
	-- 		netghost.cmdRefreshName = true
	-- 		-- game.GhostManager():updateSomeOneName(id)
	-- 		-- game.GhostManager():updateSomeOneName(self.mCharacter.mID)
	-- 	end
	-- end,

	[NetProtocol.cNotifyGroupInfoChange] = function(mMsg)
		self.mCharacter.mGroupID = mMsg:readInt()
		self.mCharacter.mGroupPickMode = mMsg:readInt()
		self.mCharacter.mGroupName = mMsg:readString()

		-- if self.isFirstGetGroupInfoChange == nil then
		-- 	self.isFirstGetGroupInfoChange = true
		-- end

		local leader = mMsg:readString()
		local isSelfNew = false
		if game.GetMainRole() then
			if string.len(leader) > 0 and leader ~= game.GetMainRole():NetAttr(Const.net_name) and leader ~= self.mCharacter.mGroupLeader and not self.isFirstGetGroupInfoChange then
				self:alertLocalMsg("您成功加入["..leader.."]的队伍", "alert")
				isSelfNew = true
			end
		end
		self.mCharacter.mGroupLeader = leader

		local result = mMsg:readInt()
		local old = clone(self.mGroupMembers)
		if result == 0 and #old > 0 and not self.isFirstGetGroupInfoChange then
			self:alertLocalMsg("您已离开队伍", "alert")
		end

		self.mGroupMembers = {}
		for i=1,result do
			local gm={}
			local isNew = true
			gm.srcid = mMsg:readInt()
			gm.name = mMsg:readString()
			for j=1,#old do
				if gm.name == old[j].name then--老成员更新数据
					isNew = false
					gm.name = old[j].name
					gm.hp = old[j].hp
					gm.mp = old[j].mp
					gm.state = old[j].state

					gm.job = old[j].job
					gm.level = old[j].level
					gm.power = old[j].power
					gm.locateMap = old[j].locateMap
					gm.gender = old[j].gender
				end
			end
			if not isSelfNew and isNew and not self.isFirstGetGroupInfoChange then
				self:alertLocalMsg(gm.name.."加入了队伍", "alert")
			end
			self.mGroupMembers[i]=gm
		end

		if result ~= 0 and result < #old then
			for i,_ in ipairs(old) do
				local isLeave = true
				for j,__ in ipairs(self.mGroupMembers) do
					if old[i].name == self.mGroupMembers[j].name then
						isLeave = false
						break
					end
				end
				if isLeave and not self.isFirstGetGroupInfoChange then
					self:alertLocalMsg(old[i].name.."离开了队伍", "alert")
				end
			end
		end
		self.isFirstGetGroupInfoChange = false
		-- UISceneGame.initVoiceSetting()
		self:dispatchEvent({name=Notify.EVENT_GROUP_LIST_CHANGED, type=NetProtocol.cNotifyGroupInfoChange})

		--刷新队伍内其他玩家名字
		if isSelfNew then
			----print("////////////////////////isSelfNew///////////////////////", isSelfNew)
			for i,v in ipairs(self.mGroupMembers) do
				local pGhost = CCGhostManager:getPixesGhostByID(v.srcid)
				----print("////////////////////////isSelfNew///////////////////////", v.srcid, pGhost)
				if pGhost then
					pGhost:updateName(true)
				end
			end
		end
	end,

	[NetProtocol.cNotifyGroupState] = function(mMsg)
		self.mCharacter.mGroupID = mMsg:readInt()
		local result = mMsg:readInt()
		for i=1,result do
			local gm={}
			gm.state = mMsg:readInt()
			gm.hp = mMsg:readInt()
			gm.mp = mMsg:readInt()
			gm.job = mMsg:readInt()
			gm.level = mMsg:readInt()
			gm.power = mMsg:readInt()
			gm.locateMap = mMsg:readString()
			gm.gender = mMsg:readInt()

			if i <= #self.mGroupMembers then
				table.merge(self.mGroupMembers[i], gm)
				-- self.mGroupMembers[i]=gm
			end
		end
		self:dispatchEvent({name=Notify.EVENT_GROUP_LIST_CHANGED, type=NetProtocol.cNotifyGroupState})
	end,

	[NetProtocol.cNotifyGroupInfo] = function(mMsg)
		local id =  mMsg:readInt()
		local group_id =  mMsg:readInt()
		local group_name =  mMsg:readString()
		local group_leader =  mMsg:readString()

		if group_id == 0 then
			self.nearByGroupInfo[id] = nil
		else
			self.nearByGroupInfo[id] = {
				group_id = group_id,
				group_leader = group_leader,
				group_name = group_name,
			}
		end
		--print("group============",id, group_id, group_name, group_leader)

		local pGhost = CCGhostManager:getPixesGhostByID(id)
		if pGhost then
			pGhost:updateName(true)
		end
		self:dispatchEvent({name=Notify.EVENT_GROUP_LIST_CHANGED, type=NetProtocol.cNotifyGroupInfo})
	end,

	[NetProtocol.cNotifyInviteGroupToMember] = function(mMsg)
		local mGroupLeader =  mMsg:readString()
		local mGroupID = mMsg:readInt()
		local inviter = NetCC:findGhostByName(mGroupLeader)
		if not self.tipsMsg["tip_group"] then self.tipsMsg["tip_group"] = {} end

		if not inviter then return end
		local groupType = UserConfig.getConf("GroupType")
		if groupType==3 then return end --拒绝组队邀请
		if groupType==1 then
			self:AgreeInviteGroup(mGroupLeader,mGroupID)
			return
		end

		local param = {
			name  = mGroupLeader,
			job   = inviter:NetAttr(Const.net_job),
			level = inviter:NetAttr(Const.net_level),
			power = inviter:NetAttr(Const.net_fight_point),
			gender= inviter:NetAttr(Const.net_gender),
			state = inviter:NetAttr(Const.net_state),
			group_id = mGroupID,
			msgType = "invite",
		}

		local needInsert = true
		for i,v in ipairs(self.tipsMsg["tip_group"]) do
			if v.name == mGroupLeader and v.msgType == "invite" then
				-- needInsert = false--只需要更新
				-- self.tipsMsg["tip_group"][i] = param
				table.remove(self.tipsMsg["tip_group"],i)
				break
			end
		end
		if needInsert then--需要插入新的申请，且消息数量+1
			table.insert(self.tipsMsg["tip_group"], param)
			self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_group"})--申请加入
		end
	end,
	[NetProtocol.cNotifyJoinGroupToLeader] = function(mMsg)
		self.m_strApplyerName = mMsg:readString()
		local applyer = NetCC:findGhostByName(self.m_strApplyerName)
		if applyer then
			if not self.tipsMsg["tip_group"] then self.tipsMsg["tip_group"] = {} end

			local param = {
				name  = self.m_strApplyerName,
				job   = applyer:NetAttr(Const.net_job),
				level = applyer:NetAttr(Const.net_level),
				power = applyer:NetAttr(Const.net_fight_point),
				gender= applyer:NetAttr(Const.net_gender),
				state = applyer:NetAttr(Const.net_state),
				msgType = "apply",
			}

			local needInsert = true
			for i,v in ipairs(self.tipsMsg["tip_group"]) do
				if v.name == self.m_strApplyerName and v.msgType == "apply" then
					-- needInsert = false--只需要更新
					-- self.tipsMsg["tip_group"][i] = param
					table.remove(self.tipsMsg["tip_group"],i)
					break
				end
			end
			if needInsert then--需要插入新的申请，且消息数量+1
				table.insert(self.tipsMsg["tip_group"], param)
				self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_group"})--申请加入
			end
		end
	end,

	[NetProtocol.cNotifyListGuildBegin] = function(mMsg)
		self.mGuildList = {}
		self.mCharacter.num_enter = 0
		--print("//////////cNotifyListGuildBegin//////////")
	end,

	[NetProtocol.cNotifyListGuildEnd] = function(mMsg)
		-- local function compFunc(member1,member2)
		-- 	if member1.mLevelGuild ~= member2.mLevelGuild then
		-- 		return member1.mLevelGuild > member2.mLevelGuild
		-- 	else
		-- 		return member1.mMemberNumber > member2.mMemberNumber
		-- 	end
		-- end
		-- table.sort(self.mGuildList, compFunc)

		-- local selfGuildName = game.GetMainRole():NetAttr(Const.net_guild_name)
		-- for i,v in ipairs(self.mGuildList) do
		-- 	if v.mName == selfGuildName then
		-- 		self.guildRanking = i
		-- 		break
		-- 	end
		-- end
		--print("//////////cNotifyListGuildEnd//////////")
		self:dispatchEvent({name=Notify.EVENT_GUILD_LIST})
	end,

	[NetProtocol.cNotifyListGuildItem] = function(mMsg)
		local pName = mMsg:readString()
		local pGuild=self:getGuildByName(pName)
		if not pGuild then
			pGuild={}
			pGuild.mName=pName
			table.insert(self.mGuildList,pGuild)
		end
		pGuild.mGuildSeedId = mMsg:readString()
		pGuild.mMemberNumber = mMsg:readInt()
		pGuild.mDesp = mMsg:readString()
		pGuild.mMasterLevel = mMsg:readInt()
		pGuild.entering = mMsg:readInt()
		if pGuild.entering > 0 then
			self.mCharacter.num_enter = (self.mCharacter.num_enter or 0) + 1
		end
		pGuild.mLeader = mMsg:readString()
		pGuild.mLevelGuild = mMsg:readInt()
		pGuild.mGuildExp = mMsg:readInt()
		pGuild.mWarStatus = mMsg:readInt()
		pGuild.mWarStartTime = mMsg:readInt()

		--print("//////////cNotifyListGuildItem//////////")
	end,

	[NetProtocol.cNotifyInfoItemChange] = function(mMsg)
		local src_id = mMsg:readUInt()
		local NetItem = {}
		NetItem.mPosition	= mMsg:readInt()
		NetItem.mTypeID 	= mMsg:readInt()
		NetItem.mDuraMax 	= mMsg:readInt()
		NetItem.mDuration  	= mMsg:readInt()
		NetItem.mItemFlags  = mMsg:readInt()
		NetItem.mLevel  	= mMsg:readInt()
		NetItem.mZLevel 	= mMsg:readInt()
		NetItem.mNumber 	= mMsg:readInt()
		NetItem.mAddAC  	= mMsg:readShort()
		NetItem.mAddMAC  	= mMsg:readShort()
		NetItem.mAddDC 		= mMsg:readShort()
		NetItem.mAddMC  	= mMsg:readShort()
		NetItem.mAddSC  	= mMsg:readShort()
		NetItem.mUpdAC  	= mMsg:readShort()
		NetItem.mUpdMAC 	= mMsg:readShort()
		NetItem.mUpdDC  	= mMsg:readShort()
		NetItem.mUpdMC  	= mMsg:readShort()
		NetItem.mUpdSC  	= mMsg:readShort()
		-- NetItem.mUpdMaxCount	= mMsg:readShort()--注释的4条服务器暂时没有发过来
		-- NetItem.mUpdFailedCount	= mMsg:readShort()
		NetItem.mLuck 		= mMsg:readShort()
		NetItem.mProtect  	= mMsg:readShort()
		-- NetItem.mSellPriceType	= mMsg:readShort()
		-- NetItem.mSellPrice 	= mMsg:readInt()
		NetItem.mAddHp  	= mMsg:readShort()
		NetItem.mAddMp  	= mMsg:readShort()
		NetItem.mCreateTime = mMsg:readInt()
		NetItem.role = mMsg:readString()
		NetItem.from = mMsg:readString()
		NetItem.map = mMsg:readString()
		-- --print("======>>>",NetItem.mPosition)
		if self.mOthersItems[NetItem.mPosition] then
			self.mOthersItems[NetItem.mPosition] =nil
		end
		if NetItem.mTypeID > 0 then
			self.mOthersItems[NetItem.mPosition] = NetItem
			self.other_equip_save = "saved"
		end
		self:dispatchEvent({name=Notify.EVENT_PLAYEREQUIP_INFO})
	end,

	[NetProtocol.cResListGuild] = function(mMsg)
		local guild_num = mMsg:readInt()
		self.mGuildList = {}
		for i=1,guild_num do
			local pGuild			= {}
			pGuild.mName			= mMsg:readString()
			pGuild.mMemberNumber	= mMsg:readInt()
			pGuild.mDesp			= mMsg:readString()
			pGuild.mMasterLevel		= mMsg:readInt()
			pGuild.mLeader			= mMsg:readString()
			table.insert(self.mGuildList, pGuild)
		end
		--print("//////////cResListGuild//////////")
	end,

	-- [NetProtocol.cNotifySessionClosed] = function(mMsg)
	-- 	local s =mMsg:readString()
	-- 	self.m_bIsDisConnect = true
	-- end,

	[NetProtocol.cNotifyShowProgressBar] = function(mMsg)
		local time = mMsg:readInt()
		local info = mMsg:readString()

		self:dispatchEvent({name=Notify.EVENT_START_PROGRESS,time = time,info=info})

		if self.m_bReqCollect then
			self.m_bCollecting = true
			self.m_bReqCollect = false
			self.m_collectTime = game.getTime() + time*1500
		end
		--print("cNotifyShowProgressBar")
	end,

	[NetProtocol.cNotifyCollectBreak] = function(mMsg)

		self:dispatchEvent({name=Notify.EVENT_STOP_PROGRESS})

		if self.m_bCollecting then
			self.m_bCollecting = false
		end
		--print("cNotifyCollectBreak")
	end,
	[NetProtocol.cNotifyCollectEnd] = function (mMsg)
		local srcid = mMsg:readInt()
		if MainRole and MainRole.completeCollect then MainRole.completeCollect(srcid) end
		--self:dispatchEvent({name=Notify.EVENT_FINISH_COLLECT, srcid = srcid})
	end,

	[NetProtocol.cResListGuildMember] = function(mMsg)
		local guild_name = mMsg:readString()
		local list_type = mMsg:readInt()
		local result = mMsg:readInt()
		local member = {}
		for i=1,result do
			local guild_member = {}
			guild_member.nick_name = mMsg:readString()
			guild_member.title = mMsg:readShort()
			guild_member.online = mMsg:readShort()
			guild_member.gender = mMsg:readShort()
			guild_member.job = mMsg:readShort()
			guild_member.level = mMsg:readShort()
			guild_member.fight = mMsg:readInt()
			guild_member.guildpt = mMsg:readInt()
            guild_member.entertime = mMsg:readInt()
			member[guild_member.nick_name] = guild_member
		end
		local pGuild=self:getGuildByName(guild_name)
		-- for i=1,#self.mGuildList do
			-- if self.mGuildList[i].mName == guild_name then
			if pGuild then
				if list_type == 101 then
					pGuild.mRealMembers = member
				elseif list_type == 100 then
					pGuild.mEnteringMembers = member

				end
			end
		-- end
		self:dispatchEvent({name = Notify.EVENT_GUILD_MEMBER,data = pGuild, memberType = list_type})
		--print("//////////cResListGuildMember//////////")
	end,
	[NetProtocol.cNotifyGuildMemberChange] = function(mMsg)
		self:dispatchEvent({name = Notify.EVENT_GUILD_MEMBER_CHANGE})
	end,

	[NetProtocol.cNotifyGuildWar] = function(mMsg)
		self:dispatchEvent({name = Notify.EVENT_GUILD_WAR_CHANGE})
	end,

	[NetProtocol.cResGetGuildInfo] = function(mMsg)
		-- local netGuild = {}
		-- netGuild.mName = mMsg:readString()
		-- netGuild.mMemberNumber = mMsg:readInt()
		-- netGuild.mDesp = mMsg:readString()
		-- netGuild.mNotice = mMsg:readString()
		-- table.insert(self.mGuildList,netGuild)
		local pName = mMsg:readString()
		local pGuild=self:getGuildByName(pName)
		if not pGuild then
			pGuild={}
			pGuild.mName=pName
			table.insert(self.mGuildList,pGuild)
		end
		pGuild.mMemberNumber = mMsg:readInt()
		pGuild.mDesp = mMsg:readString()
		pGuild.mNotice = mMsg:readString()
		pGuild.mLeader = mMsg:readString()
		pGuild.mLevelGuild = mMsg:readInt()
		pGuild.mGuildExp = mMsg:readInt()
		pGuild.mGuildSeedId = mMsg:readString()

		self:dispatchEvent({name = Notify.EVENT_GUILD_INFO})
		--print("//////////cResGetGuildInfo//////////")
	end,

	[NetProtocol.cResGetChartInfo] = function(mMsg)
		local chart_type = mMsg:readInt()
		local page = mMsg:readInt()
		local num = mMsg:readInt()
		self.mChartData[chart_type] = {}
		for i = 1, num do
			-- local item	= {}
			-- item.name	= mMsg:readString()
			-- item.seedName = mMsg:readString()
			-- item.param	= mMsg:readInt()
			local item	= {}
			item.name	= mMsg:readString()
			item.param	= mMsg:readInt()
			item.guild	= mMsg:readString()
			item.title	= mMsg:readString()
			item.job	= mMsg:readInt()
			item.lv		= mMsg:readInt()
			item.state	= mMsg:readByte()
			item.zslv 	= mMsg:readInt()
			item.gender = mMsg:readInt()
			-- item.cloth  = mMsg:readInt()
			-- item.weapon = mMsg:readInt()
			item.wing   = mMsg:readInt()
			-- item.hair   = mMsg:readInt()
			table.insert(self.mChartData[chart_type], item)
			if item.name == game.chrName then
				self.mChartData[chart_type].chartRank = i
			end
		end
		self.mChartType = chart_type
		self:dispatchEvent({name = Notify.EVENT_REQCHART_LIST,page=page})
	end,

	[NetProtocol.cResVcoinShopList] = function(mMsg)
		self.mVcoinShopNpcID = mMsg:readInt()
	end,

	[NetProtocol.cResNPCShop] = function(mMsg)
		local srcid = mMsg:readInt()
		local msg = mMsg:readString()
		local page = mMsg:readInt()
		local num = mMsg:readInt()
		self.mShopNpc.srcid = srcid
		self.mShopNpc.msg = msg
		self.mShopNpc.page = page
		self.mShopNpc.num = num
		self.mShopItemInfo = {}
		self.m_BestSellerNum = 0
		for i=1,num do
			local mSItemInfo = {}
			mSItemInfo.pos =  mMsg:readInt()
			mSItemInfo.good_id =  mMsg:readInt()
			mSItemInfo.type_id =  mMsg:readInt()
			mSItemInfo.number =  mMsg:readInt()
			mSItemInfo.price_type =  mMsg:readInt()
			mSItemInfo.price =  mMsg:readInt()
			mSItemInfo.oldprice =  mMsg:readInt()
			mSItemInfo.good_tag = mMsg:readInt()
			if mSItemInfo.pos > 1000 then
				self.m_BestSellerNum = self.m_BestSellerNum + 1
			end
			table.insert(self.mShopItemInfo,mSItemInfo)
		end
		if #self.mVcoinShopItem <= 0 and self.mShopNpc.srcid == self.mVcoinShopNpcID and page == 0 then
			self.mVcoinShopItem = {}
			for i=1,num do
				local mSItemInfo = {}
				mSItemInfo.pos = self.mShopItemInfo[i].pos
				mSItemInfo.good_id = self.mShopItemInfo[i].good_id
				mSItemInfo.type_id = self.mShopItemInfo[i].type_id
				mSItemInfo.number = self.mShopItemInfo[i].number
				mSItemInfo.price_type = self.mShopItemInfo[i].price_type
				mSItemInfo.price = self.mShopItemInfo[i].price
				mSItemInfo.oldprice = self.mShopItemInfo[i].oldprice
				mSItemInfo.good_tag = self.mShopItemInfo[i].good_tag
				table.insert(self.mVcoinShopItem,mSItemInfo)
			end
		end
		self:dispatchEvent({name = Notify.EVENT_NET_NPC_SHOP})
	end,

	[NetProtocol.cNotifyItemPanelFresh] = function(mMsg)
		local flag = mMsg:readInt();
		self.mSortFlag = nil
		self:dispatchEvent({name = Notify.EVENT_FRESH_ITEM_PANEL, flag = flag})
	end,

----------------------------------------------------------------------------------聊天相关
	[NetProtocol.cResMapChat] = function(mMsg)
		local netChat = {}
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = Const.str_chat_near--"【附近】"--
		netChat.m_strName = game.chrName
		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cNotifyMapChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strName = mMsg:readString()
		netChat.m_lv = mMsg:readInt()
		netChat.m_gender = mMsg:readInt()
		netChat.m_job = mMsg:readInt()
		netChat.m_vip = mMsg:readInt()
		netChat.m_guild = mMsg:readString()

		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = Const.str_chat_near --"【附近】"
		if self:getRelation(netChat.m_strName)==102 then return end
		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cResPrivateChat] = function(mMsg)
		local netChat = {}
		netChat.m_strName = mMsg:readString()
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_MyName = game.chrName
		netChat.m_strType = "【私聊】"--Const.str_chat_private
		self:addToMsgHistory(netChat)
		self:addChatRecentPlayer(netChat.m_strName)
		local relation = self:getRelation(netChat.m_strName)
		if relation==0 and self.mFriends and self.mFriends[netChat.m_strName] then
			if self.mFriends[netChat.m_strName].online_state == 0 then
				self.mFriends[netChat.m_strName].online_state = 1
				self:dispatchEvent({name = Notify.EVENT_CHAT_RECENT,str="private"})
			end
		end
	end,

	[NetProtocol.cNotifyPrivateChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strName = mMsg:readString()
		netChat.m_lv = mMsg:readInt()
		netChat.m_gender = mMsg:readInt()
		netChat.m_job = mMsg:readInt()
		netChat.m_vip = mMsg:readInt()
		netChat.m_guild = mMsg:readString()

		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = "【私聊】"--Const.str_chat_private
		local relation = self:getRelation(netChat.m_strName)
		if relation==102 then
			return
		elseif relation==0 then
			self.mFriends = self.mFriends or {}
			self.mFriends[netChat.m_strName] = self.mFriends[netChat.m_strName] or {}
			self.mFriends[netChat.m_strName].name = netChat.m_strName
			self.mFriends[netChat.m_strName].level = netChat.m_lv
			self.mFriends[netChat.m_strName].job = netChat.m_job
			self.mFriends[netChat.m_strName].title = 0
			self.mFriends[netChat.m_strName].guild = netChat.m_guild
			self.mFriends[netChat.m_strName].gender = netChat.m_gender
			if self.mFriends[netChat.m_strName].online_state ~= 1 then
				self.mFriends[netChat.m_strName].online_state = 1
				self:dispatchEvent({name = Notify.EVENT_CHAT_RECENT,str="private"})
			end
		end
		self:addToMsgHistory(netChat)
		self.tipsMsg["tip_private"] = {}
		table.insert(self.tipsMsg["tip_private"],netChat)
		self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_private"})

		self:addChatRecentPlayer(netChat.m_strName)
	end,

	[NetProtocol.cResGuildChat] = function(mMsg)
		local netChat = {}
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strName = game.chrName
		-- netChat.m_strMsg = "<font color='#F5F5F5'>"..game.chrName.."</font>"..netChat.m_strMsg
		netChat.m_strType = "【帮会】"--Const.str_chat_guild
		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cNotifyGuildChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strName = mMsg:readString()
		netChat.m_lv = mMsg:readInt()
		netChat.m_gender = mMsg:readInt()
		netChat.m_job = mMsg:readInt()
		netChat.m_vip = mMsg:readInt()
		netChat.m_guild = mMsg:readString()

		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = "【帮会】"--Const.str_chat_guild
		if self:getRelation(netChat.m_strName)==102 then return end

		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cResGroupChat] = function(mMsg)
		local netChat = {}
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		-- netChat.m_strMsg = "<font color='#F5F5F5'>"..game.chrName.."</font>"..netChat.m_strMsg
		netChat.m_strName = game.chrName
		netChat.m_strType = "【队伍】"
		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cNotifyGroupChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strName = mMsg:readString()
		netChat.m_lv = mMsg:readInt()
		netChat.m_gender = mMsg:readInt()
		netChat.m_job = mMsg:readInt()
		netChat.m_vip = mMsg:readInt()
		netChat.m_guild = mMsg:readString()
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = "【队伍】"
		if self:getRelation(netChat.m_strName)==102 then return end
		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cResNormalChat] = function(mMsg)
		local netChat = {}
		local strMsg = mMsg:readString()
		netChat.m_strName = game.chrName
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strMsg = netChat.m_strMsg
		-- netChat.m_strMsg = "<font color='#F5F5F5'>"..game.chrName..":</font>"..netChat.m_strMsg
		netChat.m_strType = Const.str_chat_near--"【普通】"
		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cNotifyNoramlChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strName = mMsg:readString()
		netChat.m_lv = mMsg:readInt()
		netChat.m_gender = mMsg:readInt()
		netChat.m_job = mMsg:readInt()
		netChat.m_vip = mMsg:readInt()
		netChat.m_guild = mMsg:readString()
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = Const.str_chat_near--"【普通】"
		if self:getRelation(netChat.m_strName)==102 then return end

		self:addToMsgHistory(netChat)

	end,

	[NetProtocol.cResWorldChat] = function(mMsg)
		local netChat = {}
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strName = game.chrName
		-- netChat.m_strMsg = "<font color='#DAA520'>"..game.chrName..":</font>"..netChat.m_strMsg
		-- netChat.m_strMsg = game.chrName..":"..netChat.m_strMsg
		netChat.m_strType = "【世界】"

		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cNotifyWorldChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strName = mMsg:readString()
		netChat.m_lv = mMsg:readInt()
		netChat.m_gender = mMsg:readInt()
		netChat.m_job = mMsg:readInt()
		netChat.m_vip = mMsg:readInt()
		netChat.m_guild = mMsg:readString()

		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = "【世界】"
		if self:getRelation(netChat.m_strName)==102 then return end

		self:addToMsgHistory(netChat)
	end,

	[NetProtocol.cResHornChat] = function(mMsg)
		local netChat = {}
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		-- netChat.m_strMsg = "<font color='#C8C8C8'>"..game.chrName.."</font>"..netChat.m_strMsg
		netChat.m_strMsg =  game.chrName..":"..netChat.m_strMsg
		netChat.m_strType = "【喇叭】"
		netChat.m_strName = game.chrName
		self:addToMsgHistory(netChat)
		local m_strHornMsg = netChat.m_strType..netChat.m_strMsg
		table.insert(self.mHornChat,m_strHornMsg)
		self:dispatchEvent({name = Notify.EVENT_HORN_CHAT})
	end,

	[NetProtocol.cNotifyHornChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strName = mMsg:readString()
		netChat.m_lv = mMsg:readInt()
		netChat.m_gender = mMsg:readInt()
		netChat.m_job = mMsg:readInt()
		netChat.m_vip = mMsg:readInt()
		netChat.m_guild = mMsg:readString()
		local strMsg = mMsg:readString()
		netChat.m_strMsg,netChat.localPath,netChat.httpPath,netChat.duration,netChat.flag = NetClient:SeparateVipAndMsg(strMsg)
		netChat.m_strType = "【喇叭】"
		if self:getRelation(netChat.m_strName)==102 then return end
		self:addToMsgHistory(netChat)
		local m_strHornMsg = netChat.m_strType.."["..netChat.m_strName.."]"..netChat.m_strMsg
		table.insert(self.mHornChat,m_strHornMsg)
		self:dispatchEvent({name = Notify.EVENT_HORN_CHAT})

	end,

	[NetProtocol.cNotifyMonsterChat] = function(mMsg)
		local netChat = {}
		netChat.m_uSrcId = mMsg:readInt()
		netChat.m_strMsg = mMsg:readString()
		local pixesGhost = UIPixesGhost.getPixesGhost(netChat.m_uSrcId)
		if pixesGhost then
			UIPixesGhost.addTypewritter(pixesGhost,netChat.m_strMsg)
		end
	end,

	[NetProtocol.cResNPCTalk] = function(mMsg)
		local n_id=mMsg:readUInt()
		local n_flag=mMsg:readInt()
		local n_param=mMsg:readInt()
		local n_title=mMsg:readString()
		local n_msg=mMsg:readString()
		----print("///////////////////cResNPCTalk////////////////////", n_id, n_flag, n_param, n_title, n_msg);
		if n_msg ~= "" then
			self.m_nNpcTalkId = n_id
			self.m_strNpcTalkMsg = n_msg
			local s,e = string.find(n_msg,"m_tasknpc")
			if s then
				self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str = "panel_mainTask"})
			else
				self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_npctalk"} )
			end
		end
	end,

	[NetProtocol.cNotifyGotoEndNotify] = function(mMsg)
		local target=mMsg:readString()
		MainRole._mainAvatar:clearAutoMove()
		MainRole.stopAutoFight()

		MainRole._targetNPCName = target

		MainRole.MoveToContinueTask()
	end,

	[NetProtocol.cResInfoPlayer] = function(mMsg)
		local playerEquip = {}
		playerEquip.player_id	= mMsg:readInt()
		playerEquip.name		= mMsg:readString()
		playerEquip.loverName	= mMsg:readString()
		playerEquip.guild		= mMsg:readString()
		playerEquip.job		    = mMsg:readInt()
		playerEquip.gender		= mMsg:readInt()
		playerEquip.fightpoint	= mMsg:readInt()

		playerEquip.level		= mMsg:readInt()
		playerEquip.vipLv		= mMsg:readInt()
		local mountNum 			= mMsg:readInt()
		playerEquip.mountJie	= math.floor(mountNum/100)
		playerEquip.mountXing	= mountNum%100
		playerEquip.wingLv		= mMsg:readInt()

		-- playerEquip.vipLv		= self.mModels[playerEquip.player_id][5] or 0
		-- playerEquip.mountLv		= self.mModels[playerEquip.player_id][7] or 0
		-- playerEquip.wingLv		= self.mModels[playerEquip.player_id][11] or 0

		if self.m_PlayerEquip[playerEquip.name] then
			self.m_PlayerEquip[playerEquip.name] = playerEquip
		end
		self.other_avatar_save = "saved"

		if self.checkTargetName and self.checkTargetName == playerEquip.name then
			self:dispatchEvent({name=Notify.EVENT_OPEN_PANEL,str="panel_checkequip", pName = self.checkTargetName})
		end

		self:dispatchEvent({name = Notify.EVENT_PLAYER_INFO})
	end,

----------------------------------------------------------------------------------熔炉相关


--------------------------------------------------------------------------------------交易相关
	[NetProtocol.cNotifyTradeInvite] = function(mMsg)
		self.mTradeInviter = mMsg:readString()

		if G_CloseTrade < 1 then
			if not self.tipsMsg["tip_trade"] then self.tipsMsg["tip_trade"] = {} end
			table.insert(self.tipsMsg["tip_trade"],1, self.mTradeInviter)
			self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_trade"})
		else
			self:PrivateChat(self.mTradeInviter, "我已关闭交易，请不要再烦我！")
		end
	end,

	[NetProtocol.cNotifyTradeInfo] = function(mMsg)

		self.mTradeInfo.mTradeGameMoney=mMsg:readInt()
		self.mTradeInfo.mTradeVcoin=mMsg:readInt()
		self.mTradeInfo.mTradeSubmit=mMsg:readInt()
		self.mTradeInfo.mTradeTarget=mMsg:readString()
		self.mTradeInfo.mTradeDesGameMoney=mMsg:readInt()
		self.mTradeInfo.mTradeDesVcoin=mMsg:readInt()
		self.mTradeInfo.mTradeDesSubmit=mMsg:readInt()
		self.mTradeInfo.mTradeDesLevel=mMsg:readInt()
		self.mTradeInfo.mTradeResult=mMsg:readInt()

		if self.mTradeInfo.mTradeVcoin > 0 then
			self.mTradeRecord.mTradeVcoin = self.mTradeInfo.mTradeVcoin
		end
		if self.mTradeInfo.mTradeDesVcoin > 0 then
			self.mTradeRecord.mTradeDesVcoin = self.mTradeInfo.mTradeDesVcoin
		end
		if self.mTradeInfo.mTradeTarget ~= "" then
			self.mTradeRecord.mTradeTarget = self.mTradeInfo.mTradeTarget
		end
		------------------------------交易成功，记录交易------------------------------
		if self.mTradeInfo.mTradeResult == 1 then
			local msgLost = ""
			for k,v in pairs(self.mThisTradeItems) do
				local itemName = self:getItemDefByID(v.mTypeID).mName
				if itemName then
					itemName = itemName.."*"..v.mNumber
					if msgLost == "" then
						msgLost = itemName
					else
						msgLost = msgLost .."、"..itemName
					end
				end
			end
			if self.mTradeRecord.mTradeVcoin and self.mTradeRecord.mTradeVcoin > 0 then
				msgLost = msgLost.."、"..self.mTradeRecord.mTradeVcoin.."元宝"
			end
			if msgLost ~= "" then msgLost = "失去:".. msgLost.."<br>" end

			local msgGot = ""
			for k,v in pairs(self.mDesTradeItems) do
				local itemName = self:getItemDefByID(v.mTypeID).mName
				if itemName then
					itemName = itemName.."*"..v.mNumber
					if msgGot == "" then
						msgGot = itemName
					else
						msgGot = msgGot .."、"..itemName
					end
				end
			end
			if self.mTradeRecord.mTradeDesVcoin and self.mTradeRecord.mTradeDesVcoin > 0 then
				msgGot = msgGot.."、"..self.mTradeRecord.mTradeDesVcoin.."元宝"
			end

			if msgGot ~= "" then msgGot = "获得:".. msgGot.."<br>" end

			if msgLost ~= "" or msgGot ~= "" then
				local record = "<font color=#00FF00>"..os.date("%Y-%m-%d %H:%M",os.time()).."</font><br>对象:<font color=#FF0000>"..self.mTradeRecord.mTradeTarget.."</font><br>"
				if msgLost ~= "" then
					record = record..msgLost
				end
				if msgGot ~= "" then
					record = record..msgGot
				end
				table.insert(self.mTradeLocalRecord, 1, record)
				-- -------------数据本地存储-------------
			end
		end

		-- self.mUiState = true
		-- if NetClient.mUiState then
		if self.mTradeInfo.mTradeTarget ~= "" and not game.panelTradeOpen then
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str="panel_trade"})
			-- NetClient.mUiState = false
		elseif self.mTradeInfo.mTradeTarget == "" and game.panelTradeOpen then
			self:dispatchEvent({name = Notify.EVENT_CLOSE_PANEL,str="panel_trade"})
			-- NetClient.mUiState = false
		end
		-- end
		self:dispatchEvent({name = Notify.EVENT_TRADE_MONEYCHANGE,str="panel_trade"})
	end,

	[NetProtocol.cNotifyTradeItemChange] = function(mMsg)
		local side = mMsg:readInt()
		local position = mMsg:readInt()
		local item = {}
		item.mTypeID 		= mMsg:readInt()
		item.mDuraMax 		= mMsg:readInt()
		item.mDuration 		= mMsg:readInt()
		item.mItemFlags 	= mMsg:readInt()
		item.mLevel 		= mMsg:readInt()
		item.mNumber 		= mMsg:readInt()
		item.mAddAC 		= mMsg:readShort()
		item.mAddMAC 		= mMsg:readShort()
		item.mAddDC 		= mMsg:readShort()
		item.mAddMC 		= mMsg:readShort()
		item.mAddSC 		= mMsg:readShort()
		item.mUpdAC 		= mMsg:readShort()
		item.mUpdMAC 		= mMsg:readShort()
		item.mUpdDC 		= mMsg:readShort()
		item.mUpdMC 		= mMsg:readShort()
		item.mUpdSC 		= mMsg:readShort()
		item.mLuck 			= mMsg:readShort()
		local show_flag 	= mMsg:readInt()
		item.mProtect 		= mMsg:readShort()
		item.mAddHp 		= mMsg:readShort()
		item.mAddMp 		= mMsg:readShort()
		item.mCreateTime 	= mMsg:readInt()
		----print("======>>>",item.mCreateTime)
		item.mSellPrice 	= mMsg:readInt()
		item.mZLevel 		= mMsg:readInt()
		item.mLock 			= mMsg:readInt()
		item.position 		= position

		if position < 12 then
			if side == 100 then
				self.mThisChangeItems[position] = true
				self.mThisTradeItems[position] = item
			elseif side == 101 then
				self.mDesChangeItems[position] = true
				self.mDesTradeItems[position] = item
			end
			self:dispatchEvent({name = Notify.EVENT_TRADE_ITEMCHANGE,mType = "faceTrade"})
		end
		if position>=4000 and position<4010 then

			if side == 101 then
				self:dispatchEvent({name = Notify.EVENT_TRADE_ITEMCHANGE,mType = "showItemDef",nItem = item})
			else
				self.mChatTradeItemList[position] = item

				self:dispatchEvent({name = Notify.EVENT_TRADE_ITEMCHANGE,mType = "chatTrade"})
			end
		end
	end,

--------------------------------------------------------------------------------------
	[NetProtocol.cNotifyItemTalk] = function(mMsg)
		self.m_nItemTalkId = mMsg:readInt()
		self.m_nNpcTalkId = mMsg:readInt()
		local title = mMsg:readString()
		self.m_strNpcTalkMsg = mMsg:readString()
		self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str="panel_itemtalk"})
	end,

	[NetProtocol.cNotifyPlayerTalk] = function(mMsg)
		self.m_nNpcTalkId = mMsg:readInt()
		self.m_strNpcTalkMsg = mMsg:readString()
		----print("///////////////////cNotifyPlayerTalk////////////////////", self.m_nNpcTalkId, self.m_strNpcTalkMsg);
		self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str="panel_playertalk"})
	end,

	[NetProtocol.cNotifyPushLuaTable] = function(mMsg)
		local ttype=mMsg:readString()
		local tflag=mMsg:readInt()
		local tdata=""
		if tflag > 0 then
			tdata=mMsg:readStringByZip(tflag)
			-- --print("==================：",tdata)
		else
			tdata=mMsg:readString()
			-- --print(tdata)
		end
		local result=util.decode(tdata)
		if ttype == "npc_echo" then
			-- local pixesGhost = UIPixesGhost.getPixesGhost(result.id)
			-- UIPixesGhost.addTypewritter(pixesGhost,result.talk_str)
			-- --print("///////////////////////npc_echo///////////////////////", tdata)
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str = "panel_playertalk",result = result})
		elseif ttype == "dissolveGroup" then
			self:LeaveGroup()
		elseif ttype == "npc_echo1" then		
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str = "panel_playertalk1",result = result})
		elseif ttype == "item_param" then
			self:dispatchEvent({name = Notify.EVENT_ITEM_TIME, param_id = result.param_id})
		elseif ttype == "guide" then
			-- if game.isNewFunc then
			-- 	self.guideTab[1]=result.lv
			-- else
				self:dispatchEvent({name = Notify.EVENT_SHOW_GUIDE, lv = result.lv})
			-- end
		elseif ttype == "endGuide" then
			self:dispatchEvent({name = Notify.EVENT_END_GUIDE, lv = result.lv})
		elseif ttype == "fakeShowItem" then
			self:dispatchEvent({name=Notify.EVENT_BETTER_ITEM, mTypeID = result.mTypeID})
		elseif ttype == "taskChange" then -- 特殊处理左侧任务栏
			local param={}
			param.mTaskID = result.mTaskID
			param.mFlags = result.mFlags
			param.mState = result.mState
			param.mParam_1 = result.mParam_4
			param.mParam_2 = result.mParam_4
			param.mParam_3 = result.mParam_4
			param.mParam_4 = result.mParam_4
			param.mName = result.mName
			param.mInfo = result.mShortDesp
			self.mTasks[param.mTaskID]=param

			self:dispatchEvent({name=Notify.EVENT_TASK_CHANGE,cur_id = param.mTaskID})
		elseif ttype == "startAutoFight" then
			if MainRole then MainRole.startAutoFight() end
		elseif ttype == "stopAutoFight" then
			if MainRole then MainRole.stopAutoFight() end
		elseif ttype == "showFly" then
			self:dispatchEvent({name = Notify.EVENT_SHOW_FLY, info = result.flyInfo})
		elseif ttype == "hideFly" then
			self:dispatchEvent({name = Notify.EVENT_SHOW_FLY})
		elseif ttype == "funcPreview" then
			self.mFuncPreview = {visible = result.visible, data = result}
			self:dispatchEvent({name = Notify.EVENT_HANDLE_FUNC_PREVIEW, visible = result.visible, data = result})
		elseif ttype == "showTaskTips" then
			self:dispatchEvent({name = Notify.EVENT_SHOW_TASK_TIPS, tips = result.tips})
		elseif ttype == "alert" then
			local param = {}
			table.merge(param, result)
			param.name = Notify.EVENT_PANEL_ON_ALERT
			param.confirmCallBack = function (num)
				self:PushLuaTable(result.path,util.encode({actionid = result.actionid, param = result.param,args=num}))
			end
			param.cancelCallBack = function ()
				self:PushLuaTable(result.path,util.encode({actionid = result.cancelid, param = result.param}))
			end
			self:dispatchEvent(param)
		elseif ttype =="tip_guild" then
			self.tipsMsg["tip_guild"] = self.tipsMsg["tip_guild"]  or {}
			table.insert(self.tipsMsg["tip_guild"],"tip_guild")
			self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_guild"})--申请加入
		elseif ttype == "tipsMsg" then
			self.tipsMsg[result.tipType] = self.tipsMsg[result.tipType]  or {}
			if result.visible then
				if result.tipId then
					if not table.indexof(self.tipsMsg[result.tipType], result.tipId) then
						table.insert(self.tipsMsg[result.tipType], result.tipId)
					end
				elseif not table.indexof(self.tipsMsg[result.tipType], result.tipType) then
					table.insert(self.tipsMsg[result.tipType], result.tipType)
				end
			else
				self.tipsMsg[result.tipType] = {}
			end
			self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM, str=result.tipType})
		elseif ttype =="open" then
			self:dispatchEvent({name=Notify.EVENT_OPEN_PANEL,str=result.name, tab = result.tab, mParam = result.extend, from = result.from})
		elseif ttype =="openTips" then
			if result.name == "confirm" then
				local param = {
					name = Notify.EVENT_SHOW_TIPS, str = result.name, lblConfirm = result.lblConfirm,
					btnConfirm = result.confirmTitle, btnCancel = result.cancelTitle,
					confirmCallBack = function ()
						NetClient:PushLuaTable(result.svrPath, util.encode({actionid = result.confirmAction}))
					end,
					cancelCallBack = function ()
						NetClient:PushLuaTable(result.svrPath, util.encode({actionid = result.cancelAction}))
					end,
				}
				self:dispatchEvent(param)
			else
				self:dispatchEvent({
					name = Notify.EVENT_SHOW_TIPS, str = result.name, param = result
				})
			end
		elseif ttype =="closeTips" then
			self:dispatchEvent({
				name = Notify.EVENT_HIDE_TIPS, str = result.name, param = result
			})
		elseif ttype =="lockExtendBtns" then
			self:dispatchEvent({name = Notify.EVENT_EXTEND_VISIBLE,visible = result.visible,lock = result.lock or "unlock"})
		elseif ttype == "extendVisible" then
			self:dispatchEvent({name = Notify.EVENT_EXTEND_VISIBLE,visible = result.visible})
		elseif ttype =="close" then
			self:dispatchEvent({name=Notify.EVENT_CLOSE_PANEL,str=result.name})
		elseif ttype == "newfunc" then -- 新功能开启
			if result.func and result.mType then
				if not self.m_func[result.mType] then self.m_func[result.mType] = {} end
				if not self.m_func[result.mType][result.func] then
					self.m_func[result.mType][result.func] = 1
					if result.mType == "menu" then
						self.menuChange = true
					end

					if game.guiding then
						self.guideTab[1]=tdata
					else
						self:dispatchEvent({name = Notify.EVENT_OPEN_NEWFUNC, data = tdata})
					end
				end
			end
		elseif ttype == "autoCast" then
			self.NetAutoSkills = {}
			if tdata and tdata ~= "" then
				self.NetAutoSkills = util.decode(tdata)
			end
		elseif ttype == "switchAutoCast" then
			self.NetAutoSkills = self.NetAutoSkills or {}
			if result.state and not table.indexof(self.NetAutoSkills, result.skillType) then
				table.insert(self.NetAutoSkills, result.skillType)
				self:dispatchEvent({name = Notify.EVENT_SWITCH_AUTO_SKILL, skillType = result.skillType, state = result.state})
			elseif not result.state and table.indexof(self.NetAutoSkills, result.skillType) then
				table.removebyvalue(self.NetAutoSkills, result.skillType)
				self:dispatchEvent({name = Notify.EVENT_SWITCH_AUTO_SKILL, skillType = result.skillType, state = result.state})
			end
		elseif ttype == "allGuiButtons" then
			self.mAllFuncs = {}
			for i,v in ipairs(result.allFuncs) do
				self.mAllFuncs[v.funcid] = v
			end

			self.mExtendButtons = result.extend
			self.mBasicButtons = {}
			local param = {}
			if self.mAllFuncs then
				for k,v in pairs(self.mAllFuncs) do
					if not self.mBasicButtons[v.funcKey] then
					--报错注销
						-- self.mBasicButtons[v.funcKey] = v
					elseif self.mBasicButtons[v.funcKey].level > v.level then
						self.mBasicButtons[v.funcKey] = v
					end
				end
			end

			if result.basic then
				self.mBasicButtons = result.basic
			end
			self:dispatchEvent({name = Notify.EVENT_GUI_BUTTON})
		elseif ttype == "showFun" then
			local param ={
				name = Notify.EVENT_SHOW_TIPS,
				str = "funOpen",
				openpanel = result.name,
				funName = result.funName,
				icon = result.showicon
			}
			self:dispatchEvent(param)
		elseif ttype == "allfunc" then
			self.m_func = result.allfunc
		elseif ttype == "showGestureGuide" then
			self:dispatchEvent({name = Notify.EVENT_SHOW_GESTURE_GUIDE, slideIn = result.slideIn})
		elseif ttype == "removeGestureGuide" then
			self:dispatchEvent({name = Notify.EVENT_REMOVE_GESTURE_GUIDE, slideGuide = result.slideGuide})
		elseif ttype == "switchUIMode" then
			self:dispatchEvent({name = Notify.EVENT_SWITCH_UI_MODE, mode = result.simple and Const.UI_SIMPLIFIED or Const.UI_COMPLETE})
		elseif ttype == "redPoint" then
			if result.visible then
				self:dispatchEvent({name = Notify.EVENT_SHOW_REDPOINT, lv = result.lv,index = result.index})
			else
				self:dispatchEvent({name = Notify.EVENT_REMOVE_REDPOINT, lv = result.lv,index = result.index})
			end
		elseif ttype == "showConfirm" or ttype=="showAlert" then
			if PLATFORM_BANSHU and result.callFunc=="server.showChongzhi" then
				result.callFunc = ""
				result.labelConfirm = "确定"
			end
			local param = {
				name = Notify.EVENT_SHOW_TIPS, str = ttype == "showConfirm" and "confirm" or "alert", lblConfirm = result.str, btnConfirm = result.labelConfirm,btnCancel = result.labelCancel,
				checkBox = result.checkBox,
				confirmCallBack = function ()
					self:PushLuaTable(result.callFunc,result.book)
				end
			}
			self:dispatchEvent(param)
		elseif ttype == "showBottomMsg" then
			if result.str == "tip_king" or result.str =="tip_activity" then
				if not util.isTable(self.tipsMsg[result.str]) then self.tipsMsg[result.str] = {} end
				if result.hide then
					self.tipsMsg[result.str] = {}
				else
					table.insert(self.tipsMsg[result.str],1,result)
				end
				self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str = result.str})
			end
		elseif ttype == "callFriendIntime" then
			self.lastCallFriendTime = os.time()
		elseif ttype == "callFriend" then
			local param = {name = Notify.EVENT_SHOW_TIPS, str = "gotCallFriend", playerName = result.friendName}
			self:dispatchEvent(param)
		-- elseif ttype == "flyTips" then -- 传送提示
		-- 	local touchLink = result.link
		-- 	local param = {
		-- 		name = Notify.EVENT_PANEL_ON_ALERT, panel = "hint", visible = true, lblAlert1 = Const.str_warm_prompt ,
		-- 		alertTitle = Const.str_transfer_now,
		-- 		lblAlert2 =Const.str_transfer_tips1,
		-- 		timer = 5,
		-- 		alertCallBack = function ()
		-- 			util.litenerTaskLink(touchLink)
		-- 			-- self:PushLuaTable(path, util.encode({ actionid = actionid, param = {flytarget} }))
		-- 		end
		-- 	}
		-- 	self:dispatchEvent(param)
		elseif ttype == "clearTradeRecord" then
			self.mTradeLocalRecord = {}
			self:storeTradeRecord(tdata)
		elseif ttype == "ItemDailyLimitSingle" then
			if result.data then
				for i,v in ipairs(result.data) do
					self.itemDailyUseLimit[v.id] = v
					self:dispatchEvent({name = Notify.EVENT_ITEM_USELIMIT_CHANGE, typeId = v.id})
				end
				self:checkBagRedDot()
			end
		elseif ttype == "ItemDailyLimit" then
			if result.data then
				self.itemDailyUseLimit = {}
				-- --print("////////////////////ItemDailyLimit/////////////////////////")
				for k,v in pairs(result.data) do
					-- --print("////////////////////data/////////////////////////", v.id, v.leftTimes, v.totalTimes)
					self.itemDailyUseLimit[v.id] = v
				end
				self:checkBagRedDot()
			end
			-- for k,v in pairs(self.itemDailyUseLimit) do
			-- 	--print(k,util.encode(v))
			-- end
			-- local nameSprite = UIPixesGhost.getPixesGhost(game.GetMainRole():NetAttr(Const.net_id)):getNameSprite()
			-- local mNameLabel = nameSprite:getChildByName("mNameLabel")
			-- if result.team_id ~= nil then
			-- 	local nameColor = cc.c4f(255, 0, 0, 255)
			-- 	if result.team_id == 2 then
			-- 		nameColor = cc.c4f(0, 0, 255, 255)
			-- 	end
			-- 	mNameLabel:setTextColor(nameColor)
			-- 	mNameLabel:setString(result.team_label..game.chrName)
			-- elseif result.clearFlag then
			-- 	mNameLabel:setTextColor(cc.c4f(255, 255, 255, 255))
			-- 	mNameLabel:setString(game.chrName)
			-- end
			-- util.updateNamePos(nameSprite)
		elseif ttype == "clearExploitAward" then
			-- self:storeTradeRecord(tdata)
			MainRole._mainAvatar = MainRole._mainAvatar or CCGhostManager:getMainAvatar()
			if MainRole._mainAvatar then
				local charName = MainRole._mainAvatar:NetAttr(Const.net_name) or ""
				UserConfig.setInfos(charName, {}, "GongXunOpenAward")
				UserConfig.save("GongXunOpenAward")
			end
		-- elseif ttype == "chiwooBattle" then--蚩尤战场 
			-- local nameSprite = UIPixesGhost.getPixesGhost(game.GetMainRole():NetAttr(Const.net_id)):getNameSprite()
			-- local mNameLabel = nameSprite:getChildByName("mNameLabel")
			-- if result.team_id ~= nil then
				-- local nameColor = cc.c4f(255, 0, 0, 255)
				-- if result.team_id == 2 then
					-- nameColor = cc.c4f(0, 0, 255, 255)
				-- end
				-- mNameLabel:setTextColor(nameColor)
				-- mNameLabel:setString(result.team_label..game.chrName)
			-- elseif result.clearFlag then
				-- mNameLabel:setTextColor(cc.c4f(255, 255, 255, 255))
				-- mNameLabel:setString(game.chrName)
			-- end
			-- util.updateNamePos(nameSprite)
		elseif ttype == "KHcandidate" then--皇城战
			if not game.GetMainRole() then return end
			if self.KHcandidate ~= result.KHcandidate then
				self.KHcandidate = result.KHcandidate
				local srcid = game.GetMainRole():NetAttr(Const.net_id)
				local nameSprite = UIPixesGhost.getPixesGhost(srcid):getNameSprite()
				show_player_title(srcid, nameSprite)
				for i, v in ipairs(NetCC:getNearGhost(Const.GHOST_PLAYER, true)) do
					local player = CCGhostManager:getPixesGhostByID(v)
					if player then
						local nameSprite = UIPixesGhost.getPixesGhost(v):getNameSprite()
						if nameSprite then
							show_player_title(v, nameSprite)
						end
					end
				end
			end
			util.updateNamePos(nameSprite)
		-- elseif ttype == "blackBoard" then
		-- 	self:dispatchEvent({name = Notify.EVENT_BLACK_BOARD, type=ttype, data=tdata})
		-- elseif ttype == "activity" then
		-- 	self.tipsMsg["tip_activity"] = self.tipsMsg["tip_activity"] or {}
		-- 	table.insert(self.tipsMsg["tip_activity"], result)
		-- 	self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_activity"})
		-- 	if UISceneGame.InfoPart then--持续时间过了如果还没有点 则把这条消息删掉
		-- 		UISceneGame.InfoPart:runAction(cca.seq({cca.delay(result.duration), cca.callFunc(function ()
		-- 			for i,v in ipairs(self.tipsMsg["tip_activity"]) do
		-- 				if v.msg == result.msg then
		-- 					table.remove(self.tipsMsg["tip_activity"], i)
		-- 					self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_activity"})
		-- 					break
		-- 				end
		-- 			end
		-- 		end)}))
		-- 	end
		elseif ttype == "stopTask" then -- 服务端通知客户端停止任务()
			self:dispatchEvent({name = Notify.EVENT_CONTINUE_TASK})
		elseif ttype == "continueTask" then -- 服务端通知客户端继续任务
			self:dispatchEvent({name = Notify.EVENT_CONTINUE_TASK})
		elseif ttype == "effect_one" then
			self:dispatchEvent({name = Notify.EVENT_SHOW_TASK_ANIM,effect_type=result.effect_type})
		elseif ttype == "talk_npc" then
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_npctalk",talk_tab = result} )
				elseif ttype == "panel_tixian" then
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_tixian",talk_tab = result} )
		elseif ttype == "talk_npcc" then
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_npctalkc",talk_tab = result} )	
		elseif ttype == "talk_npccc" then--官职地图
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_npctalkcc",talk_tab = result} )
		elseif ttype == "talk_libao" then--任选礼包
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_libao",talk_tab = result} )
		elseif ttype == "talk_huishou" then--装备回收
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_huishou",talk_tab = result} )	
		elseif ttype == "talk_zdhuishou" then--装备回收
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_zdhuishou",talk_tab = result} )
		elseif ttype == "talk_welcome" then--装备回收
			self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL, str = "panel_welcome",talk_tab = result} )			
		elseif ttype == "fresh_npc" then
			self:dispatchEvent({name = Notify.EVENT_FRESH_NPC,talk_tab = result} )
		elseif ttype == "fresh_fuyuancd" then
			self.mCharacter.FuyuanCD = result.time
			self:dispatchEvent({name = Notify.EVENT_FRESH_FUYUANCD})
		elseif ttype == "add_status" then
			self:dispatchEvent({name = Notify.EVENT_BUFF_GOT_ANIMATION, buff_id = result.buff_id,buff_level = result.buff_level})
		-- elseif ttype == "ChooseCard" then
		-- 	self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str ="panel_card",award = result.award,baseAward = result.baseAward,choose = result.choose,actionId = result.actionId})
		-- elseif ttype == "check_equip" then
		-- 	self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str="panel_check_equip", pName = result.name})
		-- elseif ttype == "storyline" then

		-- 	self:dispatchEvent({name = Notify.EVENT_SHOW_STORY_LINE, lv = result.lv, callback = function ()
		-- 		self:PushLuaTable(result.path, util.encode({actionid = result.actionid, param = result.param}))
		-- 	end})
		-- elseif ttype == "runstory" then

		-- elseif ttype == "showdbqb" then
		-- 	self:dispatchEvent({name = Notify.EVENT_PANEL_ON_ALERT, panel="DbqbTip", dbqbdata=result.dbqbdata})
		elseif ttype == "activityOpen" then--活动开启提示
			if not util.isTable(self.tipsMsg["tip_activity"]) then self.tipsMsg["tip_activity"] = {} end
			table.insert(self.tipsMsg["tip_activity"],1,result)
			self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str = "tip_activity"})
		elseif ttype == "dieRecord" then
			local dieRecord = result.data;
			-- for k,v in pairs(dieRecord) do
			-- 	--print("die--------------------",k,v)
			-- end
			local dieRecords = UserConfig.getInfos(dieRecord.name,"DieRecords") or {}
			table.insert(dieRecords,dieRecord)
			if #dieRecords>20 then
				table.remove(dieRecords,1)
			end
			UserConfig.setInfos(dieRecord.name, dieRecords, "DieRecords")
			UserConfig.save("DieRecords")
			-- --print("···",#UserConfig.getInfos(dieRecord.name,"DieRecords"))
		elseif ttype == "showRefreshBoss" then
			self:dispatchEvent({name = Notify.EVENT_REFRESH_BOSS, info = result})
			elseif ttype == "doHttp" then  --播放充值成功动画
			
			local senUrl=result.Data;
			--print("-----发送http" ..senUrl)
			SendHttp(senUrl)
		elseif ttype == "playcz" then  --播放充值成功动画
			if result.actionid == "playcz" then
				-- local animate = cc.AnimManager:getInstance():getPlistAnimate(4,result.resid,4)--成就达成
				-- util.addEffect(UISceneGame.m_LayerPanel:getEffectPanel(),"chongzhi",4,result.resid)
				-- PlayAudio.play("sound/recharge.mp3")
				local norTime = 0.1
				local effectPanel = UISceneGame.m_LayerPanel:getEffectPanel()
				for i = 0, 5 do
					effectPanel:runAction(cca.seq({
						cca.delay(norTime),
						cca.callFunc(function()
							local x = math.random(effectPanel:getContentSize().width) + 100 
							local y = math.random(effectPanel:getContentSize().height) - 50
							x = x > 1000 and 1000 or x
							y = y > 900 and 900 or y
							if effectPanel:getChildByName("chongzhi"..i) then
								effectPanel:getChildByName("chongzhi"..i):removeFromParent()
							end
							util.addEffect(effectPanel,"chongzhi"..i,GROUP_TYPE.EFFECT,34021,nil,nil,nil, false):setPosition(x,y)
						end)
					}))
					norTime = norTime + 0.3
				end
	
				PlayAudio.play("sound/recharge.mp3")
			end
		elseif ttype == "fristPayTips" then
			-- 首充提示
			self:dispatchEvent({name=Notify.EVENT_SHOW_TIPS, str = "fristRecharge"})
		else
			if ttype == "equippreview" then
				self.previewData = result
			end

			if ttype == "hidePersonBoss" then
				self.PersonBossData = tdata
			end
			if PLATFORM_TEST then
				--print("cNotifyPushLuaTable:",type)
			end
			self:dispatchEvent({name = Notify.EVENT_PUSH_PANEL_DATA, type=ttype, data=tdata})
		end
	end,

	[NetProtocol.cNotifyGameParam] = function(mMsg)
		local param={}
		-- param.mSteelEquipCostBase = mMsg:readInt()
		-- param.mSteelEquipCostMul = mMsg:readInt()
		param.mMaxMagicAnti = mMsg:readInt()
		param.mWalkSpeedWarriorClientParam = mMsg:readInt()
		param.mStandRelivePrice = mMsg:readInt()
		param.mChartOpenLimitLevel = mMsg:readInt()
		param.mAddDepotPrice = mMsg:readInt()
		-- param.mExchangeUpdProbBase = mMsg:readInt()
		-- param.mExchangeUpdProbGap = mMsg:readInt()
		-- param.mExchangeUpdDropMax = mMsg:readInt()
		-- param.mExchangeUpdCostGM = mMsg:readInt()
		-- param.mExchangeUpdCostBV = mMsg:readInt()
		-- param.mStatusQiseshendanAC = mMsg:readInt()
		-- param.mStatusQiseshendanACMax = mMsg:readInt()
		-- param.mStatusQiseshendanMAC = mMsg:readInt()
		-- param.mStatusQiseshendanMACMax = mMsg:readInt()
		-- param.mStatusQiseshendanDC = mMsg:readInt()
		-- param.mStatusQiseshendanDCMax = mMsg:readInt()
		-- param.mStatusQiseshendanMC = mMsg:readInt()
		-- param.mStatusQiseshendanMCMax = mMsg:readInt()
		-- param.mStatusQiseshendanSC = mMsg:readInt()
		-- param.mStatusQiseshendanSCMax = mMsg:readInt()
		-- param.mStatusQiseshendanHpmaxBase = mMsg:readInt()
		-- param.mStatusQiseshendanHpmaxGap = mMsg:readInt()
		-- param.mStatusQiseshendanMpmaxBase = mMsg:readInt()
		-- param.mStatusQiseshendanMpmaxGap = mMsg:readInt()
		-- param.mStatusYuanshenhutiAC = mMsg:readInt()
		-- param.mStatusYuanshenhutiACMax = mMsg:readInt()
		-- param.mStatusYuanshenhutiMAC = mMsg:readInt()
		-- param.mStatusYuanshenhutiMACMax = mMsg:readInt()
		-- param.mStatusYuanshenhutiDC = mMsg:readInt()
		-- param.mStatusYuanshenhutiDCMax = mMsg:readInt()
		-- param.mStatusYuanshenhutiMC = mMsg:readInt()
		-- param.mStatusYuanshenhutiMCMax = mMsg:readInt()
		-- param.mStatusYuanshenhutiSC = mMsg:readInt()
		-- param.mStatusYuanshenhutiSCMax = mMsg:readInt()
		-- param.mStatusTianshenhutiMAXHP = mMsg:readInt()
	 --    param.mStatusTianshenhutiDC = mMsg:readInt()
	 --    param.mStatusTianshenhutiDCMax = mMsg:readInt()
	 --    param.mStatusTianshenhutiMC = mMsg:readInt()
	 --    param.mStatusTianshenhutiMCMax = mMsg:readInt()
	 --    param.mStatusTianshenhutiSC = mMsg:readInt()
	 --    param.mStatusTianshenhutiSCMax = mMsg:readInt()
	 --    param.mStatusTianshenhutiSubDamageProb = mMsg:readInt()
	 --    param.mStatusTianshenhutiSubDamagePres = mMsg:readInt()
		-- param.mStatusBaqihutiAC = mMsg:readInt()
		-- param.mStatusBaqihutiACMax = mMsg:readInt()
		-- param.mStatusBaqihutiMAC = mMsg:readInt()
		-- param.mStatusBaqihutiMACMax = mMsg:readInt()
		-- param.mStatusBaqihutiDC = mMsg:readInt()
		-- param.mStatusBaqihutiDCMax = mMsg:readInt()
		-- param.mStatusBaqihutiMC = mMsg:readInt()
		-- param.mStatusBaqihutiMCMax = mMsg:readInt()
		-- param.mStatusBaqihutiSC = mMsg:readInt()
		-- param.mStatusBaqihutiSCMax = mMsg:readInt()
		-- param.mDeleteExchangeUpdFromEquip = mMsg:readInt()
		param.mDieDropBagProb = mMsg:readInt()
		param.mDieDropLoadProb = mMsg:readInt()
		param.mProtectItemPrice = mMsg:readInt()
		param.mProtectItemProbMax = mMsg:readInt()
		param.mProtectItemProb = mMsg:readInt()
		param.mProtectItemAdd = mMsg:readInt()
		param.mPKConfirm = mMsg:readInt()
		-- param.mStatusFuQiTongXinAC = mMsg:readInt()
		-- param.mStatusFuQiTongXinACMax = mMsg:readInt()
		-- param.mStatusFuQiTongXinMAC = mMsg:readInt()
		-- param.mStatusFuQiTongXinMACMax = mMsg:readInt()
		param.mGuildMemberMax = mMsg:readInt()
		param.mTotalAttrLevelLimit = mMsg:readInt()
		-- param.mStatusVipDC = mMsg:readInt()
		-- param.mStatusVipDCMax = mMsg:readInt()
		-- param.mStatusVipMC = mMsg:readInt()
		-- param.mStatusVipMCMax = mMsg:readInt()
		-- param.mStatusVipSC = mMsg:readInt()
		-- param.mStatusVipSCMax = mMsg:readInt()
		-- param.mStatusVipAC = mMsg:readInt()
		-- param.mStatusVipACMax = mMsg:readInt()
		-- param.mStatusVipMAC = mMsg:readInt()
		-- param.mStatusVipMACMax = mMsg:readInt()
		self.mGameParam = param
	end,

	[NetProtocol.cNotifyListChargeDart] = function(mMsg)
		local num = mMsg:readInt()
		local result = {}
		for i = 1, num do

			local param = {}
			param.charName = mMsg:readString()
			param.icon = mMsg:readInt()
			param.remainTime = mMsg:readInt()
			param.duration = mMsg:readInt()
			param.fightForce = mMsg:readInt()
			param.stolenTimes = mMsg:readInt()
			param.totalAwards = mMsg:readInt()
			param.remainAward = mMsg:readInt()
			param.state = mMsg:readInt()
			param.robName = mMsg:readString()


			local robname = string.split(param.robName,",")[param.stolenTimes+1]
			if game.GetMainRole() then
				if param.robName and string.len(param.robName) > 0 and param.charName and game.GetMainRole():NetAttr(Const.net_name)== param.charName and not(self.mFriends[robname] and self.mFriends[robname].title == 50) then
					if not string.find(param.robName, game.GetMainRole():NetAttr(Const.net_name)) then
						if not self.stolenTimes then self.stolenTimes = 0 end
						if self.stolenTimes ~= param.stolenTimes then
							self.stolenTimes = param.stolenTimes

							if not self.tipsMsg["tip_car_robbed"] then self.tipsMsg["tip_car_robbed"] = {} end
							local param = {
								name = string.split(param.robName,",")[param.stolenTimes+1],
								robMoney = (param.totalAwards - param.remainAward)/param.stolenTimes
							}
							table.insert(self.tipsMsg["tip_car_robbed"], param)
							self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM, str = "tip_car_robbed"})
						end
					end
				end
			end

			-- if self.dartcarState ~= param.state and param.state == 1 then--完成
			-- 	if not self.tipsMsg["tip_car_achieved"] then
			-- 		self.tipsMsg["tip_car_achieved"] = {}
			-- 	end
			-- 	table.insert(self.tipsMsg["tip_car_achieved"], {name = param.charName})
			-- 	self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM, str = "tip_car_achieved"})
			-- end
			self.dartcarState = param.state

			table.insert(result, param)
		end

		self:dispatchEvent({name = Notify.EVENT_PUSH_DART_DATA, data=result})
	end,

	[NetProtocol.cResListGuildDepot] = function(mMsg)
		local size = mMsg:readInt()
		local result = {}
		for i = 1, size do
			local param = {}
			param.pos = mMsg:readInt()
			param.typeID = mMsg:readInt()
			param.level = mMsg:readInt()
			param.zlevel = mMsg:readInt()
			param.price = mMsg:readInt()
			param.job = mMsg:readInt()
			local itemDef = self:getItemDefByID(param.typeID)
			param.pinJie = tonumber(itemDef.mIconDesc)
			table.insert(result, param)
		end
		self:dispatchEvent({name = Notify.EVENT_GUILD_REPERTORY, data = result})
		-- --print("//////////cResListGuildDepot//////////", util.encode(result))
	end,

	[NetProtocol.cResGetMails] = function(mMsg)
		local mailCount = mMsg:readInt()
		local need2SelectFirst = false
		if #self.mails == 0 then
			need2SelectFirst = true
		end
		self.mails = {}
		self.tipsMsg["tip_mail"] = {}
		for i = 1, mailCount do
			local singleMail = {}
			singleMail.id = mMsg:readString()
			singleMail.title = mMsg:readString()
			singleMail.content = mMsg:readString()
			singleMail.date = mMsg:readInt()
			singleMail.isOpen = mMsg:readInt()--0是没有读过
			singleMail.isReceive = mMsg:readInt()--0是没有领
			singleMail.itemCount = mMsg:readInt()
			singleMail.item = {}

			for j = 1, singleMail.itemCount do
				local itemInfo = {
					id		= mMsg:readInt(),
					count	= mMsg:readInt(),
				}
				table.insert(singleMail.item, itemInfo)
			end
			table.insert(self.mails, 1, singleMail)

			if util.checkMailPriority(singleMail) == 1 then
				if self.mailCount ~= mailCount and self.mailCount ~=nil  then----
					table.insert(self.tipsMsg["tip_mail"], singleMail.id)
				end
			end

		end

		-- self:dispatchEvent({name = #self.tipsMsg["tip_mail"] > 0 and Notify.EVENT_SHOW_REDPOINT or Notify.EVENT_REMOVE_REDPOINT, lv = 8,index = 1})

		local function sortF(a, b)--有红点的往前
			-- return util.checkMailPriority(a) > util.checkMailPriority(b)
			if a.isOpen == b.isOpen then
				if a.isReceive==b.isReceive then
					return a.date >b.date
				else
					return a.isReceive<b.isReceive
				end
			else
				return a.isOpen<b.isOpen
			end
		end
		table.sort(self.mails, sortF)

		self:dispatchEvent({name = Notify.EVENT_GET_MAILS, need2SelectFirst = need2SelectFirst})
		----print(self.mailCount, mailCount,"=========")
		if self.mailCount ~= mailCount then----
			if  self.mailCount ~=nil then
				----print("999999999999999")
				self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM, str = "tip_mail"})
			end
		end

		self.mailCount = mailCount

		-- if #self.tipsMsg["tip_mail"] >0 then

		-- end

		self:checkMailRedPoint()-----主面板红点
		self:dispatchEvent({name = Notify.EVENT_CHECK_MAIL_FULL})
	end,

	[NetProtocol.cNotifyMailNum] = function(mMsg)
		local num = mMsg:readInt()
		self:getMails()
	end,

	[NetProtocol.cNotifyMailReceiveSuccess] = function(mMsg)
		local id = mMsg:readString()
		-- self:getMails()
		for k,v in pairs(self.mails) do
			if v.id == id then
				v.isReceive = 1
			end
		end
		-- self:deleteMail(id)
		self:dispatchEvent({name = Notify.EVENT_GET_MAILS})
		self:checkMailRedPoint()-----主面板红点
	end,

	-- [NetProtocol.cNotifyQiangHuaAllValue] = function(mMsg)
	-- 	local result = {}
	-- 	result.acMin=mMsg:readInt()
	-- 	result.acMax=mMsg:readInt()
	-- 	result.mcMin=mMsg:readInt()
	-- 	result.mcMax=mMsg:readInt()
	-- 	result.scMin=mMsg:readInt()
	-- 	result.scMax=mMsg:readInt()
	-- 	result.defMin=mMsg:readInt()
	-- 	result.defMax=mMsg:readInt()
	-- 	result.mdefMin=mMsg:readInt()
	-- 	result.mdefMax=mMsg:readInt()
	-- 	result.hp=mMsg:readInt()
	-- 	result.mp=mMsg:readInt()
	-- 	result.monHurt=mMsg:readInt()
	-- 	result.countLev=mMsg:readInt()
	-- 	self:dispatchEvent({name = Notify.EVENT_QIANGHUA_CHANGE_VALUE, data = result})
	-- end,

	-- [NetProtocol.cNotifyQiangHuaEquip] = function(mMsg)
	-- 	local newItem = {}
	-- 	newItem.position=mMsg:readInt()
	-- 	newItem.acMin=mMsg:readInt()
	-- 	newItem.acMax=mMsg:readInt()
	-- 	newItem.mcMin=mMsg:readInt()
	-- 	newItem.mcMax=mMsg:readInt()
	-- 	newItem.scMin=mMsg:readInt()
	-- 	newItem.scMax=mMsg:readInt()
	-- 	newItem.defMin=mMsg:readInt()
	-- 	newItem.defMax=mMsg:readInt()
	-- 	newItem.mdefMin=mMsg:readInt()
	-- 	newItem.mdefMax=mMsg:readInt()
	-- 	newItem.hp=mMsg:readInt()
	-- 	newItem.mp=mMsg:readInt()
	-- 	newItem.addPer=mMsg:readInt()
	-- 	if newItem.position<0 then
	-- 		self.mEquipItems[newItem.position] = newItem
	-- 	end
	-- end,

	[NetProtocol.cResKuafuAuth] = function(mMsg)
		local result = mMsg:readInt()
		if result == 100 then
			self:EnterGame(self.kuaFuInfo.charname, game.seedName)
		end
	end,

	[NetProtocol.cNotifyKuafuInfo] = function(mMsg)
		self.kuaFuInfo = {}
		self.kuaFuInfo.ticket			= mMsg:readString()
		self.kuaFuInfo.loginid			= mMsg:readString()
		self.kuaFuInfo.charname			= mMsg:readString()
		self.kuaFuInfo.kuafuip			= mMsg:readString()
		self.kuaFuInfo.kuafuport		= mMsg:readString()
		self.kuaFuInfo.kuafuparam		= mMsg:readString()
		self.kuaFuInfo.ticketseed		= mMsg:readInt()
		self.kuaFuInfo.localip			= mMsg:readString()
		self.kuaFuInfo.localport		= mMsg:readString()
		self.kuaFuInfo.localPTID		= mMsg:readString()
		self.kuaFuInfo.localServerID	= mMsg:readString()
		self.kuaFuInfo.localArea		= mMsg:readString()

		self.kuaFuState = true
		display.replaceScene(SceneKuaFu.new())
	end,

	[NetProtocol.cNotifyKuafuEnterMainServer] = function(mMsg)
		local result = {}
		result.ticket = mMsg:readString();
		result.result = mMsg:readString();
		self:dispatchEvent({name = Notify.EVENT_KUAFU_ENTER_MAIN_SERVER, data = result})
	end,

	[NetProtocol.cResConsignItem] = function (mMsg)
		local ret = mMsg:readInt();
		-- -1:无此物品 0:成功 1:手续费不够 2:绑定物品不可寄售
		self:dispatchEvent({name = Notify.EVENT_CONSIGN_RESULT, ret = ret})
	end,

	[NetProtocol.cResGetConsignableItems] = function (mMsg)
		local param = {}
		param.mType = mMsg:readInt()
		-- param.endIndex = mMsg:readInt()
		param.job = mMsg:readInt()
		param.condition = mMsg:readInt()
		param.count = mMsg:readInt()
		param.items = {}
		for i=1, param.count do
			local ci={}
			ci.mSeedId = mMsg:readInt()
			ci.mIndex = mMsg:readInt()
			ci.mPrice = mMsg:readInt()
			ci.mTimeLeft = mMsg:readInt()
			ci.mTypeID = mMsg:readInt()
			ci.mDuraMax = mMsg:readInt()
			ci.mDuration = mMsg:readInt()
			ci.mItemFlags = mMsg:readInt()
			ci.mLuck = mMsg:readShort()
			ci.mLevel = mMsg:readInt()
			ci.mNumber = mMsg:readInt()
			ci.mAddAC = mMsg:readShort()
			ci.mAddMAC = mMsg:readShort()
			ci.mAddDC = mMsg:readShort()
			ci.mAddMC = mMsg:readShort()
			ci.mAddSC = mMsg:readShort()
			ci.mAddHp = mMsg:readShort()
			ci.mAddMp = mMsg:readShort()
			ci.mUpdAC = mMsg:readShort()
			ci.mUpdMAC = mMsg:readShort()
			ci.mUpdDC = mMsg:readShort()
			ci.mUpdMC = mMsg:readShort()
			ci.mUpdSC = mMsg:readShort()
			ci.mProtect = mMsg:readShort()
			ci.mUpdMaxCount = mMsg:readInt()
			ci.mUpdFailedCount = mMsg:readInt()
			ci.mZLevel = mMsg:readInt()
			ci.mLock = mMsg:readInt()
			table.insert(param.items, ci)
		end
		-- --print("////////", param.mType, param.job, param.condition, param.count, util.encode(param.items))
		self:dispatchEvent({name = Notify.EVENT_CONSIGN_LIST, param = param})
	end,

	[NetProtocol.cResBuyConsignableItem] = function (mMsg)
		local ret = mMsg:readInt();
		local mSeedId = mMsg:readInt();
		-- ret: -1 不存在 1背包放不下 2钱不够 0成功
		if ret == -1 then
			self:alertLocalMsg("该物品不存在", "alert")
		elseif ret == 1 then
			self:alertLocalMsg("背包剩余控件不足", "alert")
		elseif ret == 2 then
			self:alertLocalMsg("钻石不足", "alert")
		elseif ret == 0 then
			self:alertLocalMsg("购买成功", "alert")
		end
		self:dispatchEvent({name = Notify.EVENT_CONSIGN_BUY_RESULT, ret = ret, mSeedId = mSeedId})
	end,

	[NetProtocol.cResTakeBackConsignableItem] = function (mMsg)
		local ret = mMsg:readInt();
		local mSeedId = mMsg:readInt();
		-- ret: -1 不存在 0成功
		self:dispatchEvent({name = Notify.EVENT_TAKE_CONSIGN_RESULT})
	end,

	[NetProtocol.cResTakeBackVCoin] = function (mMsg)
		local ret = mMsg:readInt();
		-- ret: 取回金币数量
		self:dispatchEvent({name = Notify.EVENT_TAKE_VCOIN_RESULT, ret = ret})
	end,

	[NetProtocol.cResGuildRedPacketLog] = function (mMsg)
		local count = mMsg:readInt()
		local logs = {}
		for i=1,count do
			local log = {}
			log.sender = mMsg:readString()
			log.opCode = mMsg:readInt()
			log.vcoin = mMsg:readInt()
			log.num = mMsg:readInt()
			table.insert(logs, log)
		end
		self:dispatchEvent({name = Notify.EVENT_GUILD_HONGBAO_LOGS, logs = logs})
	end,
	[NetProtocol.cNotifyGuildRedPacketLog] = function (mMsg)
		local log = {}
		log.sender = mMsg:readString()
		log.opCode = mMsg:readInt()
		log.vcoin = mMsg:readInt()
		log.num = mMsg:readInt()
		----print("cNotifyGuildRedPacketLog", util.encode(log))
		self:dispatchEvent({name = Notify.EVENT_GUILD_HONGBAO_LOG, log = log})
	end,
	[NetProtocol.cResGuildItemLog] = function (mMsg)
		local count = mMsg:readInt()
		local logs = {}
		for i=1,count do
			local log = {}
			log.name = mMsg:readString()
			log.itemName = mMsg:readString()
			log.opCode = mMsg:readInt()
			log.time = mMsg:readInt()
			table.insert(logs, log)
		end
		-- --print("cResGuildItemLog", count, util.encode(logs))
		self:dispatchEvent({name = Notify.EVENT_GUILD_ITEM_LOGS, logs = logs})
	end,
	[NetProtocol.cNotifyMonExpHiterChange] = function (mMsg)
		local owner = {}
		owner.srcid = mMsg:readInt()
		owner.hiterid = mMsg:readInt()
		owner.name = mMsg:readString()
		self.mMonsterOwner[owner.srcid] = owner
		self:dispatchEvent({name = Notify.EVENT_MONSTER_OWNER_CHANGE, srcid = owner.srcid});
		-- --print("/////////////cNotifyMonExpHiterChange/////////////", util.encode(owner))
	end,
	[NetProtocol.cNotifyMapMonGen] = function (mMsg)
		local mapid = mMsg:readString()
		local size = mMsg:readShort()
		local name,x,y,time
		local thismap = self.mNetMap.mMapID == mapid

		self.mMapMonGenId = ""
		self.mMapMonGen = {}

		if thismap then
			self.mMapMonGenId = mapid
		end
		if size>0 then
			for i=1,size do
				name = mMsg:readString()
				x = mMsg:readShort()
				y = mMsg:readShort()
				time = mMsg:readInt()

				if thismap then
					table.insert(self.mMapMonGen,{name=name,x=x,y=y,time=time})
				end
			end
		end
	end,
	[NetProtocol.cResFindMapGhost] = function (mMsg)
		local mapid = mMsg:readString()
		local monName = mMsg:readString()
		local size = mMsg:readShort()
		local id,x,y,gtype
		local thismap = self.mNetMap.mMapID == mapid
		-- --print("=---------------cResFindMapGhost",mapid)

		self.mMapGhostMapId = ""
		self.mMapGhostList = {}
		self.mMapGhostRes = mapid

		if thismap then
			self.mMapGhostMapId = mapid
		end

		if size>0 then
			for i=1,size do
				id = mMsg:readInt()
				x = mMsg:readShort()
				y = mMsg:readShort()
				gtype = mMsg:readShort()

				if thismap then
					self.mMapGhostList[id] = {id=id,x=x,y=y,gtype=gtype}
				end
			end

			if thismap then
				-- self.mMapGhostReq = nil
				MainRole.setMapGhostList(self.mMapGhostMapId,self.mMapGhostList)
			end
		end

		-- if thismap then
		self.mMapGhostReq = nil
		-- end
	end,
}
end







function NetClient:init()

	--这里存储当前角色所有相关信息

	self:removeAllEventListeners()

	self.mLogicMap=nil
	self.mPingDelay=game.ClockTick

	self.mCharacter={mID=0,mType=Const.GHOST_THIS,mCloth=-1,mWeapon=-1,mMount=-1}
	self.mNetGhosts={}
	self.mItemDesp={}
	self.mUpgradeDesp={}
	self.mFriends={}
	self.mTasks={}
	self.mItems = {}
	self.mParam={}
	self.mPingTime = 0
	self.mPingTick = 0
	self.bagItems = {}

	self.mEquipItems = {}
	self.mGemItems = {}

	self.equipTable = {} --存放10个装备部件强化等级
	self.severDay = 0

	self.mExtendState={}
	self.mBottomState={}
	self.mSwitchState={}

	self.mModels={}
	self.mapOption ={}
	self.mMapConn = {}
	self.mMiniMapConn = {}
	-- self.mSafeData = {}
	self.mMiniNpc = {}
	self.mMapGhostReq = nil
	self.mMapGhostRes = nil
	self.mMapMonGenId = ""
	self.mMapMonGen = {}
	self.mMapGhostMapId = ""
	self.mMapGhostList = {}
	self.mNetMap={mMapID=nil,mLastMapID=nil}

	self.mGuildList = {}
	self.mChartData = {}
	self.mChartType = -1

	self.m_alertListAlert = {}
	self.m_alertListMid = {}
	self.m_alertListBottom = {}
	self.m_alertListPost = {}
	self.m_alertListRight = {}
	self.m_alertListCenterEXP = {}
	self.m_alertListCenterMoney = {}
	self.m_alertListCenterInnerPower = {}
	self.m_alertListMap = {}

	self.mVcoinShopNpcID = -1
	self.mShopNpc = {}
	self.mShopItemInfo = {}
	self.mVcoinShopItem = {}

	self.mGameParam = {}

	self.mChatHistroy = {}
	self.mHornChat = {}

	self.m_skillsDesp = {}

	--专门给技能展示用的
	self.m_skillsDespAngry = {}
	self.m_skillsDespNormal = {}

	self.m_nNpcId = 0
	self.m_nNpcTalkId = 0
	self.m_nItemTalkId = 0
	self.m_strNpcTalkMsg = ""
	self.m_strPrivateChatTarget = ""

	--消息验证
	self.mMoveStep=0
	self.mMoveStepRes=0
	self.mServerDir=0
	self.mServerX=0
	self.mServerY=0
	-- self.mMoveResTime=game.getTime()
	self.mMoveReqX=0
	self.mMoveReqY=0

	self.mSkillSendTag=0
	self.mUseItemSendTag=0

	-- self.mCastSkillTime=game.getTime()

	self.m_nCountDownDelay=0
	self.m_strCountDownMsg=""
	self.m_bLevelChanged=false
	self.m_bAllowInvite=true
	self.m_bGroupPickMode=true
	self.m_strApplyerName = ""
	-- self.m_bIsDisConnect = false
	self.m_bCollecting = false
	self.m_collectTime = 0
	self.m_bReqCollect = false
	self.m_bReqMountUp = false
	self.m_IsBagSellItem = false

	-- self.mStartAutoFight=false
	self.mAttackMode=101
	self.mBagSlotAdd = 0
	self.mDepotSlotAdd = 0
	self.mBagMaxSlot = 0
	self.mWarState = 0
	self.mKingGuild = ""
	self.mKingOfKings = ""
	self.KHcandidate = "" -- 皇宫显示的标志
	self.mXJ_slot_pos = 0  ---镶嵌位置
	self.mXJ_xq_or_hc = 1 ---1镶嵌 2合成
	self.mXJ_xq_data = {} ---镶嵌表

	self.m_IsBagSellItem = false
	self.m_BestSellerNum = 0
	self.m_netSkill = {}
	self.m_skillAddList = {}
	self.m_bBanYueOn = false
	self.m_bCiShaOn = false
	self.m_skillCD = {}
	self.mShortCut = {}
	self.mNetStatus = {}
	self.mStatusDesp = {}

	self.mOthersItems ={}
	self.m_PlayerEquip = {}

	--主角行为相关数据
	self.mLastAimGhost=-1
	self.mChangeAimFirst=false
	self.mCrossAutoMove = false
	self.m_bAutoWalk = false
	self.mLiehuoAction = false
	self.mLiehuoType = 0
	self.mTargetMap = ""
	self.mTargetMapX = 0
	self.mTargetMapY = 0
	self.mCrossMapPath = {}
	self.mSlaveState = 0
	self.mCreateJob = 0
	self.mCreateGender = 0
	-- self.m_AutoMovePos = nil--自动寻路坐标
	-- self.m_AutoMoveFlag = 0--自动寻路类型

	--交易信息
	self.mUiState = false
	self.mChatTradeItemList={}

	self.mTradeInviter=""
	self.mThisChangeItems = {}
	self.mDesChangeItems = {}
	self.mThisTradeItems = {}
	self.mDesTradeItems = {}
	self.mTradeInfo=
	{
		mTradeGameMoney=0,
		mTradeVcoin=0,
		mTradeSubmit=0,
		mTradeTarget="",
		mTradeDesGameMoney=0,
		mTradeDesVcoin=0,
		mTradeDesSubmit=0,
		mTradeDesLevel=0,
		mTradeResult=0,
	}
	self.mVoiceMsg = {}
	---------功能开启---------
	self.m_func = {}
	self.mExtendButtons = {}
	self.mBasicButtons = {}
	self.mAllFuncs = {}
	---------交易记录---------
	self.mTradeRecord = {
		mTradeVcoin = 0,
		mTradeDesVcoin = 0,
		mTradeTarget = "",
	}
	self.mTradeLocalRecord = {}

	---------装备提示面板---------
	self.mSuitLevel = nil

	self.mEquipsSuit = {}
	self.mShengshiList = {}

	self.loginEnded = false
	self.mNeedContinueTask = false
	self.notice = {}
	self.previewData = nil
	self.menuChange = false
	self.PersonBossData = ""
	self.mHuoQiangOpen = false
	self.storyHasRun = {} --已经播放的剧情
	self.mGroupMembers = {}
	self.tipsMsg = {}
	self.chatRecent = {} --本次登录最近联系人

	--技能cd相关
	self.mPublicCDTime = {}
	self.mSkillCDTime = {}

	self.actionMoving = false --移动操作中

	self.mSelectGridSkill = nil -- 需要点击地面释放的技能
	self.mCastGridSkill = nil -- 打开后可持续点击地面释放技能
	self.mCDWaitNextSKill = nil

	self.NetAutoSkills = {} -- 自动释放技能数组
	self.lastCallFriendTime = 0

	self.AlertCheckbox = {}

	self.mNetBuff = {}
	-- self.mBuffDef = {}

	-- 任务目标怪物
	self.mTaskTargetMon = nil
	self.mTaskTargetMap = nil

	self.mMonsterOwner = {}

	self.mExtendHalos = {}

	self.mFuncPreview = {}
	self.itemDailyUseLimit = {}--物品每日限制

	self.mSortFlag = nil

	self.mIsBagShowRedDot = false
	
	self.mMabiFlag = false--mabi
end

function NetClient:ParseMsg(mMsg)--网络P通道
	local type=mMsg:readShort()
	if not NetProtocol.log[type] then
		----print(string.format("msg type: 0x%04X",type))
	elseif type==NetProtocol.cResPing then				--网络Ping值
		if self.mPingTick == 0 then
			self.mPingTick = os.time()
		else
			local pt = os.time() - self.mPingTick
			self.mPingTime = (self.mPingTime + pt)/2/2
			self.mPingTick = os.time()
			if UIRightTop then
				if math.floor(self.mPingTime * 100) >= 10000 then
					UIRightTop.updatePing(10000)
				else
					UIRightTop.updatePing(math.floor(self.mPingTime * 100) )
					--print("ping: "..math.floor(self.mPingTime * 100))
				end
			end
		end
	end

	self.mPingDelay = 0

	if self.NetFunc[type] then
		self.NetFunc[type](mMsg)
	end

end
-------------------------------------------------------------------请求

local function BuildBA(msgid)
	-- --print("---------------BuildBA.msgid: "..msgid)
	local msg=SocketManager:getSendByteArray()
	msg:writeShort(msgid)
	return msg
end

function NetClient:Authenticate(type,session,seed)
	local msg=BuildBA(NetProtocol.cReqAuthenticate)
	msg:writeInt(type)
	msg:writeString(session)
	msg:writeInt(seed)
	msg:writeInt(PlatformTool.getPlatformId())
	msg:writeString((PlatformTool.getConfigString("system_code")))

	self:sendMsg(msg)
end


function NetClient:getNameLen(name)
	local chineseNum, asciiNum = util.getStrLen(name)
	return chineseNum * 2 + asciiNum
end

function NetClient:checkName(name)
	local nameLen = self:getNameLen(name)
	if nameLen > 14 then
		self:alertLocalMsg("名字过长！")
		return
	end

	if util.checkInvalidChar(name) then
		self:alertLocalMsg("名称不得包含非法字符")
		return
	end

	return true
end

function NetClient:ModifyName(chrname, seedname)
	if self:checkName(chrname) then
		local msg = BuildBA(NetProtocol.cReqModifyName)
		msg:writeString(chrname)
		msg:writeString(seedname)

		self:sendMsg(msg)
	end
end

function NetClient:ListCharacter()
	self._reqChar = true
	local msg=BuildBA(NetProtocol.cReqListCharacter)

	msg:writeInt(0)
	self:sendMsg(msg)
end

function NetClient:DeleteCharacter(charname)--删除角色
	local msg=BuildBA(NetProtocol.cReqDeleteCharacter)

	msg:writeString(charname)

	self:sendMsg(msg)
end

function NetClient:EnterGame(charname,sessionid)--进入游戏
	local msg=BuildBA(NetProtocol.cReqEnterGame)

	msg:writeString(charname)
	msg:writeString(sessionid)

	-- if sessionid~="" and PLATFORM_APP_STORE then
	-- 	cc.UserDefault:getInstance():setStringForKey("last_sid",sessionid)
	-- 	cc.UserDefault:getInstance():flush()
	-- end

	self:sendMsg(msg)
end

--[[function NetClient:CreateCharacter(chrname,job,gender,svrid,youke)--创建角色

	if util.checkInvalidChar(chrname) then
		util.showAlert("","名称中包含非法字符","确定")
		return
	end

	youke=youke or ""

	local msg=BuildBA(NetProtocol.cReqCreateCharacter)
	msg:writeString(chrname)
	msg:writeInt(job)
	msg:writeInt(gender)
	msg:writeInt(svrid)
	msg:writeString(youke)

	self:sendMsg(msg)
end]]--

--我暂时还原，你自己会改才替换回去

function NetClient:CreateCharacter(chrname,job,gender,svrid,youke,serverId)

	-- --print("kinyz创建角色")
	if util.checkInvalidChar(chrname) then
		util.showAlert("","名称中包含非法字符","确定")
		return
	end


	youke=youke or ""

	local msg=BuildBA(NetProtocol.cReqCreateCharacter)

	-- msg:writeString("s1".."."..chrname)

	-- local newname = "kinyz_prefix"..chrname --muyi5242095修改创建角色自带标识前缀名
	-- local svrid = serverId
	local newname = "s"..svrid.."."..chrname

		-- --print(newname)
	
	game.charName = newname
	game.chrName = newname
	msg:writeString(newname)
	msg:writeInt(job)
	msg:writeInt(gender)
	msg:writeInt(svrid) --数据库的
	-- msg:writeInt(serverId)
	msg:writeString(youke)
	self:sendMsg(msg)
	
end

--[[

function NetClient:CreateCharacter(chrname,job,gender,svrid,youke)--创建角色

	if util.checkInvalidChar(chrname) then
		util.showAlert("","名称中包含非法字符","确定")
		return
	end

	youke=youke or ""

	local msg=BuildBA(NetProtocol.cReqCreateCharacter)

	msg:writeString(chrname)
	msg:writeInt(job)
	msg:writeInt(gender)
	msg:writeInt(svrid)
	msg:writeString(youke)

	self:sendMsg(msg)
end]]--

function NetClient:Turn(dir)
	local msg=BuildBA(NetProtocol.cReqTurn)
	msg:writeInt(dir)
	-- if MainRole then
	MainRole.mDir = dir
	-- end
	self.mServerDir = dir
	self:sendMsg(msg)
end

function NetClient:UseSkill(skill_type,paramX,paramY,paramID)--使用技能
	-- if self.mCharacter.mDead then return end

	if skill_type == Const.SKILL_TYPE_YiBanGongJi or MainRole.isAttackSkill(skill_type) then
		if MainRole.checkCollect() then return end
	end

	if not game.checkMpEnough(skill_type) then
		return
	end

	-- if self.m_skillCD[skill_type] then return end-- 老版本cd检测
	-- if not game.IsSwitchSkill(skill_type) then
	if not game.checkSkillCD(skill_type, true) then return end -- 新版本cd检测
	-- end

	local curtime = game.getTime()
	local notifyCD = true

	if not game.IsSwitchSkill(skill_type) then
		local mainAvatar = MainRole._mainAvatar or CCGhostManager:getMainAvatar()
		if mainAvatar then
			-- and mainAvatar:PAttr(Const.avatar_state)==Const.STATE_IDLE
			if skill_type==Const.SKILL_TYPE_YiBanGongJi then
				local todir= game.getLogicDirection(cc.p(MainRole.mX,MainRole.mY),cc.p(paramX,paramY))
				if todir ~= MainRole.mDir then
					self:Turn(todir)
					-- mainAvatar:setPAttr(Const.avatar_dir,todir)
				end
			end

			local desp = game.getSkillDesp(skill_type)
			if desp and self.m_netSkill[skill_type] then
				local efftype = desp.mEffectType
				local effres = desp.mEffectResID
				if mainAvatar:NetAttr(Const.net_job) == Const.JOB_ZS then
					efftype = 10
					effres = 0
					if skill_type == Const.SKILL_TYPE_LieHuoJianFa or
						skill_type == Const.SKILL_TYPE_PoTianZhan or
						skill_type == Const.SKILL_TYPE_ZhuRiJianFa or
						skill_type == Const.SKILL_TYPE_YeManChongZhuang then

					-- elseif mainAvatar:NetAttr(Const.net_weapon) > 0 then
					else
						efftype = 0
						local temp_skill = MainRole.getWarriorSkill()
						-- local skillcd, _p = game.getSkillCDTime(skill_type)
						if self.mLiehuoAction and self.mLiehuoType > 0 and MainRole.canCastLieHuo() then -- skillcd+self.mSkillCDTime[self.mLiehuoType] <= curtime
							desp = game.getSkillDesp(self.mLiehuoType)
							if desp then
								efftype = 10
								effres = desp.mEffectResID

								self:dispatchEvent({name=Notify.EVENT_SKILL_COOLDOWN,type=self.mLiehuoType})

								self.mLiehuoAction = false
								self.mLiehuoType = 0
								notifyCD = false
							end
						elseif temp_skill ~= Const.SKILL_TYPE_YiBanGongJi then
							desp = game.getSkillDesp(temp_skill)
							if desp then
								efftype = 10
								effres = desp.mEffectResID
							end
						elseif temp_skill == Const.SKILL_TYPE_YiBanGongJi then
							efftype = 10
							effres = 10000
						end

						if mainAvatar:NetAttr(Const.net_gender) == Const.SEX_MALE then
							if effres == 10100 then effres = 10110 end
							if effres == 10120 then effres = 10130 end
							if effres == 10200 then effres = 10210 end
							if effres == 10220 then effres = 10230 end
							if effres == 10310 then effres = 10320 end
						end
						--print("=================>>>>>>skill_type",skill_type,efftype,effres)
						mainAvatar:actionUseSkill(efftype,paramX,paramY,paramID,effres,self.m_netSkill[skill_type].mLevel)
					end
				else
					mainAvatar:actionUseSkill(efftype,paramX,paramY,paramID,effres,self.m_netSkill[skill_type].mLevel)
				end
			end
		end
	end

	local mSkillCD, mPublicCD = game.getSkillCDTime(skill_type)
	self.mPublicCDTime[mPublicCD] = curtime
	self.mSkillCDTime[skill_type] = curtime

	self.mSkillSendTag=self.mSkillSendTag+1

	if not game.IsSwitchSkill(skill_type) and notifyCD then
		-- --print("-------------================,Notify.EVENT_SKILL_COOLDOWN")
		self:dispatchEvent({name=Notify.EVENT_SKILL_COOLDOWN,type=skill_type})
	end

	--主线变装怪物后攻击目换常装

	if MainRole then MainRole.checkMonKilled(paramID) end

	-- --print("=========================================use skill "..skill_type)

	local msg=BuildBA(NetProtocol.cReqUseSkill)  -- 服务器发送消息，施放技能
	msg:writeInt(skill_type)
	msg:writeInt(paramX)
	msg:writeInt(paramY)
	msg:writeUInt(paramID)
	msg:writeInt(self.mSkillSendTag)
	msg:writeInt(game.getSkipTime())
	self:sendMsg(msg)
end

function NetClient:GetItemDesp(typeid,itemName)
	local msg=BuildBA(NetProtocol.cReqGetItemDesp)
	msg:writeInt(typeid)
	msg:writeString(itemName)
	self:sendMsg(msg)
end

function NetClient:setExtendState(ext_name,state)--设置扩展状态
	self.mExtendState[ext_name]=state
	self:dispatchEvent({name=Notify.EVENT_GUI_STATE})
end

function NetClient:CountDownFinish()--倒计时完成
	local msg=BuildBA(NetProtocol.cCountDownFinish)
	self:sendMsg(msg)
end



function NetClient:ChangeAttackMode(attack_mode)--更改攻击模式
	if table.indexof(self.PKMapIds, self.mNetMap.mMapID) then
		return self:alertLocalMsg("PK战场不可以切换攻击模式", "alert")
	end

	-- if attack_mode == 105 then--
	-- 	self:alertLocalMsg("非PK地图不可切换至阵营模式", "alert")
	-- 	return
	-- end

	local msg=BuildBA(NetProtocol.cReqChangeAttackMode)
	msg:writeInt(attack_mode)
	self:sendMsg(msg)
end

function NetClient:CreateGroup(flags)--创建队伍
	local msg=BuildBA(NetProtocol.cReqCreateGroup)
	msg:writeInt(flags)
	self:sendMsg(msg)
end

function NetClient:LeaveGroup()--离开队伍
	local msg=BuildBA(NetProtocol.cReqLeaveGroup)
	self:sendMsg(msg)
end

function NetClient:PickUp(itemid,x,y)--拾取
	local msg=BuildBA(NetProtocol.cReqPickUp)
	msg:writeInt(itemid)
	msg:writeInt(x or 0)
	msg:writeInt(y or 0)
	self:sendMsg(msg)
end

function NetClient:FriendChange(name,title)--好友改变
	local msg=BuildBA(NetProtocol.cReqFriendChange)
	msg:writeString(name)
	msg:writeInt(title)
	self:sendMsg(msg)
end

function NetClient:FriendApplyAgree(name,agree)--1 同意 0 拒绝
	local msg=BuildBA(NetProtocol.cReqFriendApplyAgree)
	msg:writeString(name)
	msg:writeInt(agree)
	self:sendMsg(msg)
end

function NetClient:FriendFresh()--新好友
	local msg=BuildBA(NetProtocol.cReqFriendFresh)
	self:sendMsg(msg)
end

function NetClient:ListGuild(tag)--行会名单
	local msg=BuildBA(NetProtocol.cReqListGuild)
	msg:writeInt(tag)
	self:sendMsg(msg)
end

function NetClient:GetGuildInfo(guild_name,flags)--获取帮会信息
	local msg = BuildBA(NetProtocol.cReqGetGuildInfo)
	msg:writeString(guild_name)
	msg:writeInt(flags)
	self:sendMsg(msg)
end

function NetClient:SetGuildInfo(guild_name,desp,notice)--设置公会信息

	if util.checkInvalidChar(guild_name) then
		util.showAlert("","名称中包含非法字符","确定")
		return
	end

	if util.checkInvalidChar(desp) then
		util.showAlert("","文字中包含非法字符","确定")
		return
	end

	if util.checkInvalidChar(notice) then
		util.showAlert("","文字中包含非法字符","确定")
		return
	end

	local msg = BuildBA(NetProtocol.cReqSetGuildInfo)
	msg:writeString(guild_name)
	msg:writeString(desp)
	msg:writeString(notice)
	self:sendMsg(msg)
end

function NetClient:CreateGuild(guild_name,flags)--创建行会

	if util.checkInvalidChar(guild_name) then
		util.showAlert("","名称中包含非法字符","确定")
		return
	end

	local msg = BuildBA(NetProtocol.cReqCreateGuild)
	msg:writeString(guild_name)
	msg:writeInt(flags)
	self:sendMsg(msg)
end

function NetClient:JoinGuild(guild_name,flags)--加入行会
	local msg = BuildBA(NetProtocol.cReqJoinGuild)
	msg:writeString(guild_name)
	msg:writeInt(flags)
	self:sendMsg(msg)
end

function NetClient:ListGuildMember(guild_name,list_type)--行会成员列表
	local msg = BuildBA(NetProtocol.cReqListGuildMember)
	msg:writeString(guild_name)
	msg:writeInt(list_type)
	self:sendMsg(msg)
end

function NetClient:ChangeGuildMemberTitle(guild_name,nick_name,dir)--更改行会成员头衔
	local msg = BuildBA(NetProtocol.cReqChangeGuildMemberTitle)
	msg:writeString(guild_name)
	msg:writeString(nick_name)
	msg:writeInt(dir)
	self:sendMsg(msg)
end

function NetClient:LeaveGuild(guild_name)--离开行会
	local msg = BuildBA(NetProtocol.cReqLeaveGuild)
	msg:writeString(guild_name)
	if self.mCharacter.num_enter and self.mCharacter.num_enter > 0 then
		self.mCharacter.num_enter = self.mCharacter.num_enter - 1
	end
	self:sendMsg(msg)
end

function NetClient:CheckPlayerEquip( strName )--检查玩家装备
	self.mOthersItems = {}
	self.checkTargetName = strName
	self:InfoPlayer(strName)
end

function NetClient:check_better_item(position, skiplevel)--检查更好的物品
	local ni
	if util.isTable(position) then
		ni = self:getItemDefByID(position.mTypeID)
	elseif util.isNumber(position) then
		ni = self:getNetItem(position);
	end
	if ni and MainRole._mainAvatar then
		if ni and ni.mTypeID then
			local item_define = self:getItemDefByID(ni.mTypeID);
			if item_define then
				if item_define.mJob == 0 or item_define.mJob == MainRole._mainAvatar:NetAttr(Const.net_job) then
					if not skiplevel and (item_define.mNeedParam > MainRole._mainAvatar:NetAttr(Const.net_level) or item_define.mNeedZsLevel > MainRole._mainAvatar:NetAttr(Const.net_zslevel)) then
						return;
					end
					local better = true;

					for i,v in pairs(self.mItems) do
						if v.position < 0 then
							local id = self:getItemDefByID(v.mTypeID);
							if id and id.mEquipType == item_define.mEquipType then
								if not game.IsRing(v.mTypeID) and not game.IsGlove(v.mTypeID) then
									if id.mNeedParam > item_define.mNeedParam then
										better = false;
									end
								elseif game.IsRing(v.mTypeID) then
									local ring1 = self:getNetItem(Const.ITEM_RING1_POSITION)
									local ring2 = self:getNetItem(Const.ITEM_RING2_POSITION)
									if ring1 and ring2 then
										local ringDef1 = self:getItemDefByID(ring1.mTypeID)
										local ringDef2 = self:getItemDefByID(ring2.mTypeID)
										if ringDef1.mNeedParam > item_define.mNeedParam and ringDef2.mNeedParam > item_define.mNeedParam then
											better = false;
										end
									end
								elseif game.IsGlove(v.mTypeID) then
									local glove1 = self:getNetItem(Const.ITEM_GLOVE1_POSITION)
									local glove2 = self:getNetItem(Const.ITEM_GLOVE2_POSITION)
									if glove1 and glove2 then
										local gloveDef1 = self:getItemDefByID(glove1.mTypeID)
										local gloveDef2 = self:getItemDefByID(glove2.mTypeID)
										if gloveDef1.mNeedParam > item_define.mNeedParam and gloveDef2.mNeedParam > item_define.mNeedParam then
											better = false;
										end
									end
								end
							end
						end
					end
					if better then
						local betterType,posInAvatar1, posInAvatar2 = game.isBetterInAvatar(position)
						if betterType == Const.ITEM_BETTER_SELF then
							return better, posInAvatar1, posInAvatar2
						end
					end
				end
			end
		end
	end
end

function NetClient:InfoPlayer(player_name)--玩家信息
	local msg = BuildBA(NetProtocol.cReqInfoPlayer)
	self.m_PlayerEquip[player_name] = {}
	self.other_avatar_save = "loaded"
	msg:writeString(player_name)
	self:sendMsg(msg)
end

function NetClient:GetChartInfo(chart_type,page)--获取排行信息
	local msg = BuildBA(NetProtocol.cReqGetChartInfo)
	msg:writeInt(chart_type)
	msg:writeInt(page)
	self:sendMsg(msg)
end

function NetClient:StartCollect(id)
	if self.m_bReqMountUp then return end

	-- --print("NetClient:StartCollect",id)

	if not self.m_bCollecting and not self.m_bReqCollect then
		self.m_bReqCollect = true

		local monster=CCGhostManager:getPixesGhostByID(id)
		if monster then
			local todir= game.getLogicDirection(cc.p(MainRole.mX,MainRole.mY),cc.p(monster:NetAttr(Const.net_x),monster:NetAttr(Const.net_y)))
			if todir~=MainRole.mDir then
				self:Turn(todir)
				if MainRole._mainAvatar then
					MainRole._mainAvatar:setPAttr(Const.avatar_dir,todir)
				end
			end
		end

		local msg = BuildBA(NetProtocol.cReqCollectStart)
		msg:writeInt(id)
		self:sendMsg(msg)
	end
end

function NetClient:VcoinShopList(shop_id,flags)
	local msg = BuildBA(NetProtocol.cReqVcoinShopList)
	msg:writeInt(shop_id)
	msg:writeInt(flags)
	self:sendMsg(msg)
end

function NetClient:NPCSell(npc_id,pos,type_id,number,flag)
	local msg = BuildBA(NetProtocol.cReqNPCSell)
	msg:writeInt(npc_id)
	msg:writeInt(pos)
	msg:writeInt(type_id)
	msg:writeInt(number)
	msg:writeInt(flag)
	self:sendMsg(msg)
end

function NetClient:UndressItem(position)--卸下
	local msg = BuildBA(NetProtocol.cReqUndressItem)
	msg:writeInt(position)
	self:sendMsg(msg)
end

function NetClient:ItemPositionExchange(from,to)
	local msg = BuildBA(NetProtocol.cReqItemPositionExchange)
	msg:writeInt(from)
	msg:writeInt(to)
	msg:writeInt(0)
	self:sendMsg(msg)
end
--交易
function NetClient:TradeAddItem(pos,type_id,price,flag) --flag 0：面对面交易 ,1:聊天交易上架， 2：下架
	local msg = BuildBA(NetProtocol.cReqTradeAddItem)
	msg:writeInt(pos)
	msg:writeInt(type_id)
	msg:writeInt(price)
	msg:writeInt(flag)
	self:sendMsg(msg)
end

function NetClient:TradeSubItem(pos,type_id)
	NetClient:TradeAddItem(pos,type_id,0,2)
end

function NetClient:TradeBuyItem(chrName,pos,type_id,lock,flag)--flag=1 购买，2 请求物品信息
	local msg = BuildBA(NetProtocol.cReqTradeBuyItem)
	msg:writeString(chrName)
	msg:writeInt(pos)
	msg:writeInt(type_id)
	msg:writeInt(lock)
	msg:writeInt(flag)
	self:sendMsg(msg)
end

function NetClient:BagUseItemByType(type_id)
	for pos = Const.ITEM_BAG_BEGIN, Const.ITEM_BAG_SIZE + self.mBagSlotAdd - 1 do
		local netItem = self:getNetItem(pos)

		if netItem and netItem.mTypeID == type_id then
			self:BagUseItem(pos,type_id)
			return true
		end
	end
end

function NetClient:BagUseItem(position,type_id,num)
	if game.IsGem(type_id) then
		self:dispatchEvent({name=Notify.EVENT_OPEN_PANEL,str="main_avatar", tab = 7, mParam = {tab=7,index=7}})
		return
	end
	if type_id ==33070023 then--物品id
				local param = {
				name = Notify.EVENT_SHOW_TIPS,
				str = "confirm2",
				noAutoClose = true,
				confirmCallBack = function (inputText)
				self:checkAndCreate(inputText)
				self:dispatchEvent({name = Notify.EVENT_HIDE_TIPS,str = "confirm2"})	
				end
			}
			self:dispatchEvent(param)
		return
	end
	if game.useItemOpen(type_id) or util.useItemOpen(type_id) then return end
	--  装备强化继承 人生如戏
	if game.checkEquipDress(position) then
		if UIQuickSuccession.useCheckJiCheng(position) then return end
	end
	
	local num = num or 1
	local msg = BuildBA(NetProtocol.cReqBagUseItem)
	msg:writeInt(position)
	msg:writeInt(type_id)
	msg:writeInt(num)
	self.mUseItemSendTag = self.mUseItemSendTag + 1
	msg:writeInt(self.mUseItemSendTag)
	self:sendMsg(msg)
	--喝药音效
end

function NetClient:checkAndCreate(str)
	local firstillegal = string.find(str,"[@%~%^%<%>]")
	if firstillegal then
		util.showAlert("","名称中包含非法字符","确定")
		return
	end

	local vaild = false
	if str and str~="" and #str>0 then
		local clen,elen = util.getStrLen(str)
		if (clen*2+elen)<11 then
			vaild = true
		end
	end
	----print("str=",str)
	----print("vaild=",vaild)
	if vaild then
		NetClient:PushLuaTable("item.gaiming.gname",str)
	else
		NetClient:alertLocalMsg("名称长度不符合要求！", "alert")
	end
end

function NetClient:AddBagSlot()--开背包格子
	local msg = BuildBA(NetProtocol.cReqAddBagSlot)
	self:sendMsg(msg)
end

function NetClient:AddDepotSlot()--开仓库格子
	local msg = BuildBA(NetProtocol.cReqAddDepotSlot)
	self:sendMsg(msg)
end

function NetClient:DropItem(pos,type_id,number)--删除项目
	local msg = BuildBA(NetProtocol.cReqDropItem)
	msg:writeInt(pos)
	msg:writeInt(type_id)
	msg:writeInt(number)
	self:sendMsg(msg)
end

function NetClient:SortItem(flag)--整理

	PlayAudio.play("sound/bagsort.mp3")

	local msg = BuildBA(NetProtocol.cReqSortItem)
	msg:writeInt(flag)
	self:sendMsg(msg)

	self.mSortFlag = flag
end

function NetClient:PushLuaTable(type,table)
	local msg = BuildBA(NetProtocol.cReqPushLuaTable)
	msg:writeString(type)
	msg:writeString(table)
	self:sendMsg(msg)
end

function NetClient:DirectFly(fly_id)--传送
	local msg = BuildBA(NetProtocol.cReqDirectFly)
	msg:writeInt(fly_id)
	self:sendMsg(msg)
end

function NetClient:ServerScript(param)  --执行服务器lua脚本,处理相关逻辑
	local msg = BuildBA(NetProtocol.cReqServerScript)
	msg:writeString(param)
	self:sendMsg(msg)
end

function NetClient:NpcTalk(npcid,param)--NPC对话
	self.m_nNpcTalkId = 0
	self.m_strNpcTalkMsg = ""

	local msg = BuildBA(NetProtocol.cReqNPCTalk)
	msg:writeUInt(npcid)
	msg:writeString(param)
	self:sendMsg(msg)
end

function NetClient:PlayerTalk(seed,param)--玩家对话
	local msg = BuildBA(NetProtocol.cReqPlayerTalk)
	msg:writeInt(seed)
	msg:writeString(param)
	self:sendMsg(msg)
end

function NetClient:ItemTalk(itemid,seed,param)--物品对话
	local msg = BuildBA(NetProtocol.cReqItemTalk)
	msg:writeInt(itemid)
	msg:writeInt(seed)
	msg:writeString(param)
	self:sendMsg(msg)
end

function NetClient:NormalChat(msgstr)--普通聊天
	if string.len(msgstr) > 511 then
		self:alertLocalMsg(Const.str_msg_too_long, "alert")
		return
	end
	if util.checkInvalidChar(msgstr,true) then
		self:alertLocalMsg("请不要发送非法字符", "alert")
		return
	end
	self.lastChatChannel = Const.str_chat_near

	local msg = BuildBA(NetProtocol.cReqNormalChat)
	msg:writeString(msgstr)
	self:sendMsg(msg)
end

function NetClient:MapChat(msgstr)--地图聊天
	if string.len(msgstr) > 511 then
		self:alertLocalMsg(Const.str_msg_too_long, "alert")
		return
	end
	if util.checkInvalidChar(msgstr,true) then
		self:alertLocalMsg("请不要发送非法字符", "alert")
		return
	end

	local msg = BuildBA(NetProtocol.cReqMapChat)
	msg:writeString(msgstr)
	self:sendMsg(msg)
end


function NetClient:PrivateChat(target,msgstr)--私聊
	if string.len(msgstr) > 511 then
		self:alertLocalMsg(Const.str_msg_too_long, "alert")
		return
	end
	if util.checkInvalidChar(msgstr,true) then
		self:alertLocalMsg("请不要发送非法字符", "alert")
		return
	end
	self.lastChatChannel = Const.str_chat_private

	local msg = BuildBA(NetProtocol.cReqPrivateChat)
	msg:writeString(target)
	msg:writeString(msgstr)
	self:sendMsg(msg)
end

function NetClient:WorldChat(msgstr)--世界聊天
	if string.len(msgstr) > 511 then
		self:alertLocalMsg(Const.str_msg_too_long, "alert")
		return
	end
	if util.checkInvalidChar(msgstr,true) then
		self:alertLocalMsg("请不要发送非法字符", "alert")
		return
	end

	self.lastChatChannel = Const.str_chat_world

	self.WorldChatTime = self.WorldChatTime or 0
	if os.time() - self.WorldChatTime <10 then
		return self:alertLocalMsg(string.format("距下次世界频道发言%d秒",self.WorldChatTime +10-os.time()), "alert")
	end
	self.WorldChatTime = os.time()
	local msg = BuildBA(NetProtocol.cReqWorldChat)
	msg:writeString(msgstr)
	self:sendMsg(msg)
end

function NetClient:HornChat(msgstr)--号角聊天
	if string.len(msgstr) > 256 then
		self:alertLocalMsg(Const.str_msg_too_long, "alert")
		return
	end
	if util.checkInvalidChar(msgstr,true) then
		self:alertLocalMsg("请不要发送非法字符", "alert")
		return
	end

	self.lastChatChannel = Const.str_chat_private
	local msg = BuildBA(NetProtocol.cReqHornChat)
	msg:writeString(msgstr)
	self:sendMsg(msg)
end

function NetClient:GuildChat(msgstr)--行会聊天
	if string.len(msgstr) > 511 then
		self:alertLocalMsg(Const.str_msg_too_long, "alert")
		return
	end
	if util.checkInvalidChar(msgstr,true) then
		self:alertLocalMsg("请不要发送非法字符", "alert")
		return
	end
	self.lastChatChannel = Const.str_chat_guild

	local msg = BuildBA(NetProtocol.cReqGuildChat)
	msg:writeString(msgstr)
	self:sendMsg(msg)
end

function NetClient:GroupChat(msgstr)--组队聊天
	if string.len(msgstr) > 511 then
		self:alertLocalMsg(Const.str_msg_too_long, "alert")
		return
	end
	if util.checkInvalidChar(msgstr,true) then
		self:alertLocalMsg("请不要发送非法字符", "alert")
		return
	end
	self.lastChatChannel = Const.str_chat_group

	local msg = BuildBA(NetProtocol.cReqGroupChat)
	msg:writeString(msgstr)
	self:sendMsg(msg)
end
function NetClient:sendChatToLastChannel(msg)--将聊天发送到最后一个频道
	if self.lastChatChannel == Const.str_chat_group then
		self:GroupChat(msg)
	elseif self.lastChatChannel == Const.str_chat_guild then
		self:GuildChat(msg)
	elseif self.lastChatChannel == Const.str_chat_private then
		self:PrivateChat(msg)
	elseif self.lastChatChannel == Const.str_chat_near then
		self:MapChat(msg)
	else
		self:WorldChat(msg)
	end
end
-- function NetClient:UpgradeEquip(posEquip,posSteel,posAdd,pay_type)
-- 	local msg = BuildBA(NetProtocol.cReqUpgradeEquip)
-- 	self.m_upgradeFlag = false
-- 	msg:writeInt(posEquip)
-- 	msg:writeInt(posSteel)
-- 	msg:writeInt(posAdd)
-- 	msg:writeInt(pay_type)
-- 	self:sendMsg(msg)
-- end

-- function NetClient:MergeSteel(pos1,pos2,pos3,posAdd,pay_type)
-- 	local msg = BuildBA(NetProtocol.cReqMergeSteel)
-- 	msg:writeInt(pos1)
-- 	msg:writeInt(pos2)
-- 	msg:writeInt(pos3)
-- 	msg:writeInt(posAdd)
-- 	msg:writeInt(pay_type)
-- 	self:sendMsg(msg)
-- end

-- function NetClient:EquipExchangeUpgrade(posFrom,posTo,posAdd,pay_type)
-- 	local msg = BuildBA(NetProtocol.cReqEquipExchangeUpgrade)
-- 	msg:writeInt(posFrom)
-- 	msg:writeInt(posTo)
-- 	msg:writeInt(posAdd)
-- 	msg:writeInt(pay_type)
-- 	self:sendMsg(msg)
-- end

-- function NetClient:SteelEquip(pos,type_id)
-- 	local msg = BuildBA(NetProtocol.cReqSteelEquip)
-- 	msg:writeInt(pos)
-- 	msg:writeInt(type_id)
-- 	self:sendMsg(msg)
-- end

-- function NetClient:EquipReRandAdd(posEquip,posAdd)
-- 	local msg = BuildBA(NetProtocol.cReqEquipReRandAdd)
-- 	msg:writeInt(posEquip)
-- 	msg:writeInt(posAdd)
-- 	self:sendMsg(msg)
-- end

function NetClient:SplitItem(pos,id,num)--拆分物品
	local msg = BuildBA(NetProtocol.cReqSplitItem)
	msg:writeInt(pos)
	msg:writeInt(id)
	msg:writeInt(num)
	self:sendMsg(msg)
end

function NetClient:UpdateTicket()--更新
	local msg = BuildBA(NetProtocol.cReqUpdateTicket)
	self:sendMsg(msg)
end

function NetClient:NpcBuy(id,num)--购买
	if self.mShopNpc then
		local itemdef = self:getItemDefByID(self.mShopItemInfo[id].type_id)
		--print("shop========",self.mShopItemInfo[id].type_id,itemdef.mStackMax)
		if itemdef and self:getLeftBagNum() >= math.ceil(num/itemdef.mStackMax) then
			local msg = BuildBA(NetProtocol.cReqNPCBuy)
			msg:writeUInt(self.mShopNpc.srcid)
			msg:writeInt(self.mShopNpc.page)
			msg:writeInt(self.mShopItemInfo[id].pos)
			msg:writeInt(self.mShopItemInfo[id].good_id)
			msg:writeInt(self.mShopItemInfo[id].type_id)
			msg:writeInt(num)
			self:sendMsg(msg)
		else
			self:alertLocalMsg("背包格子不足！", "alert")
		end
	end
end

function NetClient:VcoinShopBuy(id,num)--商店购买
	if #self.mVcoinShopItem <= 0 or self.mVcoinShopNpcID < 0 then
		self.VcoinShopList(0,0)
		return
	end
	local msg = BuildBA(NetProtocol.cReqNPCBuy)
	msg:writeUInt(self.mVcoinShopNpcID)
	msg:writeInt(0)
	msg:writeInt(self.mShopItemInfo[id].pos)
	msg:writeInt(self.mShopItemInfo[id].good_id)
	msg:writeInt(self.mShopItemInfo[id].type_id)
	msg:writeInt(num)
	self:sendMsg(msg)
end

function NetClient:InviteGroup(name)--邀请组队
	if checkint(self.mCharacter.mGroupID) == 0 then
		self:CreateGroup(0)
	end
	local msg = BuildBA(NetProtocol.cReqInviteGroup)
	msg:writeString(name)
	self:sendMsg(msg)
end

function NetClient:JoinGroup(group_id)--加入组队
	local msg = BuildBA(NetProtocol.cReqJoinGroup)
	msg:writeInt(group_id)
	self:sendMsg(msg)
end

function NetClient:GroupKickMember(name)--踢出队伍
	local msg = BuildBA(NetProtocol.cReqGroupKickMember)
	msg:writeString(name)
	self:sendMsg(msg)
end

function NetClient:GroupSetLeader(name)--设置队长
	local msg = BuildBA(NetProtocol.cReqGroupSetLeader)
	msg:writeString(name)
	self:sendMsg(msg)
end

function NetClient:TradeInvite(name)--请求交易
	local msg = BuildBA(NetProtocol.cReqTradeInvite)
	msg:writeString(name)
	self:sendMsg(msg)
end

function NetClient:AgreeTradeInvite(inviter)--同意交易
	local msg = BuildBA(NetProtocol.cReqAgreeTradeInvite)
	msg:writeString(inviter)
	self:sendMsg(msg)
end

function NetClient:TradeSubmit()--交易提交
	local msg = BuildBA(NetProtocol.cReqTradeSubmit)
	self:sendMsg(msg)
end

function NetClient:CloseTrade()--交易完成-关闭交易
	local target = self.mTradeInviter
	self.mTradeInviter=""
	self.mThisChangeItems = {}
	self.mDesChangeItems = {}
	self.mThisTradeItems = {}
	self.mDesTradeItems = {}

	self.mTradeInfo.mTradeGameMoney=0
	self.mTradeInfo.mTradeVcoin=0
	self.mTradeInfo.mTradeSubmit=0
	self.mTradeInfo.mTradeTarget=""
	self.mTradeInfo.mTradeDesGameMoney=0
	self.mTradeInfo.mTradeDesVcoin=0
	self.mTradeInfo.mTradeDesSubmit=0
	self.mTradeInfo.mTradeDesLevel=0

	self.mTradeRecord = {
		mTradeVcoin = 0,
		mTradeDesVcoin = 0,
		mTradeTarget = "",
	}

	--if self.mTradeInfo.mTradeResult == 1 then
		local msg = BuildBA(NetProtocol.cReqCloseTrade)
		msg:writeString(target)
		self:sendMsg(msg)
	--end

end

function NetClient:TradeAddVcoin(num)--元宝交易
	local msg = BuildBA(NetProtocol.cReqTradeAddVcoin)
	msg:writeInt(num)
	self:sendMsg(msg)
end

function NetClient:TradeAddGameMoney(num)--金币交易
	local msg = BuildBA(NetProtocol.cReqTradeAddGameMoney)
	msg:writeInt(num)
	self:sendMsg(msg)
end

function NetClient:AgreeInviteGroup(name,id)--同意组队邀请
	local msg = BuildBA(NetProtocol.cReqAgreeInviteGroup)
	msg:writeString(name)
	msg:writeInt(id)
	self:sendMsg(msg)
end

function NetClient:AgreeJoinGroup(name)--同意加入组队
	local msg = BuildBA(NetProtocol.cReqAgreeJoinGroup)
	msg:writeString(name)
	self:sendMsg(msg)
end

function NetClient:DestoryItem(pos,id)--销毁物品
	local msg = BuildBA(NetProtocol.cReqDestoryItem)
	msg:writeInt(pos)
	msg:writeInt(id)
	self:sendMsg(msg)
end

function NetClient:NpcShop(npc_id,page)--NPC商店

	local msg = BuildBA(NetProtocol.cReqNPCShop)
	msg:writeUInt(npc_id)
	msg:writeInt(page)
	self:sendMsg(msg)
end

function NetClient:SaveShortcut(notDispatch)--保存快捷方式
	local numSkill = 0
	local msg = BuildBA(NetProtocol.cReqSaveShortcut)
	for i=1,16 do
		if self.mShortCut[i] and self.mShortCut[i].param ~= 0 then
			numSkill = numSkill + 1
		end
	end
	msg:writeInt(numSkill)
	for i=1,16 do
		if self.mShortCut[i] and self.mShortCut[i].param ~= 0 then
			msg:writeInt(self.mShortCut[i].cut_id)
			msg:writeInt(self.mShortCut[i].type)
			msg:writeInt(self.mShortCut[i].param)
		end
	end
	self:sendMsg(msg)
	if not notDispatch then
		self:dispatchEvent({name = Notify.EVENT_SET_SHORTCUT})
	end
end

function NetClient:ChangeMount()
	if self.m_bReqMountUp then return end
	local msg = BuildBA(NetProtocol.cReqChangeMount)
	self:sendMsg(msg)
end
function NetClient:freshHPMP()
	local msg = BuildBA(NetProtocol.cReqFreshHPMP)
	self:sendMsg(msg)
end

function NetClient:Relive(type)
	local msg = BuildBA(NetProtocol.cReqRelive)
	msg:writeInt(type)
	self:sendMsg(msg)
end

function NetClient:GuildReperotry()--行会仓库
	local msg = BuildBA(NetProtocol.cReqListGuildDepot)
	self:sendMsg(msg)
end

function NetClient:getMails()--获取邮件
	local msg = BuildBA(NetProtocol.cReqGetMails)
	self:sendMsg(msg)

end

function  NetClient:checkMailRedPoint()
	local flag=false
	for i=1,#self.mails do
	-- if (#singleMail.item > 0 and singleMail.isReceive == 0) or (#singleMail.item == 0 and singleMail.isOpen == 0) then
		if (self.mails[i].isReceive==0 and #self.mails[i].item>0) or (self.mails[i].isOpen==0 and #self.mails[i].item==0)  then
			flag=true
			break
		else
			flag=false
		end
	end
	if flag then
		self:dispatchEvent({name = Notify.EVENT_SHOW_REDPOINT, lv = 2051,index =1})
	else
		self:dispatchEvent({name = Notify.EVENT_REMOVE_REDPOINT, lv = 2051,index = 1})
	end
end

function NetClient:checkSkillRedPoint(netSkill2)
	local show = false
	for k,v in pairs(self.m_netSkill) do
		local netSkill=v
		if netSkill.mTypeID~=100 then --不计算普通攻击
			if not MainRole or not MainRole._mainAvatar then return end
			local curLevel = MainRole._mainAvatar:NetAttr(Const.net_level)
			local nsd = game.getSkillDesp(netSkill.mTypeID)
			if curLevel>=netSkill.mLevel and netSkill.mExp>=nsd.mNeedExp and netSkill.mExp>0 then
				-- self:dispatchEvent({name = Notify.EVENT_SHOW_REDPOINT, lv = 2022,index =1})
				self.skillRed[netSkill.mTypeID]=true
				show = true
				-- break
			else
				-- self:dispatchEvent({name = Notify.EVENT_REMOVE_REDPOINT, lv = 2022,index = 1})
				self.skillRed[netSkill.mTypeID]=false
			end
		end
	end

	if show then
		self:dispatchEvent({name = Notify.EVENT_SHOW_REDPOINT, lv = 2022,index =1})
	else
		self:dispatchEvent({name = Notify.EVENT_REMOVE_REDPOINT, lv = 2022,index = 1})
	end
end

function NetClient:readMail(mailId)
	local msg = BuildBA(NetProtocol.cReqOpenMail)
	msg:writeString(mailId)
	self:sendMsg(msg)
	self:checkMailRedPoint()-----主面板红点
end

function NetClient:getMailAward(mailId)
	local msg = BuildBA(NetProtocol.cReqReceiveMailItems)
	msg:writeString(mailId)
	self:sendMsg(msg)
end

function NetClient:deleteMail(mailId)
	local msg = BuildBA(NetProtocol.cReqDeleteMail)
	msg:writeInt(1)
	-- for i,v in ipairs(self.mails) do
		msg:writeString(mailId)
	-- end
	self:sendMsg(msg)
end

function NetClient:KuafuAuth(result)
	local msg = BuildBA(NetProtocol.cReqKuafuAuth)
	msg:writeString(result.ticket)
	msg:writeString(result.loginid)
	msg:writeString(result.charname)
	msg:writeString(result.kuafuip)
	msg:writeString(result.kuafuport)
	msg:writeString(result.localip)
	msg:writeString(result.localport)
	msg:writeString(result.kuafuparam)
	msg:writeInt(result.ticketseed)
	msg:writeString(result.localPTID)
	msg:writeString(result.localServerID)
	msg:writeString(result.localArea)
	self:sendMsg(msg)
end
--寄售
function NetClient:consignItem(result)
	local msg = BuildBA(NetProtocol.cReqConsignItem)
	msg:writeInt(result.pos)
	msg:writeInt(result.num)
	msg:writeInt(result.price)
	msg:writeInt(result.time)
	self:sendMsg(msg)
end

-- int type; // 0:全部 1:装备 2:药品 3:材料 4:其他 5:自己
-- 	int begin_index; // 开始查找索引
-- 	int job; // 职业
-- 	int condition; // 筛选条件
-- 0 全部 1:0-80 2:80-2转 3:2转以上
--请求寄售列表
function NetClient:reqConsignableItems(result)
	local msg = BuildBA(NetProtocol.cReqGetConsignableItems)
	msg:writeInt(result.type)
	msg:writeInt(result.index)
	msg:writeInt(result.job)
	msg:writeInt(result.level)
	msg:writeString(result.filter)
	self:sendMsg(msg)
end

--购买寄售物品
function NetClient:reqBuyConsignItem(result)
	local msg = BuildBA(NetProtocol.cReqBuyConsignableItem)
	msg:writeInt(result.mSeedId)
	self:sendMsg(msg)
end

--寄售下架
function NetClient:reqTakeBackConsignableItem(result)
	local msg = BuildBA(NetProtocol.cReqTakeBackConsignableItem)
	msg:writeInt(result.mSeedId)
	self:sendMsg(msg)
end

--提取寄售收益
function NetClient:reqTakeBackVcoin()
	local msg = BuildBA(NetProtocol.cReqTakeBackVCoin)
	self:sendMsg(msg)
end

--请求红包日志
function NetClient:reqGuildRedPacketLog()
	local msg = BuildBA(NetProtocol.cReqGuildRedPacketLog)
	self:sendMsg(msg)
end

--请求帮会仓库日志
function NetClient:reqGuildItemLog()
	local msg = BuildBA(NetProtocol.cReqGuildItemLog)
	self:sendMsg(msg)
end

--请求查询地图上的物体
function NetClient:reqFindMapGhost(mapid,num,name,gtype)
	if not gtype then gtype = 0 end
	if not name then name = "" end

	self.mMapGhostRes = nil
	self.mMapGhostReq = mapid

	--print("reqFindMapGhost========",mapid,num,name,gtype)

	local msg = BuildBA(NetProtocol.cReqFindMapGhost)
	msg:writeString(mapid)
	msg:writeShort(num)
	msg:writeString(name)
	msg:writeShort(gtype)
	self:sendMsg(msg)
end

----------------------------------工具方法--------------------------------

function NetClient:GameEnterMap()

	if not self.mNetMap.mMapID then
		PlatformTool.showMsg("登录失败,请重试")

		game.ExitToRelogin()
	end

	self.mMapGhostReq = nil
	self.mMapGhostRes = nil
	self.mMapGhostMapId = ""
	self.mMapGhostList = {}
	self.mMapMonGenId = ""
	self.mMapMonGen = {}

	MainRole.setMapGhostList()
	MainRole.updateAttr()
	MainRole.stopAutoFight()
	-- MainRole.addGhostEffect(MainRole.mID,990013,"entermap")
	--PlayAudio.mapMusic(self.mNetMap.mMapID)
	----print("self.mNetMap.mMapID=======",self.mNetMap.mMapID)
	if not MAIN_IS_IN_GAME then

	-- 	if CONFIG_IS_DEBUG == 1 then
	-- 		cc.Director:getInstance():runWithScene(GameScene.new())
	-- 	else
			-- cc.Director:getInstance():replaceScene(cc.SceneGame:create())
	-- 	end
	else
		cc.GhostManager:getInstance():remAllEffect()
		cc.GhostManager:getInstance():remAllSkill()
		cc.CacheManager:getInstance():releaseUnused(false)
	end
	self:alertLocalMsg(self.mNetMap.mName,"map")	--进入地图提示消息
	self:dispatchEvent({name = Notify.EVENT_CHANGE_MAP})
	self:dispatchEvent({name = Notify.EVENT_MOVE_END})
	self:dispatchEvent({name = Notify.EVENT_MAP_ENTER, PkEnable = table.indexof(self.PKMapIds, self.mNetMap.mMapID)})
	self:dispatchEvent({name = Notify.EVENT_CLOSE_PANEL, str = "panel_minimap"})
	if self.mNeedContinueTask then
		self:dispatchEvent({name = Notify.EVENT_CONTINUE_TASK})
		self.mNeedContinueTask = false
	end

	--  -- 邪恶龙神剧情
	-- if self.mNetMap.mName == "邪恶领地[副本]" then
	-- 	local tid, ts = self:checkTaskState(1000)
	-- 	if tid == 26 and ts < 4 then
	-- 		self:dispatchEvent({name = Notify.EVENT_SHOW_STORY_LINE, lv = 1000, callback = function ()
 --  				self:PushLuaTable("map.raid_main_task1.handleTimerStart", "")
 --  				MainRole.startAutoFight()
 --  			end})
	-- 	end
	-- end

	UILeftTop.resetTick()
	-- --进入皇宫取消坐骑
	local forbidMountMap = {"v925"}
	if table.indexof(forbidMountMap,self.mNetMap.mMapID) and MainRole._mainAvatar then
		local mModels = self.mModels[MainRole._mainAvatar:NetAttr(Const.net_id)]
		if mModels[7] and mModels[7]>0 and MainRole._mainAvatar:NetAttr(Const.net_mount)>0 and MainRole._mainAvatar:NetAttr(Const.net_level)>=65 then
			self:PushLuaTable("gui.PanelMount.onPanelData",util.encode({ actionid= "mounting"}))
			self:ChangeMount()
		end
	end
end

--equipGroup	套装组
--num			套装数
--对应套装id     套装组*100 + 套装数得到相应套装属性
function NetClient:getEquipSuitAttr(equipGroup, num,itemDef,mEquipGroup)
	--print("0000")
	if self.mEquipsSuit[equipGroup+ num] then
	--print("001110201100")
		return self.mEquipsSuit[equipGroup + num]
		
	end
	return nil
end

-- 根据套装组获取当前所有套装
function NetClient:getEquipByGroup(equipGroup, job, gender)
	local items = {}
	--local gender = MainRole._mainAvatar:NetAttr(Const.net_gender)
	for k, v in pairs(self.mItemDesp) do
		local item = {}
		item.mTypeID = v.mTypeID
		if game.IsXZ(v.mTypeID) or game.IsXQ(v.mTypeID) then
			if v.mEquipGroup == equipGroup then
				item.ePos = v.mEquipType * -2
				--item.noType = true
				table.insert(items, item)
			end
		elseif game.IsEquipment(v.mTypeID) then
			if v.mEquipGroup == equipGroup and v.mJob == job and v.mEquipGroup >= 200 then
				-- 找到套装组
				item.ePos = v.mEquipType * -2
				item.mEquipType = v.mEquipType
				item.mEquipGroup = v.mEquipGroup
				if v.mEquipType == 5 or v.mEquipType == 6 then item.fPos = v.mEquipType * -2 - 1  end
				if v.mGender > 0 then
					if v.mGender == gender then
						table.insert(items, item)
					end
				else
					table.insert(items, item)
				end

				-- local equipType = v.mEquipType
				-- if v.mEquipType == 5 or v.mEquipType == 6 then
				-- 	local tItem = {}
				-- 	if v.mEquipType == 6 then 
				-- 		equipType = 5
				-- 	else
				-- 		equipType = 4
				-- 	end

				-- 	tItem.ePos = v.mEquipType * -2
				-- 	tItem.fPos = equipType * -2 - 2
				-- 	tItem.f2Pos = equipType * -2 - 3
				-- 	--print(tItem.f2Pos)
				-- 	tItem.mTypeID = v.mTypeID
				-- 	tItem.mEquipType = v.mEquipType
				-- 	tItem.mEquipGroup = v.mEquipGroup
				-- 	dump(tItem)
				-- 	local isFind = false
				-- 	for i=1,#items do
				-- 		if items[i].mEquipType == tItem.mEquipType and items[i].mEquipGroup == tItem.mEquipGroup then
				-- 			isFind = true
				-- 		end
				-- 	end
				-- 	if not isFind then
				-- 		table.insert(items, tItem)
				-- 	end
				-- end
			end
		end
	end	
	--对items 进行过滤

	return items
end

-- 根据套装组获取其他玩家的所有套装 isDress 是否穿戴
function NetClient:getOtherEquipByGroup(equipGroup, job, gender)
	local items = {}
	--local gender = MainRole._mainAvatar:NetAttr(Const.net_gender)
	for k, v in pairs(self.mOthersItems) do
		local item = {}
		item.mTypeID = v.mTypeID
		local itemdef = self:getItemDefByID(v.mTypeID)
		if game.IsXZ(itemdef.mTypeID) or game.IsXQ(itemdef.mTypeID) then
			if itemdef.mEquipGroup == equipGroup then
				item.noType = true
				table.insert(items, item)
			end
		elseif game.IsEquipment(v.mTypeID) then
			if itemdef.mEquipGroup == equipGroup and itemdef.mJob == job then
				item.ePos = itemdef.mEquipType * -2
				if itemdef.mGender > 0 then
					if itemdef.mGender == gender then
						table.insert(items, item)
					end
				else
					table.insert(items, item)
				end
			end
		end
	end	

	return items
end

function NetClient:getPlayerModel(srcid,mid)
	if self.mModels and self.mModels[srcid] then
		if self.mModels[srcid][mid] then
			return self.mModels[srcid][mid]
		end
	end
	return 0
end

function NetClient:getSSEquipAttr(id)
	if self.mShengshiList[id] then
		return self.mShengshiList[id]
	end
	return nil
end

function NetClient:getItemDefByPos(pos)
	local netItem = self:getNetItem(pos)
	if netItem then
		return self:getItemDefByID(netItem.mTypeID)
	end
	return nil
end

function NetClient:getItemDefByID(typeid)
	if self.mItemDesp[typeid] then
		return self.mItemDesp[typeid]
	else
		self:GetItemDesp(typeid,"")
	end
	return nil
end

function NetClient:getItemDefByName(name)
	for itemid,item in pairs(self.mItemDesp) do
		if item.mName == name then
			return item
		end
	end
	self:GetItemDesp(-1,name)
	return nil
end

function NetClient:getItemPosByType(typeid)
	for pos,item in pairs(self.mItems) do
		if item and game.IsPosInBag(item.position) then
			if item.mTypeID == typeid then
				return pos
			end
		end
	end
	return -999
end

function NetClient:hasItem(name)
	local itemdef = self:getItemDefByName(name)
	if not itemdef then return false end

	for pos,item in pairs(self.mItems) do
		if item and game.IsPosInBag(item.position) then
			if item.mTypeID == itemdef.mTypeID then
				return true
			end
		end
	end
	return false
end

function NetClient:dispatchChangeAlertMsg(str1,str2,change)
	local msg = {
		[1] = {"获得了物品:", "30FF00"},
	}
	if change ~= 0 then
		if change > 0 then
			msg[1][1] = str1..change
			self:alertLocalMsg(util.encode(msg),"right")
		else
			msg[1][1] = str2..(-change)
			self:alertLocalMsg(util.encode(msg),"right")
		end
	end
end

function NetClient:alertLocalMsg(msg,mtype,param,firstInQueue)
	if util.decode(msg) then
		param = util.decode(msg)
		if param.msg then
			msg = param.msg
		end
	end
	-- msg = game.clearHtmlText(msg)
	if not mtype then mtype="alert" end
	table.insert(self["m_alertList"..string.ucfirst(mtype)],msg)
	param = param or {}
	param.firstInQueue = firstInQueue
	--print("alertLocalMsg", msg, mtype);
	self:dispatchEvent({name=Notify.EVENT_ADD_ALERT,msg=msg,type=mtype, param = param})
end

function NetClient:getNetItem(pos)
	if self.mItems[pos] then
		return self.mItems[pos]
	else
		return nil
	end
end

function NetClient:getQiangHuaItem(pos)
	if self.mEquipItems[pos] then
		return self.mEquipItems[pos]
	else
		return nil
	end
end

function NetClient:getNetItemById(typeid)
	for i=0,Const.ITEM_BAG_SIZE + self.mBagSlotAdd - 1 do
		if self.mItems[i] then
			if self.mItems[i].mTypeID == typeid then
				return i
			end
		end
	end
	return nil
end

function NetClient:getTypeItemNum(typeid)
	local num=0
	for i=0,Const.ITEM_BAG_SIZE + self.mBagSlotAdd - 1 do
		if self.mItems[i] then
			if self.mItems[i].mTypeID == typeid then
				num=num+self.mItems[i].mNumber
			end
		end
	end
	return num
end

function NetClient:getBagCount()
	local count = 0
	for i=0,Const.ITEM_BAG_SIZE + self.mBagSlotAdd - 1 do
		if self.mItems[i] then
			count = count + 1
		end
	end
	return count
end

function NetClient:isBagFull()
	return self:getBagCount() >= Const.ITEM_BAG_SIZE + self.mBagSlotAdd
end

function NetClient:isPosInBag(pos)
	return (pos>=0 and pos<Const.ITEM_BAG_SIZE + self.mBagSlotAdd)
end

function NetClient:getLeftBagNum()
	return Const.ITEM_BAG_SIZE + self.mBagSlotAdd - self:getBagCount()
end

function NetClient:checkBagFull(pos)--检查背包是否已满
	local leftBagNum = self:getLeftBagNum()
	if leftBagNum <= 3 then
		-- if not self.tipsMsg["tip_bag_full"] then
		-- 	self.tipsMsg["tip_bag_full"] = {"full"}
		-- 	self:dispatchEvent({name = Notify.EVENT_SHOW_BOTTOM,str="tip_bag_full"})
		-- end
		self:dispatchEvent({name=Notify.EVENT_BAG_UNFULL,vis = true})
	else
		-- if self.tipsMsg["tip_bag_full"] and #self.tipsMsg["tip_bag_full"]>0 then
		-- end
		self:dispatchEvent({name=Notify.EVENT_BAG_UNFULL,vis = false})
	end
end

function NetClient:checkBagRedDot()
	local showDot = false
	for i=0,Const.ITEM_BAG_SIZE + self.mBagSlotAdd - 1 do
		if self.mItems[i] and game.checkItemShowUse(self.mItems[i].mTypeID) then
			showDot = true
			break
		end
	end

	-- if showDot and not self.mIsBagShowRedDot then
	-- 	self:dispatchEvent({name = Notify.EVENT_SHOW_REDPOINT, lv = 2071,index = 1})
	-- elseif not showDot and self.mIsBagShowRedDot then
	-- 	self:dispatchEvent({name = Notify.EVENT_REMOVE_REDPOINT, lv = 2071,index = 1})
	-- end
	self.mIsBagShowRedDot = showDot
	if showDot then
		self:dispatchEvent({name = Notify.EVENT_SHOW_REDPOINT, lv = 2071,index = 1})
	else
		self:dispatchEvent({name = Notify.EVENT_REMOVE_REDPOINT, lv = 2071,index = 1})
	end
end

function NetClient:getServerParam(index)
	if self.mParam[MainRole.mID][index] then
		return self.mParam[MainRole.mID][index]
	end
	return 0
end

function NetClient:addToMsgHistory(netChat)
	if self:getRelation(netChat.m_strName)==102 then return end
	table.insert(self.mChatHistroy,netChat)
	if #self.mChatHistroy > 200 then
		table.remove(self.mChatHistroy,1)
	end
	self:dispatchEvent({name = Notify.EVENT_CHAT_MSG,msg = netChat})
end

-- -- [2]文字信息  [3]本地  [4]http  [5]时长
-- function NetClient:saveNetVoiceMsg(params)
-- 	--"onVoice",charStr,localStr,httpStr,duration
-- 	self:dispatchEvent({name = Notify.EVENT_VOICE_HANDLE_MSG, params = params})
-- end

-- function NetClient:onChangeTroopModel( model,isLeader )
-- 	self:dispatchEvent({name = Notify.EVENT_VOICE_MODEL_CHANGE,model = model,isLeader = isLeader})
-- end

function NetClient:privateChatTo(name)
	if name == self.mCharacter.mName then
		return
	end
	self.m_strPrivateChatTarget = name

	self:dispatchEvent({name = Notify.EVENT_OPEN_PANEL,str="panel_chat", tab = 3})
end

function NetClient:getRelation(name)
	self.mFriends = self.mFriends or {}
	if name and self.mFriends[name] then
		return checkint(self.mFriends[name].title)
	end
	return 0
end

function NetClient:getPlayerInfo(name)--获取玩家信息
	if not name then return end
	local info
	self.mFriends = self.mFriends or {}
	for _,v in pairs(self.mFriends) do
		if v.name == name then
			info = v
		end
	end
	if not info then
		local pGhost=NetCC:findGhostByName(name)
		if pGhost then
			info = {
				name = pGhost:NetAttr(Const.net_name),
				level = pGhost:NetAttr(Const.net_level),
				title = 0,
				online_state = 1,
				job = pGhost:NetAttr(Const.net_job),
				gender = pGhost:NetAttr(Const.net_gender),
				guild = pGhost:NetAttr(Const.net_guild_name),
			}
			self.mFriends[name] = info
		end
	end
	return info
end

function NetClient:removeChatRecentPlayer(name)--删除最近聊天记录
	if self.m_strPrivateChatTarget == name then
		self.m_strPrivateChatTarget = nil
	end
	for i,v in ipairs(self.chatRecent) do
		if v.name == name then
			table.remove(self.chatRecent,i)
		end
	end
	self:dispatchEvent({name = Notify.EVENT_CHAT_RECENT,str="private"})
end

function NetClient:addChatRecentPlayer(name)--添加最近聊天记录
	self.m_strPrivateChatTarget = name
	local change,exist = true,nil
	for i,v in ipairs(self.chatRecent) do
		if v.name == name then
			if i == 1 then
				change = false--此人正是第一个最近联系人不改变列表顺序
			end
			exist = i
			break;
		end
	end
	if change then
		local playerInfo = self:getPlayerInfo(name)
		if playerInfo then
			if exist then
				self.chatRecent[exist] = self.chatRecent[1]
				self.chatRecent[1] = playerInfo
			else
				table.insert(self.chatRecent,1,playerInfo)
			end
		end
		self:dispatchEvent({name = Notify.EVENT_CHAT_RECENT,str="private"})
	end
end

function NetClient:getGuildByName(pName)--获取帮会名称
	for i=1,#self.mGuildList do
		if self.mGuildList[i].mName == pName then
			return self.mGuildList[i]
		end
	end
	return nil
end

function NetClient:SeparateVipAndMsg(strMsg)
	local msg,localPath,httpPath,duration,flag = strMsg,nil,nil,0,0
	if string.find(msg,"<voice>") then
		--print("SeparateVipAndMsg   ",msg)
		local params = string.split(msg,"|")
		if #params>=3 then
			httpPath = util.FromBase64(params[2])
			flag = params[3]
			localPath = util.FromBase64(params[4])
			duration = checknumber(params[5])
			msg = "语音消息"
		end
	end
	return msg,localPath,httpPath,duration,flag
end

--检测物品是否可用（每日限制）
function NetClient:canItemUse(typeID)
	----print("canItemUse///////////////////////////////", typeID, self.itemDailyUseLimit[typeID])
	if self.itemDailyUseLimit[typeID] then
		----print("111111111111111111111111111111", self.itemDailyUseLimit[typeID].leftTimes, self.itemDailyUseLimit[typeID].totalTimes, self.itemDailyUseLimit[typeID].id)
		return self.itemDailyUseLimit[typeID].leftTimes > 0
	else
		return true
	end
end
--------------------------本地存储交易记录--------------------------

function NetClient:storeTradeRecord(name)
	local strName = name
	if not strName then
		if MainRole._mainAvatar then strName = game.seedName end
	end
	if strName then
		local tempjson=util.encode(self.mTradeLocalRecord)
		if tempjson then
			local enjson=cc.DataBase64:EncodeData(tempjson)
			cc.UserDefault:getInstance():setStringForKey("tradeRecord"..strName, enjson)
			cc.UserDefault:getInstance():flush()
		end
	end
end

function NetClient:checkTaskState(taskid)
	if self.mTasks[taskid] then
		local tid = math.floor(self.mTasks[taskid].mState / 10)
		local ts = math.fmod(self.mTasks[taskid].mState, 10)
		return tid, ts
	end
end

function NetClient:checkGuiButton(name)
	-- --print("///////////checkExtendShow//////////", util.encode(NetClient.mExtendButtons))
	if PLATFORM_BANSHU then --版署版本寻宝不可用
		if name == "btn_main_boss" then
			return false
		end
	end
	if self.mExtendButtons and table.indexof(self.mExtendButtons, name) then
		return true
	end
	return false
end

function NetClient:checkFuncOpenedByID(funcid)
	if funcid and self.mAllFuncs[funcid] then
		return self.mAllFuncs[funcid].opened, self.mAllFuncs[funcid].level, self.mAllFuncs[funcid].funcname
	else
		return true
	end
end

function NetClient:checkFuncOpened(name)
	-- --print(util.encode(self.mBasicButtons))
	if string.sub(name,0,5) == "main_" then
		name = "btn_"..name
	end

	if self.mBasicButtons[name] then
		return self.mBasicButtons[name].opened, self.mBasicButtons[name].level, self.mBasicButtons[name].funcname
	else
		return true
	end
end

function NetClient:takeItemFromLottory(itemPos)
	if game.IsPosInLottoryDepot(itemPos) and self:getNetItem(itemPos) then
		for pos = Const.ITEM_BAG_BEGIN, Const.ITEM_BAG_BEGIN + Const.ITEM_BAG_SIZE + self.mBagSlotAdd - 1 do
			if not self:getNetItem(pos) then -- 表示空位
				NetClient:ItemPositionExchange(itemPos, pos)
				return true
			end
		end
	end
end

function NetClient:getMonsterOwner(monId)
	return self.mMonsterOwner[monId];
end

-- 主界面右上角按钮光晕
function NetClient:addExtendHalo(name)
	if name then
		table.insert(self.mExtendHalos, name)
	end
end

function NetClient:checkExtendHalo(name)
	return table.indexof(self.mExtendHalos, name);
end

function NetClient:isGroupMember(name)
	for i,v in ipairs(self.mGroupMembers) do
		if name == v.name then
			return true
		end
	end
	return false
end
----------------------------------system----------------------------------



----------------------------------socket----------------------------------

local socketdelay = nil

local function delayback()

	game.disEnterButton=false

	if socketdelay then
		Scheduler.unscheduleGlobal(socketdelay)
		socketdelay=nil
	end			
end

function NetClient:connect(__host, __port, connectType)
	local CONNECT_TYPES = {
		KUAFU	= 1,
		BACK	= 2,
		GAME    = 3,		--游戏内掉线
	}

	if socketdelay then
		return
	end

	if self._connected==true then
		self:disconnect()
	end

	if self._connected==false then

		game.disEnterButton = true

		socketdelay = Scheduler.scheduleGlobal(delayback,5.0)

		--print("connect",__host,__port, connectType)

		SocketManager:startSocketAsync(__host,__port,function(result)
			self._connected=result
			if result then
				game.initTime=cc.SystemUtil:getTime()
				--print("connected initTime",game.initTime)

				if connectType == CONNECT_TYPES.GAME then
					self:dispatchEvent({name=Notify.EVENT_CONNECT_GAME_ON})
				else
					self:dispatchEvent({name=Notify.EVENT_CONNECT_ON})
				end

				if connectType == CONNECT_TYPES.KUAFU then
					self:KuafuAuth(self.kuaFuInfo)
				elseif connectType == CONNECT_TYPES.BACK then
					self:Authenticate(103,game.gameKey,0,0)
				end
			else
				game.disEnterButton = false
			end
		end)
	end
end

-- function NetClient:connect(__host, __port)

-- 	self:disconnect()

-- 	if self._connected==false then
-- 		--print("connect",__host,__port)
-- 		if SocketManager:startSocket(__host,__port) then

-- 			self._connected=true

-- 			game.initTime=cc.SystemUtil:getTime()
-- 			--print("connected initTime",game.initTime)

-- 			self:dispatchEvent({name=Notify.EVENT_CONNECT_ON})

-- 			if connectType == CONNECT_TYPES.KUAFU then
-- 				self:KuafuAuth(self.kuaFuInfo)
-- 			elseif connectType == CONNECT_TYPES.BACK then
-- 				self:Authenticate(103,game.gameKey,0,0)
-- 			end
-- 		else
-- 			self:dispatchEvent({name=Notify.EVENT_CONNECT_FAILED})
-- 		end
-- 	end
-- end

function NetClient:onMessage(mMsg)
	self:ParseMsg(mMsg)
end

function NetClient:disconnect(reinit)
	if socketdelay then
		Scheduler.unscheduleGlobal(socketdelay)
		socketdelay=nil
	end

	game.disEnterButton = false

	SocketManager:stopSocket()

	if not reinit then
		cc.NetClient:getInstance():initClient()
	end

	self._connected=false
end

function NetClient:sendMsg(msg)
	SocketManager:sendPacket()
	-- --print("sendMsg",self.mPingDelay)
	if self.mPingDelay == 0 then
		self.mPingDelay = game.ClockTick
	end
end

function SendHttp(senUrl)
	--print("发送请求:"..senUrl);
	
	if not senUrl then
		return
	end
	local http=cc.XMLHttpRequest:new()
	http.responseType = cc.XMLHTTPREQUEST_RESPONSE_JSON
	http:open("GET", senUrl)
	local function callback()
		local state=http.status
		--print("-------state = "..state.."  data: "..http.response)
		if state==200 then
			local response=http.response
			local json=string.gsub(utilapp.unicode_to_utf8(response),"\\","")
			json=utilapp.decode(json)
			if type(json)=="table" and json.code then
				local code = tonumber(json["code"]);
				if code == 0 then
					PlatformTool.showMsg("提现成功请等待GM打款！");
				elseif code == -1 then
					--已经注册
					PlatformTool.showMsg("提现失败");
				end
			end
		else
		end
	end
	http:registerScriptHandler(callback)
	http:send()
end

return NetClient:new()